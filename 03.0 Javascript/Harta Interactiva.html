<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

</head>
<body>
    <div id="map" class="romania">

</div>
    <h1 id="region-name">Test</h1>
    <script>
        // ┌───────────────────────────────────────────────────────────────────────────────────────────────────────┐ \\
        // │ Raphaël 2.2.0 - JavaScript Vector Library                                                             │ \\
        // ├───────────────────────────────────────────────────────────────────────────────────────────────────────┤ \\
        // │ Copyright © 2008-2016 Dmitry Baranovskiy (http://raphaeljs.com)                                       │ \\
        // │ Copyright © 2008-2016 Sencha Labs (http://sencha.com)                                                 │ \\
        // ├───────────────────────────────────────────────────────────────────────────────────────────────────────┤ \\
        // │ Licensed under the MIT (https://github.com/DmitryBaranovskiy/raphael/blob/master/license.txt) license.│ \\
        // └───────────────────────────────────────────────────────────────────────────────────────────────────────┘ \\

        (function webpackUniversalModuleDefinition(root, factory) {
            if(typeof exports === 'object' && typeof module === 'object')
                module.exports = factory();
            else if(typeof define === 'function' && define.amd)
                define([], factory);
            else if(typeof exports === 'object')
                exports["Raphael"] = factory();
            else
                root["Raphael"] = factory();
        })(this, function() {
            return /******/ (function(modules) { // webpackBootstrap
                /******/ 	// The module cache
                /******/ 	var installedModules = {};

                /******/ 	// The require function
                /******/ 	function __webpack_require__(moduleId) {

                    /******/ 		// Check if module is in cache
                    /******/ 		if(installedModules[moduleId])
                    /******/ 			return installedModules[moduleId].exports;

                    /******/ 		// Create a new module (and put it into the cache)
                    /******/ 		var module = installedModules[moduleId] = {
                        /******/ 			exports: {},
                        /******/ 			id: moduleId,
                        /******/ 			loaded: false
                        /******/ 		};

                    /******/ 		// Execute the module function
                    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

                    /******/ 		// Flag the module as loaded
                    /******/ 		module.loaded = true;

                    /******/ 		// Return the exports of the module
                    /******/ 		return module.exports;
                    /******/ 	}


                /******/ 	// expose the modules object (__webpack_modules__)
                /******/ 	__webpack_require__.m = modules;

                /******/ 	// expose the module cache
                /******/ 	__webpack_require__.c = installedModules;

                /******/ 	// __webpack_public_path__
                /******/ 	__webpack_require__.p = "";

                /******/ 	// Load entry module and return exports
                /******/ 	return __webpack_require__(0);
                /******/ })
            /************************************************************************/
            /******/ ([
                /* 0 */
                /***/ function(module, exports, __webpack_require__) {

                    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function(R) {

                        return R;

                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

                    /***/ },
                /* 1 */
                /***/ function(module, exports, __webpack_require__) {

                    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function(eve) {

                        /*\
                         * Raphael
                         [ method ]
                         **
                         * Creates a canvas object on which to draw.
                         * You must do this first, as all future calls to drawing methods
                         * from this instance will be bound to this canvas.
                         > Parameters
                         **
                         - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface
                         - width (number)
                         - height (number)
                         - callback (function) #optional callback function which is going to be executed in the context of newly created paper
                         * or
                         - x (number)
                         - y (number)
                         - width (number)
                         - height (number)
                         - callback (function) #optional callback function which is going to be executed in the context of newly created paper
                         * or
                         - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.
                         - callback (function) #optional callback function which is going to be executed in the context of newly created paper
                         * or
                         - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eve’s “DOMLoad” event. In this case method returns `undefined`.
                         = (object) @Paper
                         > Usage
                         | // Each of the following examples create a canvas
                         | // that is 320px wide by 200px high.
                         | // Canvas is created at the viewport’s 10,50 coordinate.
                         | var paper = Raphael(10, 50, 320, 200);
                         | // Canvas is created at the top left corner of the #notepad element
                         | // (or its top right corner in dir="rtl" elements)
                         | var paper = Raphael(document.getElementById("notepad"), 320, 200);
                         | // Same as above
                         | var paper = Raphael("notepad", 320, 200);
                         | // Image dump
                         | var set = Raphael(["notepad", 320, 200, {
                         |     type: "rect",
                         |     x: 10,
                         |     y: 10,
                         |     width: 25,
                         |     height: 25,
                         |     stroke: "#f00"
                         | }, {
                         |     type: "text",
                         |     x: 30,
                         |     y: 40,
                         |     text: "Dump"
                         | }]);
                         \*/
                        function R(first) {
                            if (R.is(first, "function")) {
                                return loaded ? first() : eve.on("raphael.DOMload", first);
                            } else if (R.is(first, array)) {
                                return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
                            } else {
                                var args = Array.prototype.slice.call(arguments, 0);
                                if (R.is(args[args.length - 1], "function")) {
                                    var f = args.pop();
                                    return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on("raphael.DOMload", function () {
                                            f.call(R._engine.create[apply](R, args));
                                        });
                                } else {
                                    return R._engine.create[apply](R, arguments);
                                }
                            }
                        }
                        R.version = "2.2.0";
                        R.eve = eve;
                        var loaded,
                            separator = /[, ]+/,
                            elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},
                            formatrg = /\{(\d+)\}/g,
                            proto = "prototype",
                            has = "hasOwnProperty",
                            g = {
                                doc: document,
                                win: window
                            },
                            oldRaphael = {
                                was: Object.prototype[has].call(g.win, "Raphael"),
                                is: g.win.Raphael
                            },
                            Paper = function () {
                                /*\
                                 * Paper.ca
                                 [ property (object) ]
                                 **
                                 * Shortcut for @Paper.customAttributes
                                 \*/
                                /*\
                                 * Paper.customAttributes
                                 [ property (object) ]
                                 **
                                 * If you have a set of attributes that you would like to represent
                                 * as a function of some number you can do it easily with custom attributes:
                                 > Usage
                                 | paper.customAttributes.hue = function (num) {
                                 |     num = num % 1;
                                 |     return {fill: "hsb(" + num + ", 0.75, 1)"};
                                 | };
                                 | // Custom attribute “hue” will change fill
                                 | // to be given hue with fixed saturation and brightness.
                                 | // Now you can use it like this:
                                 | var c = paper.circle(10, 10, 10).attr({hue: .45});
                                 | // or even like this:
                                 | c.animate({hue: 1}, 1e3);
                                 |
                                 | // You could also create custom attribute
                                 | // with multiple parameters:
                                 | paper.customAttributes.hsb = function (h, s, b) {
                                 |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
                                 | };
                                 | c.attr({hsb: "0.5 .8 1"});
                                 | c.animate({hsb: [1, 0, 0.5]}, 1e3);
                                 \*/
                                this.ca = this.customAttributes = {};
                            },
                            paperproto,
                            appendChild = "appendChild",
                            apply = "apply",
                            concat = "concat",
                            supportsTouch = ('ontouchstart' in g.win) || g.win.DocumentTouch && g.doc instanceof DocumentTouch, //taken from Modernizr touch test
                            E = "",
                            S = " ",
                            Str = String,
                            split = "split",
                            events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[split](S),
                            touchMap = {
                                mousedown: "touchstart",
                                mousemove: "touchmove",
                                mouseup: "touchend"
                            },
                            lowerCase = Str.prototype.toLowerCase,
                            math = Math,
                            mmax = math.max,
                            mmin = math.min,
                            abs = math.abs,
                            pow = math.pow,
                            PI = math.PI,
                            nu = "number",
                            string = "string",
                            array = "array",
                            toString = "toString",
                            fillString = "fill",
                            objectToString = Object.prototype.toString,
                            paper = {},
                            push = "push",
                            ISURL = R._ISURL = /^url\(['"]?(.+?)['"]?\)$/i,
                            colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
                            isnan = {"NaN": 1, "Infinity": 1, "-Infinity": 1},
                            bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
                            round = math.round,
                            setAttribute = "setAttribute",
                            toFloat = parseFloat,
                            toInt = parseInt,
                            upperCase = Str.prototype.toUpperCase,
                            availableAttrs = R._availableAttrs = {
                                "arrow-end": "none",
                                "arrow-start": "none",
                                blur: 0,
                                "clip-rect": "0 0 1e9 1e9",
                                cursor: "default",
                                cx: 0,
                                cy: 0,
                                fill: "#fff",
                                "fill-opacity": 1,
                                font: '10px "Arial"',
                                "font-family": '"Arial"',
                                "font-size": "10",
                                "font-style": "normal",
                                "font-weight": 400,
                                gradient: 0,
                                height: 0,
                                href: "http://raphaeljs.com/",
                                "letter-spacing": 0,
                                opacity: 1,
                                path: "M0,0",
                                r: 0,
                                rx: 0,
                                ry: 0,
                                src: "",
                                stroke: "#000",
                                "stroke-dasharray": "",
                                "stroke-linecap": "butt",
                                "stroke-linejoin": "butt",
                                "stroke-miterlimit": 0,
                                "stroke-opacity": 1,
                                "stroke-width": 1,
                                target: "_blank",
                                "text-anchor": "middle",
                                title: "Raphael",
                                transform: "",
                                width: 0,
                                x: 0,
                                y: 0,
                                "class": ""
                            },
                            availableAnimAttrs = R._availableAnimAttrs = {
                                blur: nu,
                                "clip-rect": "csv",
                                cx: nu,
                                cy: nu,
                                fill: "colour",
                                "fill-opacity": nu,
                                "font-size": nu,
                                height: nu,
                                opacity: nu,
                                path: "path",
                                r: nu,
                                rx: nu,
                                ry: nu,
                                stroke: "colour",
                                "stroke-opacity": nu,
                                "stroke-width": nu,
                                transform: "transform",
                                width: nu,
                                x: nu,
                                y: nu
                            },
                            whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,
                            commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,
                            hsrg = {hs: 1, rg: 1},
                            p2s = /,?([achlmqrstvxz]),?/gi,
                            pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
                            tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
                            pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,
                            radial_gradient = R._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/,
                            eldata = {},
                            sortByKey = function (a, b) {
                                return a.key - b.key;
                            },
                            sortByNumber = function (a, b) {
                                return toFloat(a) - toFloat(b);
                            },
                            fun = function () {},
                            pipe = function (x) {
                                return x;
                            },
                            rectPath = R._rectPath = function (x, y, w, h, r) {
                                if (r) {
                                    return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
                                }
                                return [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
                            },
                            ellipsePath = function (x, y, rx, ry) {
                                if (ry == null) {
                                    ry = rx;
                                }
                                return [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
                            },
                            getPath = R._getPath = {
                                path: function (el) {
                                    return el.attr("path");
                                },
                                circle: function (el) {
                                    var a = el.attrs;
                                    return ellipsePath(a.cx, a.cy, a.r);
                                },
                                ellipse: function (el) {
                                    var a = el.attrs;
                                    return ellipsePath(a.cx, a.cy, a.rx, a.ry);
                                },
                                rect: function (el) {
                                    var a = el.attrs;
                                    return rectPath(a.x, a.y, a.width, a.height, a.r);
                                },
                                image: function (el) {
                                    var a = el.attrs;
                                    return rectPath(a.x, a.y, a.width, a.height);
                                },
                                text: function (el) {
                                    var bbox = el._getBBox();
                                    return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
                                },
                                set : function(el) {
                                    var bbox = el._getBBox();
                                    return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
                                }
                            },
                                /*\
                                 * Raphael.mapPath
                                 [ method ]
                                 **
                                 * Transform the path string with given matrix.
                                 > Parameters
                                 - path (string) path string
                                 - matrix (object) see @Matrix
                                 = (string) transformed path string
                                 \*/
                            mapPath = R.mapPath = function (path, matrix) {
                                if (!matrix) {
                                    return path;
                                }
                                var x, y, i, j, ii, jj, pathi;
                                path = path2curve(path);
                                for (i = 0, ii = path.length; i < ii; i++) {
                                    pathi = path[i];
                                    for (j = 1, jj = pathi.length; j < jj; j += 2) {
                                        x = matrix.x(pathi[j], pathi[j + 1]);
                                        y = matrix.y(pathi[j], pathi[j + 1]);
                                        pathi[j] = x;
                                        pathi[j + 1] = y;
                                    }
                                }
                                return path;
                            };

                        R._g = g;
                        /*\
                         * Raphael.type
                         [ property (string) ]
                         **
                         * Can be “SVG”, “VML” or empty, depending on browser support.
                         \*/
                        R.type = (g.win.SVGAngle || g.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");
                        if (R.type == "VML") {
                            var d = g.doc.createElement("div"),
                                b;
                            d.innerHTML = '<v:shape adj="1"/>';
                            b = d.firstChild;
                            b.style.behavior = "url(#default#VML)";
                            if (!(b && typeof b.adj == "object")) {
                                return (R.type = E);
                            }
                            d = null;
                        }
                        /*\
                         * Raphael.svg
                         [ property (boolean) ]
                         **
                         * `true` if browser supports SVG.
                         \*/
                        /*\
                         * Raphael.vml
                         [ property (boolean) ]
                         **
                         * `true` if browser supports VML.
                         \*/
                        R.svg = !(R.vml = R.type == "VML");
                        R._Paper = Paper;
                        /*\
                         * Raphael.fn
                         [ property (object) ]
                         **
                         * You can add your own method to the canvas. For example if you want to draw a pie chart,
                         * you can create your own pie chart function and ship it as a Raphaël plugin. To do this
                         * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a
                         * Raphaël instance is created, otherwise it will take no effect. Please note that the
                         * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to
                         * ensure any namespacing ensures proper context.
                         > Usage
                         | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
                         |     return this.path( ... );
                         | };
                         | // or create namespace
                         | Raphael.fn.mystuff = {
                         |     arrow: function () {…},
                         |     star: function () {…},
                         |     // etc…
                         | };
                         | var paper = Raphael(10, 10, 630, 480);
                         | // then use it
                         | paper.arrow(10, 10, 30, 30, 5).attr({fill: "#f00"});
                         | paper.mystuff.arrow();
                         | paper.mystuff.star();
                         \*/
                        R.fn = paperproto = Paper.prototype = R.prototype;
                        R._id = 0;
                        /*\
                         * Raphael.is
                         [ method ]
                         **
                         * Handful of replacements for `typeof` operator.
                         > Parameters
                         - o (…) any object or primitive
                         - type (string) name of the type, i.e. “string”, “function”, “number”, etc.
                         = (boolean) is given value is of given type
                         \*/
                        R.is = function (o, type) {
                            type = lowerCase.call(type);
                            if (type == "finite") {
                                return !isnan[has](+o);
                            }
                            if (type == "array") {
                                return o instanceof Array;
                            }
                            return  (type == "null" && o === null) ||
                                (type == typeof o && o !== null) ||
                                (type == "object" && o === Object(o)) ||
                                (type == "array" && Array.isArray && Array.isArray(o)) ||
                                objectToString.call(o).slice(8, -1).toLowerCase() == type;
                        };

                        function clone(obj) {
                            if (typeof obj == "function" || Object(obj) !== obj) {
                                return obj;
                            }
                            var res = new obj.constructor;
                            for (var key in obj) if (obj[has](key)) {
                                res[key] = clone(obj[key]);
                            }
                            return res;
                        }

                        /*\
                         * Raphael.angle
                         [ method ]
                         **
                         * Returns angle between two or three points
                         > Parameters
                         - x1 (number) x coord of first point
                         - y1 (number) y coord of first point
                         - x2 (number) x coord of second point
                         - y2 (number) y coord of second point
                         - x3 (number) #optional x coord of third point
                         - y3 (number) #optional y coord of third point
                         = (number) angle in degrees.
                         \*/
                        R.angle = function (x1, y1, x2, y2, x3, y3) {
                            if (x3 == null) {
                                var x = x1 - x2,
                                    y = y1 - y2;
                                if (!x && !y) {
                                    return 0;
                                }
                                return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
                            } else {
                                return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
                            }
                        };
                        /*\
                         * Raphael.rad
                         [ method ]
                         **
                         * Transform angle to radians
                         > Parameters
                         - deg (number) angle in degrees
                         = (number) angle in radians.
                         \*/
                        R.rad = function (deg) {
                            return deg % 360 * PI / 180;
                        };
                        /*\
                         * Raphael.deg
                         [ method ]
                         **
                         * Transform angle to degrees
                         > Parameters
                         - rad (number) angle in radians
                         = (number) angle in degrees.
                         \*/
                        R.deg = function (rad) {
                            return Math.round ((rad * 180 / PI% 360)* 1000) / 1000;
                        };
                        /*\
                         * Raphael.snapTo
                         [ method ]
                         **
                         * Snaps given value to given grid.
                         > Parameters
                         - values (array|number) given array of values or step of the grid
                         - value (number) value to adjust
                         - tolerance (number) #optional tolerance for snapping. Default is `10`.
                         = (number) adjusted value.
                         \*/
                        R.snapTo = function (values, value, tolerance) {
                            tolerance = R.is(tolerance, "finite") ? tolerance : 10;
                            if (R.is(values, array)) {
                                var i = values.length;
                                while (i--) if (abs(values[i] - value) <= tolerance) {
                                    return values[i];
                                }
                            } else {
                                values = +values;
                                var rem = value % values;
                                if (rem < tolerance) {
                                    return value - rem;
                                }
                                if (rem > values - tolerance) {
                                    return value - rem + values;
                                }
                            }
                            return value;
                        };

                        /*\
                         * Raphael.createUUID
                         [ method ]
                         **
                         * Returns RFC4122, version 4 ID
                         \*/
                        var createUUID = R.createUUID = (function (uuidRegEx, uuidReplacer) {
                            return function () {
                                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
                            };
                        })(/[xy]/g, function (c) {
                            var r = math.random() * 16 | 0,
                                v = c == "x" ? r : (r & 3 | 8);
                            return v.toString(16);
                        });

                        /*\
                         * Raphael.setWindow
                         [ method ]
                         **
                         * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.
                         > Parameters
                         - newwin (window) new window object
                         \*/
                        R.setWindow = function (newwin) {
                            eve("raphael.setWindow", R, g.win, newwin);
                            g.win = newwin;
                            g.doc = g.win.document;
                            if (R._engine.initWin) {
                                R._engine.initWin(g.win);
                            }
                        };
                        var toHex = function (color) {
                                if (R.vml) {
                                    // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
                                    var trim = /^\s+|\s+$/g;
                                    var bod;
                                    try {
                                        var docum = new ActiveXObject("htmlfile");
                                        docum.write("<body>");
                                        docum.close();
                                        bod = docum.body;
                                    } catch(e) {
                                        bod = createPopup().document.body;
                                    }
                                    var range = bod.createTextRange();
                                    toHex = cacher(function (color) {
                                        try {
                                            bod.style.color = Str(color).replace(trim, E);
                                            var value = range.queryCommandValue("ForeColor");
                                            value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
                                            return "#" + ("000000" + value.toString(16)).slice(-6);
                                        } catch(e) {
                                            return "none";
                                        }
                                    });
                                } else {
                                    var i = g.doc.createElement("i");
                                    i.title = "Rapha\xebl Colour Picker";
                                    i.style.display = "none";
                                    g.doc.body.appendChild(i);
                                    toHex = cacher(function (color) {
                                        i.style.color = color;
                                        return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
                                    });
                                }
                                return toHex(color);
                            },
                            hsbtoString = function () {
                                return "hsb(" + [this.h, this.s, this.b] + ")";
                            },
                            hsltoString = function () {
                                return "hsl(" + [this.h, this.s, this.l] + ")";
                            },
                            rgbtoString = function () {
                                return this.hex;
                            },
                            prepareRGB = function (r, g, b) {
                                if (g == null && R.is(r, "object") && "r" in r && "g" in r && "b" in r) {
                                    b = r.b;
                                    g = r.g;
                                    r = r.r;
                                }
                                if (g == null && R.is(r, string)) {
                                    var clr = R.getRGB(r);
                                    r = clr.r;
                                    g = clr.g;
                                    b = clr.b;
                                }
                                if (r > 1 || g > 1 || b > 1) {
                                    r /= 255;
                                    g /= 255;
                                    b /= 255;
                                }

                                return [r, g, b];
                            },
                            packageRGB = function (r, g, b, o) {
                                r *= 255;
                                g *= 255;
                                b *= 255;
                                var rgb = {
                                    r: r,
                                    g: g,
                                    b: b,
                                    hex: R.rgb(r, g, b),
                                    toString: rgbtoString
                                };
                                R.is(o, "finite") && (rgb.opacity = o);
                                return rgb;
                            };

                        /*\
                         * Raphael.color
                         [ method ]
                         **
                         * Parses the color string and returns object with all values for the given color.
                         > Parameters
                         - clr (string) color string in one of the supported formats (see @Raphael.getRGB)
                         = (object) Combined RGB & HSB object in format:
                         o {
                         o     r (number) red,
                         o     g (number) green,
                         o     b (number) blue,
                         o     hex (string) color in HTML/CSS format: #••••••,
                         o     error (boolean) `true` if string can’t be parsed,
                         o     h (number) hue,
                         o     s (number) saturation,
                         o     v (number) value (brightness),
                         o     l (number) lightness
                         o }
                         \*/
                        R.color = function (clr) {
                            var rgb;
                            if (R.is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
                                rgb = R.hsb2rgb(clr);
                                clr.r = rgb.r;
                                clr.g = rgb.g;
                                clr.b = rgb.b;
                                clr.hex = rgb.hex;
                            } else if (R.is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
                                rgb = R.hsl2rgb(clr);
                                clr.r = rgb.r;
                                clr.g = rgb.g;
                                clr.b = rgb.b;
                                clr.hex = rgb.hex;
                            } else {
                                if (R.is(clr, "string")) {
                                    clr = R.getRGB(clr);
                                }
                                if (R.is(clr, "object") && "r" in clr && "g" in clr && "b" in clr) {
                                    rgb = R.rgb2hsl(clr);
                                    clr.h = rgb.h;
                                    clr.s = rgb.s;
                                    clr.l = rgb.l;
                                    rgb = R.rgb2hsb(clr);
                                    clr.v = rgb.b;
                                } else {
                                    clr = {hex: "none"};
                                    clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
                                }
                            }
                            clr.toString = rgbtoString;
                            return clr;
                        };
                        /*\
                         * Raphael.hsb2rgb
                         [ method ]
                         **
                         * Converts HSB values to RGB object.
                         > Parameters
                         - h (number) hue
                         - s (number) saturation
                         - v (number) value or brightness
                         = (object) RGB object in format:
                         o {
                         o     r (number) red,
                         o     g (number) green,
                         o     b (number) blue,
                         o     hex (string) color in HTML/CSS format: #••••••
                         o }
                         \*/
                        R.hsb2rgb = function (h, s, v, o) {
                            if (this.is(h, "object") && "h" in h && "s" in h && "b" in h) {
                                v = h.b;
                                s = h.s;
                                o = h.o;
                                h = h.h;
                            }
                            h *= 360;
                            var R, G, B, X, C;
                            h = (h % 360) / 60;
                            C = v * s;
                            X = C * (1 - abs(h % 2 - 1));
                            R = G = B = v - C;

                            h = ~~h;
                            R += [C, X, 0, 0, X, C][h];
                            G += [X, C, C, X, 0, 0][h];
                            B += [0, 0, X, C, C, X][h];
                            return packageRGB(R, G, B, o);
                        };
                        /*\
                         * Raphael.hsl2rgb
                         [ method ]
                         **
                         * Converts HSL values to RGB object.
                         > Parameters
                         - h (number) hue
                         - s (number) saturation
                         - l (number) luminosity
                         = (object) RGB object in format:
                         o {
                         o     r (number) red,
                         o     g (number) green,
                         o     b (number) blue,
                         o     hex (string) color in HTML/CSS format: #••••••
                         o }
                         \*/
                        R.hsl2rgb = function (h, s, l, o) {
                            if (this.is(h, "object") && "h" in h && "s" in h && "l" in h) {
                                l = h.l;
                                s = h.s;
                                h = h.h;
                            }
                            if (h > 1 || s > 1 || l > 1) {
                                h /= 360;
                                s /= 100;
                                l /= 100;
                            }
                            h *= 360;
                            var R, G, B, X, C;
                            h = (h % 360) / 60;
                            C = 2 * s * (l < .5 ? l : 1 - l);
                            X = C * (1 - abs(h % 2 - 1));
                            R = G = B = l - C / 2;

                            h = ~~h;
                            R += [C, X, 0, 0, X, C][h];
                            G += [X, C, C, X, 0, 0][h];
                            B += [0, 0, X, C, C, X][h];
                            return packageRGB(R, G, B, o);
                        };
                        /*\
                         * Raphael.rgb2hsb
                         [ method ]
                         **
                         * Converts RGB values to HSB object.
                         > Parameters
                         - r (number) red
                         - g (number) green
                         - b (number) blue
                         = (object) HSB object in format:
                         o {
                         o     h (number) hue
                         o     s (number) saturation
                         o     b (number) brightness
                         o }
                         \*/
                        R.rgb2hsb = function (r, g, b) {
                            b = prepareRGB(r, g, b);
                            r = b[0];
                            g = b[1];
                            b = b[2];

                            var H, S, V, C;
                            V = mmax(r, g, b);
                            C = V - mmin(r, g, b);
                            H = (C == 0 ? null :
                                    V == r ? (g - b) / C :
                                        V == g ? (b - r) / C + 2 :
                                            (r - g) / C + 4
                            );
                            H = ((H + 360) % 6) * 60 / 360;
                            S = C == 0 ? 0 : C / V;
                            return {h: H, s: S, b: V, toString: hsbtoString};
                        };
                        /*\
                         * Raphael.rgb2hsl
                         [ method ]
                         **
                         * Converts RGB values to HSL object.
                         > Parameters
                         - r (number) red
                         - g (number) green
                         - b (number) blue
                         = (object) HSL object in format:
                         o {
                         o     h (number) hue
                         o     s (number) saturation
                         o     l (number) luminosity
                         o }
                         \*/
                        R.rgb2hsl = function (r, g, b) {
                            b = prepareRGB(r, g, b);
                            r = b[0];
                            g = b[1];
                            b = b[2];

                            var H, S, L, M, m, C;
                            M = mmax(r, g, b);
                            m = mmin(r, g, b);
                            C = M - m;
                            H = (C == 0 ? null :
                                M == r ? (g - b) / C :
                                    M == g ? (b - r) / C + 2 :
                                        (r - g) / C + 4);
                            H = ((H + 360) % 6) * 60 / 360;
                            L = (M + m) / 2;
                            S = (C == 0 ? 0 :
                                L < .5 ? C / (2 * L) :
                                    C / (2 - 2 * L));
                            return {h: H, s: S, l: L, toString: hsltoString};
                        };
                        R._path2string = function () {
                            return this.join(",").replace(p2s, "$1");
                        };
                        function repush(array, item) {
                            for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
                                return array.push(array.splice(i, 1)[0]);
                            }
                        }
                        function cacher(f, scope, postprocessor) {
                            function newf() {
                                var arg = Array.prototype.slice.call(arguments, 0),
                                    args = arg.join("\u2400"),
                                    cache = newf.cache = newf.cache || {},
                                    count = newf.count = newf.count || [];
                                if (cache[has](args)) {
                                    repush(count, args);
                                    return postprocessor ? postprocessor(cache[args]) : cache[args];
                                }
                                count.length >= 1e3 && delete cache[count.shift()];
                                count.push(args);
                                cache[args] = f[apply](scope, arg);
                                return postprocessor ? postprocessor(cache[args]) : cache[args];
                            }
                            return newf;
                        }

                        var preload = R._preload = function (src, f) {
                            var img = g.doc.createElement("img");
                            img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
                            img.onload = function () {
                                f.call(this);
                                this.onload = null;
                                g.doc.body.removeChild(this);
                            };
                            img.onerror = function () {
                                g.doc.body.removeChild(this);
                            };
                            g.doc.body.appendChild(img);
                            img.src = src;
                        };

                        function clrToString() {
                            return this.hex;
                        }

                        /*\
                         * Raphael.getRGB
                         [ method ]
                         **
                         * Parses colour string as RGB object
                         > Parameters
                         - colour (string) colour string in one of formats:
                         # <ul>
                         #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>
                         #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>
                         #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>
                         #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>
                         #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>
                         #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>
                         #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
                         #     <li>hsl(•••, •••, •••) — same as hsb</li>
                         #     <li>hsl(•••%, •••%, •••%) — same as hsb</li>
                         # </ul>
                         = (object) RGB object in format:
                         o {
                         o     r (number) red,
                         o     g (number) green,
                         o     b (number) blue
                         o     hex (string) color in HTML/CSS format: #••••••,
                         o     error (boolean) true if string can’t be parsed
                         o }
                         \*/
                        R.getRGB = cacher(function (colour) {
                            if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
                                return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
                            }
                            if (colour == "none") {
                                return {r: -1, g: -1, b: -1, hex: "none", toString: clrToString};
                            }
                            !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
                            var res,
                                red,
                                green,
                                blue,
                                opacity,
                                t,
                                values,
                                rgb = colour.match(colourRegExp);
                            if (rgb) {
                                if (rgb[2]) {
                                    blue = toInt(rgb[2].substring(5), 16);
                                    green = toInt(rgb[2].substring(3, 5), 16);
                                    red = toInt(rgb[2].substring(1, 3), 16);
                                }
                                if (rgb[3]) {
                                    blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                                    green = toInt((t = rgb[3].charAt(2)) + t, 16);
                                    red = toInt((t = rgb[3].charAt(1)) + t, 16);
                                }
                                if (rgb[4]) {
                                    values = rgb[4][split](commaSpaces);
                                    red = toFloat(values[0]);
                                    values[0].slice(-1) == "%" && (red *= 2.55);
                                    green = toFloat(values[1]);
                                    values[1].slice(-1) == "%" && (green *= 2.55);
                                    blue = toFloat(values[2]);
                                    values[2].slice(-1) == "%" && (blue *= 2.55);
                                    rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                                    values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                                }
                                if (rgb[5]) {
                                    values = rgb[5][split](commaSpaces);
                                    red = toFloat(values[0]);
                                    values[0].slice(-1) == "%" && (red *= 2.55);
                                    green = toFloat(values[1]);
                                    values[1].slice(-1) == "%" && (green *= 2.55);
                                    blue = toFloat(values[2]);
                                    values[2].slice(-1) == "%" && (blue *= 2.55);
                                    (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                                    rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                                    values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                                    return R.hsb2rgb(red, green, blue, opacity);
                                }
                                if (rgb[6]) {
                                    values = rgb[6][split](commaSpaces);
                                    red = toFloat(values[0]);
                                    values[0].slice(-1) == "%" && (red *= 2.55);
                                    green = toFloat(values[1]);
                                    values[1].slice(-1) == "%" && (green *= 2.55);
                                    blue = toFloat(values[2]);
                                    values[2].slice(-1) == "%" && (blue *= 2.55);
                                    (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                                    rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                                    values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                                    return R.hsl2rgb(red, green, blue, opacity);
                                }
                                rgb = {r: red, g: green, b: blue, toString: clrToString};
                                rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
                                R.is(opacity, "finite") && (rgb.opacity = opacity);
                                return rgb;
                            }
                            return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
                        }, R);
                        /*\
                         * Raphael.hsb
                         [ method ]
                         **
                         * Converts HSB values to hex representation of the colour.
                         > Parameters
                         - h (number) hue
                         - s (number) saturation
                         - b (number) value or brightness
                         = (string) hex representation of the colour.
                         \*/
                        R.hsb = cacher(function (h, s, b) {
                            return R.hsb2rgb(h, s, b).hex;
                        });
                        /*\
                         * Raphael.hsl
                         [ method ]
                         **
                         * Converts HSL values to hex representation of the colour.
                         > Parameters
                         - h (number) hue
                         - s (number) saturation
                         - l (number) luminosity
                         = (string) hex representation of the colour.
                         \*/
                        R.hsl = cacher(function (h, s, l) {
                            return R.hsl2rgb(h, s, l).hex;
                        });
                        /*\
                         * Raphael.rgb
                         [ method ]
                         **
                         * Converts RGB values to hex representation of the colour.
                         > Parameters
                         - r (number) red
                         - g (number) green
                         - b (number) blue
                         = (string) hex representation of the colour.
                         \*/
                        R.rgb = cacher(function (r, g, b) {
                            function round(x) { return (x + 0.5) | 0; }
                            return "#" + (16777216 | round(b) | (round(g) << 8) | (round(r) << 16)).toString(16).slice(1);
                        });
                        /*\
                         * Raphael.getColor
                         [ method ]
                         **
                         * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset
                         > Parameters
                         - value (number) #optional brightness, default is `0.75`
                         = (string) hex representation of the colour.
                         \*/
                        R.getColor = function (value) {
                            var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},
                                rgb = this.hsb2rgb(start.h, start.s, start.b);
                            start.h += .075;
                            if (start.h > 1) {
                                start.h = 0;
                                start.s -= .2;
                                start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});
                            }
                            return rgb.hex;
                        };
                        /*\
                         * Raphael.getColor.reset
                         [ method ]
                         **
                         * Resets spectrum position for @Raphael.getColor back to red.
                         \*/
                        R.getColor.reset = function () {
                            delete this.start;
                        };

                        // http://schepers.cc/getting-to-the-point
                        function catmullRom2bezier(crp, z) {
                            var d = [];
                            for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
                                var p = [
                                    {x: +crp[i - 2], y: +crp[i - 1]},
                                    {x: +crp[i],     y: +crp[i + 1]},
                                    {x: +crp[i + 2], y: +crp[i + 3]},
                                    {x: +crp[i + 4], y: +crp[i + 5]}
                                ];
                                if (z) {
                                    if (!i) {
                                        p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
                                    } else if (iLen - 4 == i) {
                                        p[3] = {x: +crp[0], y: +crp[1]};
                                    } else if (iLen - 2 == i) {
                                        p[2] = {x: +crp[0], y: +crp[1]};
                                        p[3] = {x: +crp[2], y: +crp[3]};
                                    }
                                } else {
                                    if (iLen - 4 == i) {
                                        p[3] = p[2];
                                    } else if (!i) {
                                        p[0] = {x: +crp[i], y: +crp[i + 1]};
                                    }
                                }
                                d.push(["C",
                                    (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                                    (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                                    (p[1].x + 6 * p[2].x - p[3].x) / 6,
                                    (p[1].y + 6*p[2].y - p[3].y) / 6,
                                    p[2].x,
                                    p[2].y
                                ]);
                            }

                            return d;
                        }
                        /*\
                         * Raphael.parsePathString
                         [ method ]
                         **
                         * Utility method
                         **
                         * Parses given path string into an array of arrays of path segments.
                         > Parameters
                         - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)
                         = (array) array of segments.
                         \*/
                        R.parsePathString = function (pathString) {
                            if (!pathString) {
                                return null;
                            }
                            var pth = paths(pathString);
                            if (pth.arr) {
                                return pathClone(pth.arr);
                            }

                            var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},
                                data = [];
                            if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
                                data = pathClone(pathString);
                            }
                            if (!data.length) {
                                Str(pathString).replace(pathCommand, function (a, b, c) {
                                    var params = [],
                                        name = b.toLowerCase();
                                    c.replace(pathValues, function (a, b) {
                                        b && params.push(+b);
                                    });
                                    if (name == "m" && params.length > 2) {
                                        data.push([b][concat](params.splice(0, 2)));
                                        name = "l";
                                        b = b == "m" ? "l" : "L";
                                    }
                                    if (name == "r") {
                                        data.push([b][concat](params));
                                    } else while (params.length >= paramCounts[name]) {
                                        data.push([b][concat](params.splice(0, paramCounts[name])));
                                        if (!paramCounts[name]) {
                                            break;
                                        }
                                    }
                                });
                            }
                            data.toString = R._path2string;
                            pth.arr = pathClone(data);
                            return data;
                        };
                        /*\
                         * Raphael.parseTransformString
                         [ method ]
                         **
                         * Utility method
                         **
                         * Parses given path string into an array of transformations.
                         > Parameters
                         - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)
                         = (array) array of transformations.
                         \*/
                        R.parseTransformString = cacher(function (TString) {
                            if (!TString) {
                                return null;
                            }
                            var paramCounts = {r: 3, s: 4, t: 2, m: 6},
                                data = [];
                            if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption
                                data = pathClone(TString);
                            }
                            if (!data.length) {
                                Str(TString).replace(tCommand, function (a, b, c) {
                                    var params = [],
                                        name = lowerCase.call(b);
                                    c.replace(pathValues, function (a, b) {
                                        b && params.push(+b);
                                    });
                                    data.push([b][concat](params));
                                });
                            }
                            data.toString = R._path2string;
                            return data;
                        });
                        // PATHS
                        var paths = function (ps) {
                            var p = paths.ps = paths.ps || {};
                            if (p[ps]) {
                                p[ps].sleep = 100;
                            } else {
                                p[ps] = {
                                    sleep: 100
                                };
                            }
                            setTimeout(function () {
                                for (var key in p) if (p[has](key) && key != ps) {
                                    p[key].sleep--;
                                    !p[key].sleep && delete p[key];
                                }
                            });
                            return p[ps];
                        };
                        /*\
                         * Raphael.findDotsAtSegment
                         [ method ]
                         **
                         * Utility method
                         **
                         * Find dot coordinates on the given cubic bezier curve at the given t.
                         > Parameters
                         - p1x (number) x of the first point of the curve
                         - p1y (number) y of the first point of the curve
                         - c1x (number) x of the first anchor of the curve
                         - c1y (number) y of the first anchor of the curve
                         - c2x (number) x of the second anchor of the curve
                         - c2y (number) y of the second anchor of the curve
                         - p2x (number) x of the second point of the curve
                         - p2y (number) y of the second point of the curve
                         - t (number) position on the curve (0..1)
                         = (object) point information in format:
                         o {
                         o     x: (number) x coordinate of the point
                         o     y: (number) y coordinate of the point
                         o     m: {
                         o         x: (number) x coordinate of the left anchor
                         o         y: (number) y coordinate of the left anchor
                         o     }
                         o     n: {
                         o         x: (number) x coordinate of the right anchor
                         o         y: (number) y coordinate of the right anchor
                         o     }
                         o     start: {
                         o         x: (number) x coordinate of the start of the curve
                         o         y: (number) y coordinate of the start of the curve
                         o     }
                         o     end: {
                         o         x: (number) x coordinate of the end of the curve
                         o         y: (number) y coordinate of the end of the curve
                         o     }
                         o     alpha: (number) angle of the curve derivative at the point
                         o }
                         \*/
                        R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
                            var t1 = 1 - t,
                                t13 = pow(t1, 3),
                                t12 = pow(t1, 2),
                                t2 = t * t,
                                t3 = t2 * t,
                                x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
                                y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
                                mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
                                my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
                                nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
                                ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
                                ax = t1 * p1x + t * c1x,
                                ay = t1 * p1y + t * c1y,
                                cx = t1 * c2x + t * p2x,
                                cy = t1 * c2y + t * p2y,
                                alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
                            (mx > nx || my < ny) && (alpha += 180);
                            return {
                                x: x,
                                y: y,
                                m: {x: mx, y: my},
                                n: {x: nx, y: ny},
                                start: {x: ax, y: ay},
                                end: {x: cx, y: cy},
                                alpha: alpha
                            };
                        };
                        /*\
                         * Raphael.bezierBBox
                         [ method ]
                         **
                         * Utility method
                         **
                         * Return bounding box of a given cubic bezier curve
                         > Parameters
                         - p1x (number) x of the first point of the curve
                         - p1y (number) y of the first point of the curve
                         - c1x (number) x of the first anchor of the curve
                         - c1y (number) y of the first anchor of the curve
                         - c2x (number) x of the second anchor of the curve
                         - c2y (number) y of the second anchor of the curve
                         - p2x (number) x of the second point of the curve
                         - p2y (number) y of the second point of the curve
                         * or
                         - bez (array) array of six points for bezier curve
                         = (object) point information in format:
                         o {
                         o     min: {
                         o         x: (number) x coordinate of the left point
                         o         y: (number) y coordinate of the top point
                         o     }
                         o     max: {
                         o         x: (number) x coordinate of the right point
                         o         y: (number) y coordinate of the bottom point
                         o     }
                         o }
                         \*/
                        R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
                            if (!R.is(p1x, "array")) {
                                p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
                            }
                            var bbox = curveDim.apply(null, p1x);
                            return {
                                x: bbox.min.x,
                                y: bbox.min.y,
                                x2: bbox.max.x,
                                y2: bbox.max.y,
                                width: bbox.max.x - bbox.min.x,
                                height: bbox.max.y - bbox.min.y
                            };
                        };
                        /*\
                         * Raphael.isPointInsideBBox
                         [ method ]
                         **
                         * Utility method
                         **
                         * Returns `true` if given point is inside bounding boxes.
                         > Parameters
                         - bbox (string) bounding box
                         - x (string) x coordinate of the point
                         - y (string) y coordinate of the point
                         = (boolean) `true` if point inside
                         \*/
                        R.isPointInsideBBox = function (bbox, x, y) {
                            return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
                        };
                        /*\
                         * Raphael.isBBoxIntersect
                         [ method ]
                         **
                         * Utility method
                         **
                         * Returns `true` if two bounding boxes intersect
                         > Parameters
                         - bbox1 (string) first bounding box
                         - bbox2 (string) second bounding box
                         = (boolean) `true` if they intersect
                         \*/
                        R.isBBoxIntersect = function (bbox1, bbox2) {
                            var i = R.isPointInsideBBox;
                            return i(bbox2, bbox1.x, bbox1.y)
                                || i(bbox2, bbox1.x2, bbox1.y)
                                || i(bbox2, bbox1.x, bbox1.y2)
                                || i(bbox2, bbox1.x2, bbox1.y2)
                                || i(bbox1, bbox2.x, bbox2.y)
                                || i(bbox1, bbox2.x2, bbox2.y)
                                || i(bbox1, bbox2.x, bbox2.y2)
                                || i(bbox1, bbox2.x2, bbox2.y2)
                                || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
                                && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
                        };
                        function base3(t, p1, p2, p3, p4) {
                            var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
                                t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
                            return t * t2 - 3 * p1 + 3 * p2;
                        }
                        function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
                            if (z == null) {
                                z = 1;
                            }
                            z = z > 1 ? 1 : z < 0 ? 0 : z;
                            var z2 = z / 2,
                                n = 12,
                                Tvalues = [-0.1252,0.1252,-0.3678,0.3678,-0.5873,0.5873,-0.7699,0.7699,-0.9041,0.9041,-0.9816,0.9816],
                                Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
                                sum = 0;
                            for (var i = 0; i < n; i++) {
                                var ct = z2 * Tvalues[i] + z2,
                                    xbase = base3(ct, x1, x2, x3, x4),
                                    ybase = base3(ct, y1, y2, y3, y4),
                                    comb = xbase * xbase + ybase * ybase;
                                sum += Cvalues[i] * math.sqrt(comb);
                            }
                            return z2 * sum;
                        }
                        function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
                            if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
                                return;
                            }
                            var t = 1,
                                step = t / 2,
                                t2 = t - step,
                                l,
                                e = .01;
                            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
                            while (abs(l - ll) > e) {
                                step /= 2;
                                t2 += (l < ll ? 1 : -1) * step;
                                l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
                            }
                            return t2;
                        }
                        function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
                            if (
                                mmax(x1, x2) < mmin(x3, x4) ||
                                mmin(x1, x2) > mmax(x3, x4) ||
                                mmax(y1, y2) < mmin(y3, y4) ||
                                mmin(y1, y2) > mmax(y3, y4)
                            ) {
                                return;
                            }
                            var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
                                ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
                                denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

                            if (!denominator) {
                                return;
                            }
                            var px = nx / denominator,
                                py = ny / denominator,
                                px2 = +px.toFixed(2),
                                py2 = +py.toFixed(2);
                            if (
                                px2 < +mmin(x1, x2).toFixed(2) ||
                                px2 > +mmax(x1, x2).toFixed(2) ||
                                px2 < +mmin(x3, x4).toFixed(2) ||
                                px2 > +mmax(x3, x4).toFixed(2) ||
                                py2 < +mmin(y1, y2).toFixed(2) ||
                                py2 > +mmax(y1, y2).toFixed(2) ||
                                py2 < +mmin(y3, y4).toFixed(2) ||
                                py2 > +mmax(y3, y4).toFixed(2)
                            ) {
                                return;
                            }
                            return {x: px, y: py};
                        }
                        function inter(bez1, bez2) {
                            return interHelper(bez1, bez2);
                        }
                        function interCount(bez1, bez2) {
                            return interHelper(bez1, bez2, 1);
                        }
                        function interHelper(bez1, bez2, justCount) {
                            var bbox1 = R.bezierBBox(bez1),
                                bbox2 = R.bezierBBox(bez2);
                            if (!R.isBBoxIntersect(bbox1, bbox2)) {
                                return justCount ? 0 : [];
                            }
                            var l1 = bezlen.apply(0, bez1),
                                l2 = bezlen.apply(0, bez2),
                                n1 = mmax(~~(l1 / 5), 1),
                                n2 = mmax(~~(l2 / 5), 1),
                                dots1 = [],
                                dots2 = [],
                                xy = {},
                                res = justCount ? 0 : [];
                            for (var i = 0; i < n1 + 1; i++) {
                                var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
                                dots1.push({x: p.x, y: p.y, t: i / n1});
                            }
                            for (i = 0; i < n2 + 1; i++) {
                                p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
                                dots2.push({x: p.x, y: p.y, t: i / n2});
                            }
                            for (i = 0; i < n1; i++) {
                                for (var j = 0; j < n2; j++) {
                                    var di = dots1[i],
                                        di1 = dots1[i + 1],
                                        dj = dots2[j],
                                        dj1 = dots2[j + 1],
                                        ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                                        cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                                        is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                                    if (is) {
                                        if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                                            continue;
                                        }
                                        xy[is.x.toFixed(4)] = is.y.toFixed(4);
                                        var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                                            t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                                        if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
                                            if (justCount) {
                                                res++;
                                            } else {
                                                res.push({
                                                    x: is.x,
                                                    y: is.y,
                                                    t1: mmin(t1, 1),
                                                    t2: mmin(t2, 1)
                                                });
                                            }
                                        }
                                    }
                                }
                            }
                            return res;
                        }
                        /*\
                         * Raphael.pathIntersection
                         [ method ]
                         **
                         * Utility method
                         **
                         * Finds intersections of two paths
                         > Parameters
                         - path1 (string) path string
                         - path2 (string) path string
                         = (array) dots of intersection
                         o [
                         o     {
                         o         x: (number) x coordinate of the point
                         o         y: (number) y coordinate of the point
                         o         t1: (number) t value for segment of path1
                         o         t2: (number) t value for segment of path2
                         o         segment1: (number) order number for segment of path1
                         o         segment2: (number) order number for segment of path2
                         o         bez1: (array) eight coordinates representing beziér curve for the segment of path1
                         o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
                         o     }
                         o ]
                         \*/
                        R.pathIntersection = function (path1, path2) {
                            return interPathHelper(path1, path2);
                        };
                        R.pathIntersectionNumber = function (path1, path2) {
                            return interPathHelper(path1, path2, 1);
                        };
                        function interPathHelper(path1, path2, justCount) {
                            path1 = R._path2curve(path1);
                            path2 = R._path2curve(path2);
                            var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
                                res = justCount ? 0 : [];
                            for (var i = 0, ii = path1.length; i < ii; i++) {
                                var pi = path1[i];
                                if (pi[0] == "M") {
                                    x1 = x1m = pi[1];
                                    y1 = y1m = pi[2];
                                } else {
                                    if (pi[0] == "C") {
                                        bez1 = [x1, y1].concat(pi.slice(1));
                                        x1 = bez1[6];
                                        y1 = bez1[7];
                                    } else {
                                        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                                        x1 = x1m;
                                        y1 = y1m;
                                    }
                                    for (var j = 0, jj = path2.length; j < jj; j++) {
                                        var pj = path2[j];
                                        if (pj[0] == "M") {
                                            x2 = x2m = pj[1];
                                            y2 = y2m = pj[2];
                                        } else {
                                            if (pj[0] == "C") {
                                                bez2 = [x2, y2].concat(pj.slice(1));
                                                x2 = bez2[6];
                                                y2 = bez2[7];
                                            } else {
                                                bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                                                x2 = x2m;
                                                y2 = y2m;
                                            }
                                            var intr = interHelper(bez1, bez2, justCount);
                                            if (justCount) {
                                                res += intr;
                                            } else {
                                                for (var k = 0, kk = intr.length; k < kk; k++) {
                                                    intr[k].segment1 = i;
                                                    intr[k].segment2 = j;
                                                    intr[k].bez1 = bez1;
                                                    intr[k].bez2 = bez2;
                                                }
                                                res = res.concat(intr);
                                            }
                                        }
                                    }
                                }
                            }
                            return res;
                        }
                        /*\
                         * Raphael.isPointInsidePath
                         [ method ]
                         **
                         * Utility method
                         **
                         * Returns `true` if given point is inside a given closed path.
                         > Parameters
                         - path (string) path string
                         - x (number) x of the point
                         - y (number) y of the point
                         = (boolean) true, if point is inside the path
                         \*/
                        R.isPointInsidePath = function (path, x, y) {
                            var bbox = R.pathBBox(path);
                            return R.isPointInsideBBox(bbox, x, y) &&
                                interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
                        };
                        R._removedFactory = function (methodname) {
                            return function () {
                                eve("raphael.log", null, "Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object", methodname);
                            };
                        };
                        /*\
                         * Raphael.pathBBox
                         [ method ]
                         **
                         * Utility method
                         **
                         * Return bounding box of a given path
                         > Parameters
                         - path (string) path string
                         = (object) bounding box
                         o {
                         o     x: (number) x coordinate of the left top point of the box
                         o     y: (number) y coordinate of the left top point of the box
                         o     x2: (number) x coordinate of the right bottom point of the box
                         o     y2: (number) y coordinate of the right bottom point of the box
                         o     width: (number) width of the box
                         o     height: (number) height of the box
                         o     cx: (number) x coordinate of the center of the box
                         o     cy: (number) y coordinate of the center of the box
                         o }
                         \*/
                        var pathDimensions = R.pathBBox = function (path) {
                                var pth = paths(path);
                                if (pth.bbox) {
                                    return clone(pth.bbox);
                                }
                                if (!path) {
                                    return {x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0};
                                }
                                path = path2curve(path);
                                var x = 0,
                                    y = 0,
                                    X = [],
                                    Y = [],
                                    p;
                                for (var i = 0, ii = path.length; i < ii; i++) {
                                    p = path[i];
                                    if (p[0] == "M") {
                                        x = p[1];
                                        y = p[2];
                                        X.push(x);
                                        Y.push(y);
                                    } else {
                                        var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                                        X = X[concat](dim.min.x, dim.max.x);
                                        Y = Y[concat](dim.min.y, dim.max.y);
                                        x = p[5];
                                        y = p[6];
                                    }
                                }
                                var xmin = mmin[apply](0, X),
                                    ymin = mmin[apply](0, Y),
                                    xmax = mmax[apply](0, X),
                                    ymax = mmax[apply](0, Y),
                                    width = xmax - xmin,
                                    height = ymax - ymin,
                                    bb = {
                                        x: xmin,
                                        y: ymin,
                                        x2: xmax,
                                        y2: ymax,
                                        width: width,
                                        height: height,
                                        cx: xmin + width / 2,
                                        cy: ymin + height / 2
                                    };
                                pth.bbox = clone(bb);
                                return bb;
                            },
                            pathClone = function (pathArray) {
                                var res = clone(pathArray);
                                res.toString = R._path2string;
                                return res;
                            },
                            pathToRelative = R._pathToRelative = function (pathArray) {
                                var pth = paths(pathArray);
                                if (pth.rel) {
                                    return pathClone(pth.rel);
                                }
                                if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                                    pathArray = R.parsePathString(pathArray);
                                }
                                var res = [],
                                    x = 0,
                                    y = 0,
                                    mx = 0,
                                    my = 0,
                                    start = 0;
                                if (pathArray[0][0] == "M") {
                                    x = pathArray[0][1];
                                    y = pathArray[0][2];
                                    mx = x;
                                    my = y;
                                    start++;
                                    res.push(["M", x, y]);
                                }
                                for (var i = start, ii = pathArray.length; i < ii; i++) {
                                    var r = res[i] = [],
                                        pa = pathArray[i];
                                    if (pa[0] != lowerCase.call(pa[0])) {
                                        r[0] = lowerCase.call(pa[0]);
                                        switch (r[0]) {
                                            case "a":
                                                r[1] = pa[1];
                                                r[2] = pa[2];
                                                r[3] = pa[3];
                                                r[4] = pa[4];
                                                r[5] = pa[5];
                                                r[6] = +(pa[6] - x).toFixed(3);
                                                r[7] = +(pa[7] - y).toFixed(3);
                                                break;
                                            case "v":
                                                r[1] = +(pa[1] - y).toFixed(3);
                                                break;
                                            case "m":
                                                mx = pa[1];
                                                my = pa[2];
                                            default:
                                                for (var j = 1, jj = pa.length; j < jj; j++) {
                                                    r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
                                                }
                                        }
                                    } else {
                                        r = res[i] = [];
                                        if (pa[0] == "m") {
                                            mx = pa[1] + x;
                                            my = pa[2] + y;
                                        }
                                        for (var k = 0, kk = pa.length; k < kk; k++) {
                                            res[i][k] = pa[k];
                                        }
                                    }
                                    var len = res[i].length;
                                    switch (res[i][0]) {
                                        case "z":
                                            x = mx;
                                            y = my;
                                            break;
                                        case "h":
                                            x += +res[i][len - 1];
                                            break;
                                        case "v":
                                            y += +res[i][len - 1];
                                            break;
                                        default:
                                            x += +res[i][len - 2];
                                            y += +res[i][len - 1];
                                    }
                                }
                                res.toString = R._path2string;
                                pth.rel = pathClone(res);
                                return res;
                            },
                            pathToAbsolute = R._pathToAbsolute = function (pathArray) {
                                var pth = paths(pathArray);
                                if (pth.abs) {
                                    return pathClone(pth.abs);
                                }
                                if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                                    pathArray = R.parsePathString(pathArray);
                                }
                                if (!pathArray || !pathArray.length) {
                                    return [["M", 0, 0]];
                                }
                                var res = [],
                                    x = 0,
                                    y = 0,
                                    mx = 0,
                                    my = 0,
                                    start = 0;
                                if (pathArray[0][0] == "M") {
                                    x = +pathArray[0][1];
                                    y = +pathArray[0][2];
                                    mx = x;
                                    my = y;
                                    start++;
                                    res[0] = ["M", x, y];
                                }
                                var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
                                for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
                                    res.push(r = []);
                                    pa = pathArray[i];
                                    if (pa[0] != upperCase.call(pa[0])) {
                                        r[0] = upperCase.call(pa[0]);
                                        switch (r[0]) {
                                            case "A":
                                                r[1] = pa[1];
                                                r[2] = pa[2];
                                                r[3] = pa[3];
                                                r[4] = pa[4];
                                                r[5] = pa[5];
                                                r[6] = +(pa[6] + x);
                                                r[7] = +(pa[7] + y);
                                                break;
                                            case "V":
                                                r[1] = +pa[1] + y;
                                                break;
                                            case "H":
                                                r[1] = +pa[1] + x;
                                                break;
                                            case "R":
                                                var dots = [x, y][concat](pa.slice(1));
                                                for (var j = 2, jj = dots.length; j < jj; j++) {
                                                    dots[j] = +dots[j] + x;
                                                    dots[++j] = +dots[j] + y;
                                                }
                                                res.pop();
                                                res = res[concat](catmullRom2bezier(dots, crz));
                                                break;
                                            case "M":
                                                mx = +pa[1] + x;
                                                my = +pa[2] + y;
                                            default:
                                                for (j = 1, jj = pa.length; j < jj; j++) {
                                                    r[j] = +pa[j] + ((j % 2) ? x : y);
                                                }
                                        }
                                    } else if (pa[0] == "R") {
                                        dots = [x, y][concat](pa.slice(1));
                                        res.pop();
                                        res = res[concat](catmullRom2bezier(dots, crz));
                                        r = ["R"][concat](pa.slice(-2));
                                    } else {
                                        for (var k = 0, kk = pa.length; k < kk; k++) {
                                            r[k] = pa[k];
                                        }
                                    }
                                    switch (r[0]) {
                                        case "Z":
                                            x = mx;
                                            y = my;
                                            break;
                                        case "H":
                                            x = r[1];
                                            break;
                                        case "V":
                                            y = r[1];
                                            break;
                                        case "M":
                                            mx = r[r.length - 2];
                                            my = r[r.length - 1];
                                        default:
                                            x = r[r.length - 2];
                                            y = r[r.length - 1];
                                    }
                                }
                                res.toString = R._path2string;
                                pth.abs = pathClone(res);
                                return res;
                            },
                            l2c = function (x1, y1, x2, y2) {
                                return [x1, y1, x2, y2, x2, y2];
                            },
                            q2c = function (x1, y1, ax, ay, x2, y2) {
                                var _13 = 1 / 3,
                                    _23 = 2 / 3;
                                return [
                                    _13 * x1 + _23 * ax,
                                    _13 * y1 + _23 * ay,
                                    _13 * x2 + _23 * ax,
                                    _13 * y2 + _23 * ay,
                                    x2,
                                    y2
                                ];
                            },
                            a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
                                // for more information of where this math came from visit:
                                // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
                                var _120 = PI * 120 / 180,
                                    rad = PI / 180 * (+angle || 0),
                                    res = [],
                                    xy,
                                    rotate = cacher(function (x, y, rad) {
                                        var X = x * math.cos(rad) - y * math.sin(rad),
                                            Y = x * math.sin(rad) + y * math.cos(rad);
                                        return {x: X, y: Y};
                                    });
                                if (!recursive) {
                                    xy = rotate(x1, y1, -rad);
                                    x1 = xy.x;
                                    y1 = xy.y;
                                    xy = rotate(x2, y2, -rad);
                                    x2 = xy.x;
                                    y2 = xy.y;
                                    var cos = math.cos(PI / 180 * angle),
                                        sin = math.sin(PI / 180 * angle),
                                        x = (x1 - x2) / 2,
                                        y = (y1 - y2) / 2;
                                    var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
                                    if (h > 1) {
                                        h = math.sqrt(h);
                                        rx = h * rx;
                                        ry = h * ry;
                                    }
                                    var rx2 = rx * rx,
                                        ry2 = ry * ry,
                                        k = (large_arc_flag == sweep_flag ? -1 : 1) *
                                            math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                                        cx = k * rx * y / ry + (x1 + x2) / 2,
                                        cy = k * -ry * x / rx + (y1 + y2) / 2,
                                        f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                                        f2 = math.asin(((y2 - cy) / ry).toFixed(9));

                                    f1 = x1 < cx ? PI - f1 : f1;
                                    f2 = x2 < cx ? PI - f2 : f2;
                                    f1 < 0 && (f1 = PI * 2 + f1);
                                    f2 < 0 && (f2 = PI * 2 + f2);
                                    if (sweep_flag && f1 > f2) {
                                        f1 = f1 - PI * 2;
                                    }
                                    if (!sweep_flag && f2 > f1) {
                                        f2 = f2 - PI * 2;
                                    }
                                } else {
                                    f1 = recursive[0];
                                    f2 = recursive[1];
                                    cx = recursive[2];
                                    cy = recursive[3];
                                }
                                var df = f2 - f1;
                                if (abs(df) > _120) {
                                    var f2old = f2,
                                        x2old = x2,
                                        y2old = y2;
                                    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                                    x2 = cx + rx * math.cos(f2);
                                    y2 = cy + ry * math.sin(f2);
                                    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
                                }
                                df = f2 - f1;
                                var c1 = math.cos(f1),
                                    s1 = math.sin(f1),
                                    c2 = math.cos(f2),
                                    s2 = math.sin(f2),
                                    t = math.tan(df / 4),
                                    hx = 4 / 3 * rx * t,
                                    hy = 4 / 3 * ry * t,
                                    m1 = [x1, y1],
                                    m2 = [x1 + hx * s1, y1 - hy * c1],
                                    m3 = [x2 + hx * s2, y2 - hy * c2],
                                    m4 = [x2, y2];
                                m2[0] = 2 * m1[0] - m2[0];
                                m2[1] = 2 * m1[1] - m2[1];
                                if (recursive) {
                                    return [m2, m3, m4][concat](res);
                                } else {
                                    res = [m2, m3, m4][concat](res).join()[split](",");
                                    var newres = [];
                                    for (var i = 0, ii = res.length; i < ii; i++) {
                                        newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                                    }
                                    return newres;
                                }
                            },
                            findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
                                var t1 = 1 - t;
                                return {
                                    x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
                                    y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
                                };
                            },
                            curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
                                var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
                                    b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
                                    c = p1x - c1x,
                                    t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
                                    t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
                                    y = [p1y, p2y],
                                    x = [p1x, p2x],
                                    dot;
                                abs(t1) > "1e12" && (t1 = .5);
                                abs(t2) > "1e12" && (t2 = .5);
                                if (t1 > 0 && t1 < 1) {
                                    dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                                    x.push(dot.x);
                                    y.push(dot.y);
                                }
                                if (t2 > 0 && t2 < 1) {
                                    dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                                    x.push(dot.x);
                                    y.push(dot.y);
                                }
                                a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
                                b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
                                c = p1y - c1y;
                                t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
                                t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
                                abs(t1) > "1e12" && (t1 = .5);
                                abs(t2) > "1e12" && (t2 = .5);
                                if (t1 > 0 && t1 < 1) {
                                    dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                                    x.push(dot.x);
                                    y.push(dot.y);
                                }
                                if (t2 > 0 && t2 < 1) {
                                    dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                                    x.push(dot.x);
                                    y.push(dot.y);
                                }
                                return {
                                    min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},
                                    max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}
                                };
                            }),
                            path2curve = R._path2curve = cacher(function (path, path2) {
                                var pth = !path2 && paths(path);
                                if (!path2 && pth.curve) {
                                    return pathClone(pth.curve);
                                }
                                var p = pathToAbsolute(path),
                                    p2 = path2 && pathToAbsolute(path2),
                                    attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                                    attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                                    processPath = function (path, d, pcom) {
                                        var nx, ny, tq = {T:1, Q:1};
                                        if (!path) {
                                            return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                                        }
                                        !(path[0] in tq) && (d.qx = d.qy = null);
                                        switch (path[0]) {
                                            case "M":
                                                d.X = path[1];
                                                d.Y = path[2];
                                                break;
                                            case "A":
                                                path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                                                break;
                                            case "S":
                                                if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
                                                    nx = d.x * 2 - d.bx;          // And reflect the previous
                                                    ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                                                }
                                                else {                            // or some else or nothing
                                                    nx = d.x;
                                                    ny = d.y;
                                                }
                                                path = ["C", nx, ny][concat](path.slice(1));
                                                break;
                                            case "T":
                                                if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
                                                    d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                                                    d.qy = d.y * 2 - d.qy;        // to case "S".
                                                }
                                                else {                            // or something else or nothing
                                                    d.qx = d.x;
                                                    d.qy = d.y;
                                                }
                                                path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                                                break;
                                            case "Q":
                                                d.qx = path[1];
                                                d.qy = path[2];
                                                path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                                                break;
                                            case "L":
                                                path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                                                break;
                                            case "H":
                                                path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                                                break;
                                            case "V":
                                                path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                                                break;
                                            case "Z":
                                                path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                                                break;
                                        }
                                        return path;
                                    },
                                    fixArc = function (pp, i) {
                                        if (pp[i].length > 7) {
                                            pp[i].shift();
                                            var pi = pp[i];
                                            while (pi.length) {
                                                pcoms1[i]="A"; // if created multiple C:s, their original seg is saved
                                                p2 && (pcoms2[i]="A"); // the same as above
                                                pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                                            }
                                            pp.splice(i, 1);
                                            ii = mmax(p.length, p2 && p2.length || 0);
                                        }
                                    },
                                    fixM = function (path1, path2, a1, a2, i) {
                                        if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                                            path2.splice(i, 0, ["M", a2.x, a2.y]);
                                            a1.bx = 0;
                                            a1.by = 0;
                                            a1.x = path1[i][1];
                                            a1.y = path1[i][2];
                                            ii = mmax(p.length, p2 && p2.length || 0);
                                        }
                                    },
                                    pcoms1 = [], // path commands of original path p
                                    pcoms2 = [], // path commands of original path p2
                                    pfirst = "", // temporary holder for original path command
                                    pcom = ""; // holder for previous path command of original path
                                for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
                                    p[i] && (pfirst = p[i][0]); // save current path command

                                    if (pfirst != "C") // C is not saved yet, because it may be result of conversion
                                    {
                                        pcoms1[i] = pfirst; // Save current path command
                                        i && ( pcom = pcoms1[i-1]); // Get previous path command pcom
                                    }
                                    p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

                                    if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
                                    // which may produce multiple C:s
                                    // so we have to make sure that C is also C in original path

                                    fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

                                    if (p2) { // the same procedures is done to p2
                                        p2[i] && (pfirst = p2[i][0]);
                                        if (pfirst != "C")
                                        {
                                            pcoms2[i] = pfirst;
                                            i && (pcom = pcoms2[i-1]);
                                        }
                                        p2[i] = processPath(p2[i], attrs2, pcom);

                                        if (pcoms2[i]!="A" && pfirst=="C") pcoms2[i]="C";

                                        fixArc(p2, i);
                                    }
                                    fixM(p, p2, attrs, attrs2, i);
                                    fixM(p2, p, attrs2, attrs, i);
                                    var seg = p[i],
                                        seg2 = p2 && p2[i],
                                        seglen = seg.length,
                                        seg2len = p2 && seg2.length;
                                    attrs.x = seg[seglen - 2];
                                    attrs.y = seg[seglen - 1];
                                    attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
                                    attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
                                    attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
                                    attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
                                    attrs2.x = p2 && seg2[seg2len - 2];
                                    attrs2.y = p2 && seg2[seg2len - 1];
                                }
                                if (!p2) {
                                    pth.curve = pathClone(p);
                                }
                                return p2 ? [p, p2] : p;
                            }, null, pathClone),
                            parseDots = R._parseDots = cacher(function (gradient) {
                                var dots = [];
                                for (var i = 0, ii = gradient.length; i < ii; i++) {
                                    var dot = {},
                                        par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
                                    dot.color = R.getRGB(par[1]);
                                    if (dot.color.error) {
                                        return null;
                                    }
                                    dot.opacity = dot.color.opacity;
                                    dot.color = dot.color.hex;
                                    par[2] && (dot.offset = par[2] + "%");
                                    dots.push(dot);
                                }
                                for (i = 1, ii = dots.length - 1; i < ii; i++) {
                                    if (!dots[i].offset) {
                                        var start = toFloat(dots[i - 1].offset || 0),
                                            end = 0;
                                        for (var j = i + 1; j < ii; j++) {
                                            if (dots[j].offset) {
                                                end = dots[j].offset;
                                                break;
                                            }
                                        }
                                        if (!end) {
                                            end = 100;
                                            j = ii;
                                        }
                                        end = toFloat(end);
                                        var d = (end - start) / (j - i + 1);
                                        for (; i < j; i++) {
                                            start += d;
                                            dots[i].offset = start + "%";
                                        }
                                    }
                                }
                                return dots;
                            }),
                            tear = R._tear = function (el, paper) {
                                el == paper.top && (paper.top = el.prev);
                                el == paper.bottom && (paper.bottom = el.next);
                                el.next && (el.next.prev = el.prev);
                                el.prev && (el.prev.next = el.next);
                            },
                            tofront = R._tofront = function (el, paper) {
                                if (paper.top === el) {
                                    return;
                                }
                                tear(el, paper);
                                el.next = null;
                                el.prev = paper.top;
                                paper.top.next = el;
                                paper.top = el;
                            },
                            toback = R._toback = function (el, paper) {
                                if (paper.bottom === el) {
                                    return;
                                }
                                tear(el, paper);
                                el.next = paper.bottom;
                                el.prev = null;
                                paper.bottom.prev = el;
                                paper.bottom = el;
                            },
                            insertafter = R._insertafter = function (el, el2, paper) {
                                tear(el, paper);
                                el2 == paper.top && (paper.top = el);
                                el2.next && (el2.next.prev = el);
                                el.next = el2.next;
                                el.prev = el2;
                                el2.next = el;
                            },
                            insertbefore = R._insertbefore = function (el, el2, paper) {
                                tear(el, paper);
                                el2 == paper.bottom && (paper.bottom = el);
                                el2.prev && (el2.prev.next = el);
                                el.prev = el2.prev;
                                el2.prev = el;
                                el.next = el2;
                            },
                                /*\
                                 * Raphael.toMatrix
                                 [ method ]
                                 **
                                 * Utility method
                                 **
                                 * Returns matrix of transformations applied to a given path
                                 > Parameters
                                 - path (string) path string
                                 - transform (string|array) transformation string
                                 = (object) @Matrix
                                 \*/
                            toMatrix = R.toMatrix = function (path, transform) {
                                var bb = pathDimensions(path),
                                    el = {
                                        _: {
                                            transform: E
                                        },
                                        getBBox: function () {
                                            return bb;
                                        }
                                    };
                                extractTransform(el, transform);
                                return el.matrix;
                            },
                                /*\
                                 * Raphael.transformPath
                                 [ method ]
                                 **
                                 * Utility method
                                 **
                                 * Returns path transformed by a given transformation
                                 > Parameters
                                 - path (string) path string
                                 - transform (string|array) transformation string
                                 = (string) path
                                 \*/
                            transformPath = R.transformPath = function (path, transform) {
                                return mapPath(path, toMatrix(path, transform));
                            },
                            extractTransform = R._extractTransform = function (el, tstr) {
                                if (tstr == null) {
                                    return el._.transform;
                                }
                                tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
                                var tdata = R.parseTransformString(tstr),
                                    deg = 0,
                                    dx = 0,
                                    dy = 0,
                                    sx = 1,
                                    sy = 1,
                                    _ = el._,
                                    m = new Matrix;
                                _.transform = tdata || [];
                                if (tdata) {
                                    for (var i = 0, ii = tdata.length; i < ii; i++) {
                                        var t = tdata[i],
                                            tlen = t.length,
                                            command = Str(t[0]).toLowerCase(),
                                            absolute = t[0] != command,
                                            inver = absolute ? m.invert() : 0,
                                            x1,
                                            y1,
                                            x2,
                                            y2,
                                            bb;
                                        if (command == "t" && tlen == 3) {
                                            if (absolute) {
                                                x1 = inver.x(0, 0);
                                                y1 = inver.y(0, 0);
                                                x2 = inver.x(t[1], t[2]);
                                                y2 = inver.y(t[1], t[2]);
                                                m.translate(x2 - x1, y2 - y1);
                                            } else {
                                                m.translate(t[1], t[2]);
                                            }
                                        } else if (command == "r") {
                                            if (tlen == 2) {
                                                bb = bb || el.getBBox(1);
                                                m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                                                deg += t[1];
                                            } else if (tlen == 4) {
                                                if (absolute) {
                                                    x2 = inver.x(t[2], t[3]);
                                                    y2 = inver.y(t[2], t[3]);
                                                    m.rotate(t[1], x2, y2);
                                                } else {
                                                    m.rotate(t[1], t[2], t[3]);
                                                }
                                                deg += t[1];
                                            }
                                        } else if (command == "s") {
                                            if (tlen == 2 || tlen == 3) {
                                                bb = bb || el.getBBox(1);
                                                m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                                                sx *= t[1];
                                                sy *= t[tlen - 1];
                                            } else if (tlen == 5) {
                                                if (absolute) {
                                                    x2 = inver.x(t[3], t[4]);
                                                    y2 = inver.y(t[3], t[4]);
                                                    m.scale(t[1], t[2], x2, y2);
                                                } else {
                                                    m.scale(t[1], t[2], t[3], t[4]);
                                                }
                                                sx *= t[1];
                                                sy *= t[2];
                                            }
                                        } else if (command == "m" && tlen == 7) {
                                            m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                                        }
                                        _.dirtyT = 1;
                                        el.matrix = m;
                                    }
                                }

                                /*\
                                 * Element.matrix
                                 [ property (object) ]
                                 **
                                 * Keeps @Matrix object, which represents element transformation
                                 \*/
                                el.matrix = m;

                                _.sx = sx;
                                _.sy = sy;
                                _.deg = deg;
                                _.dx = dx = m.e;
                                _.dy = dy = m.f;

                                if (sx == 1 && sy == 1 && !deg && _.bbox) {
                                    _.bbox.x += +dx;
                                    _.bbox.y += +dy;
                                } else {
                                    _.dirtyT = 1;
                                }
                            },
                            getEmpty = function (item) {
                                var l = item[0];
                                switch (l.toLowerCase()) {
                                    case "t": return [l, 0, 0];
                                    case "m": return [l, 1, 0, 0, 1, 0, 0];
                                    case "r": if (item.length == 4) {
                                        return [l, 0, item[2], item[3]];
                                    } else {
                                        return [l, 0];
                                    }
                                    case "s": if (item.length == 5) {
                                        return [l, 1, 1, item[3], item[4]];
                                    } else if (item.length == 3) {
                                        return [l, 1, 1];
                                    } else {
                                        return [l, 1];
                                    }
                                }
                            },
                            equaliseTransform = R._equaliseTransform = function (t1, t2) {
                                t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
                                t1 = R.parseTransformString(t1) || [];
                                t2 = R.parseTransformString(t2) || [];
                                var maxlength = mmax(t1.length, t2.length),
                                    from = [],
                                    to = [],
                                    i = 0, j, jj,
                                    tt1, tt2;
                                for (; i < maxlength; i++) {
                                    tt1 = t1[i] || getEmpty(t2[i]);
                                    tt2 = t2[i] || getEmpty(tt1);
                                    if ((tt1[0] != tt2[0]) ||
                                        (tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
                                        (tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
                                    ) {
                                        return;
                                    }
                                    from[i] = [];
                                    to[i] = [];
                                    for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {
                                        j in tt1 && (from[i][j] = tt1[j]);
                                        j in tt2 && (to[i][j] = tt2[j]);
                                    }
                                }
                                return {
                                    from: from,
                                    to: to
                                };
                            };
                        R._getContainer = function (x, y, w, h) {
                            var container;
                            container = h == null && !R.is(x, "object") ? g.doc.getElementById(x) : x;
                            if (container == null) {
                                return;
                            }
                            if (container.tagName) {
                                if (y == null) {
                                    return {
                                        container: container,
                                        width: container.style.pixelWidth || container.offsetWidth,
                                        height: container.style.pixelHeight || container.offsetHeight
                                    };
                                } else {
                                    return {
                                        container: container,
                                        width: y,
                                        height: w
                                    };
                                }
                            }
                            return {
                                container: 1,
                                x: x,
                                y: y,
                                width: w,
                                height: h
                            };
                        };
                        /*\
                         * Raphael.pathToRelative
                         [ method ]
                         **
                         * Utility method
                         **
                         * Converts path to relative form
                         > Parameters
                         - pathString (string|array) path string or array of segments
                         = (array) array of segments.
                         \*/
                        R.pathToRelative = pathToRelative;
                        R._engine = {};
                        /*\
                         * Raphael.path2curve
                         [ method ]
                         **
                         * Utility method
                         **
                         * Converts path to a new path where all segments are cubic bezier curves.
                         > Parameters
                         - pathString (string|array) path string or array of segments
                         = (array) array of segments.
                         \*/
                        R.path2curve = path2curve;
                        /*\
                         * Raphael.matrix
                         [ method ]
                         **
                         * Utility method
                         **
                         * Returns matrix based on given parameters.
                         > Parameters
                         - a (number)
                         - b (number)
                         - c (number)
                         - d (number)
                         - e (number)
                         - f (number)
                         = (object) @Matrix
                         \*/
                        R.matrix = function (a, b, c, d, e, f) {
                            return new Matrix(a, b, c, d, e, f);
                        };
                        function Matrix(a, b, c, d, e, f) {
                            if (a != null) {
                                this.a = +a;
                                this.b = +b;
                                this.c = +c;
                                this.d = +d;
                                this.e = +e;
                                this.f = +f;
                            } else {
                                this.a = 1;
                                this.b = 0;
                                this.c = 0;
                                this.d = 1;
                                this.e = 0;
                                this.f = 0;
                            }
                        }
                        (function (matrixproto) {
                            /*\
                             * Matrix.add
                             [ method ]
                             **
                             * Adds given matrix to existing one.
                             > Parameters
                             - a (number)
                             - b (number)
                             - c (number)
                             - d (number)
                             - e (number)
                             - f (number)
                             or
                             - matrix (object) @Matrix
                             \*/
                            matrixproto.add = function (a, b, c, d, e, f) {
                                var out = [[], [], []],
                                    m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
                                    matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
                                    x, y, z, res;

                                if (a && a instanceof Matrix) {
                                    matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
                                }

                                for (x = 0; x < 3; x++) {
                                    for (y = 0; y < 3; y++) {
                                        res = 0;
                                        for (z = 0; z < 3; z++) {
                                            res += m[x][z] * matrix[z][y];
                                        }
                                        out[x][y] = res;
                                    }
                                }
                                this.a = out[0][0];
                                this.b = out[1][0];
                                this.c = out[0][1];
                                this.d = out[1][1];
                                this.e = out[0][2];
                                this.f = out[1][2];
                            };
                            /*\
                             * Matrix.invert
                             [ method ]
                             **
                             * Returns inverted version of the matrix
                             = (object) @Matrix
                             \*/
                            matrixproto.invert = function () {
                                var me = this,
                                    x = me.a * me.d - me.b * me.c;
                                return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
                            };
                            /*\
                             * Matrix.clone
                             [ method ]
                             **
                             * Returns copy of the matrix
                             = (object) @Matrix
                             \*/
                            matrixproto.clone = function () {
                                return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
                            };
                            /*\
                             * Matrix.translate
                             [ method ]
                             **
                             * Translate the matrix
                             > Parameters
                             - x (number)
                             - y (number)
                             \*/
                            matrixproto.translate = function (x, y) {
                                this.add(1, 0, 0, 1, x, y);
                            };
                            /*\
                             * Matrix.scale
                             [ method ]
                             **
                             * Scales the matrix
                             > Parameters
                             - x (number)
                             - y (number) #optional
                             - cx (number) #optional
                             - cy (number) #optional
                             \*/
                            matrixproto.scale = function (x, y, cx, cy) {
                                y == null && (y = x);
                                (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
                                this.add(x, 0, 0, y, 0, 0);
                                (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
                            };
                            /*\
                             * Matrix.rotate
                             [ method ]
                             **
                             * Rotates the matrix
                             > Parameters
                             - a (number)
                             - x (number)
                             - y (number)
                             \*/
                            matrixproto.rotate = function (a, x, y) {
                                a = R.rad(a);
                                x = x || 0;
                                y = y || 0;
                                var cos = +math.cos(a).toFixed(9),
                                    sin = +math.sin(a).toFixed(9);
                                this.add(cos, sin, -sin, cos, x, y);
                                this.add(1, 0, 0, 1, -x, -y);
                            };
                            /*\
                             * Matrix.x
                             [ method ]
                             **
                             * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y
                             > Parameters
                             - x (number)
                             - y (number)
                             = (number) x
                             \*/
                            matrixproto.x = function (x, y) {
                                return x * this.a + y * this.c + this.e;
                            };
                            /*\
                             * Matrix.y
                             [ method ]
                             **
                             * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x
                             > Parameters
                             - x (number)
                             - y (number)
                             = (number) y
                             \*/
                            matrixproto.y = function (x, y) {
                                return x * this.b + y * this.d + this.f;
                            };
                            matrixproto.get = function (i) {
                                return +this[Str.fromCharCode(97 + i)].toFixed(4);
                            };
                            matrixproto.toString = function () {
                                return R.svg ?
                                    "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" :
                                    [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
                            };
                            matrixproto.toFilter = function () {
                                return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) +
                                    ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) +
                                    ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
                            };
                            matrixproto.offset = function () {
                                return [this.e.toFixed(4), this.f.toFixed(4)];
                            };
                            function norm(a) {
                                return a[0] * a[0] + a[1] * a[1];
                            }
                            function normalize(a) {
                                var mag = math.sqrt(norm(a));
                                a[0] && (a[0] /= mag);
                                a[1] && (a[1] /= mag);
                            }
                            /*\
                             * Matrix.split
                             [ method ]
                             **
                             * Splits matrix into primitive transformations
                             = (object) in format:
                             o dx (number) translation by x
                             o dy (number) translation by y
                             o scalex (number) scale by x
                             o scaley (number) scale by y
                             o shear (number) shear
                             o rotate (number) rotation in deg
                             o isSimple (boolean) could it be represented via simple transformations
                             \*/
                            matrixproto.split = function () {
                                var out = {};
                                // translation
                                out.dx = this.e;
                                out.dy = this.f;

                                // scale and shear
                                var row = [[this.a, this.c], [this.b, this.d]];
                                out.scalex = math.sqrt(norm(row[0]));
                                normalize(row[0]);

                                out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
                                row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

                                out.scaley = math.sqrt(norm(row[1]));
                                normalize(row[1]);
                                out.shear /= out.scaley;

                                // rotation
                                var sin = -row[0][1],
                                    cos = row[1][1];
                                if (cos < 0) {
                                    out.rotate = R.deg(math.acos(cos));
                                    if (sin < 0) {
                                        out.rotate = 360 - out.rotate;
                                    }
                                } else {
                                    out.rotate = R.deg(math.asin(sin));
                                }

                                out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
                                out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
                                out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
                                return out;
                            };
                            /*\
                             * Matrix.toTransformString
                             [ method ]
                             **
                             * Return transform string that represents given matrix
                             = (string) transform string
                             \*/
                            matrixproto.toTransformString = function (shorter) {
                                var s = shorter || this[split]();
                                if (s.isSimple) {
                                    s.scalex = +s.scalex.toFixed(4);
                                    s.scaley = +s.scaley.toFixed(4);
                                    s.rotate = +s.rotate.toFixed(4);
                                    return  (s.dx || s.dy ? "t" + [s.dx, s.dy] : E) +
                                        (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
                                        (s.rotate ? "r" + [s.rotate, 0, 0] : E);
                                } else {
                                    return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
                                }
                            };
                        })(Matrix.prototype);

                        var preventDefault = function () {
                                this.returnValue = false;
                            },
                            preventTouch = function () {
                                return this.originalEvent.preventDefault();
                            },
                            stopPropagation = function () {
                                this.cancelBubble = true;
                            },
                            stopTouch = function () {
                                return this.originalEvent.stopPropagation();
                            },
                            getEventPosition = function (e) {
                                var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                                    scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;

                                return {
                                    x: e.clientX + scrollX,
                                    y: e.clientY + scrollY
                                };
                            },
                            addEvent = (function () {
                                if (g.doc.addEventListener) {
                                    return function (obj, type, fn, element) {
                                        var f = function (e) {
                                            var pos = getEventPosition(e);
                                            return fn.call(element, e, pos.x, pos.y);
                                        };
                                        obj.addEventListener(type, f, false);

                                        if (supportsTouch && touchMap[type]) {
                                            var _f = function (e) {
                                                var pos = getEventPosition(e),
                                                    olde = e;

                                                for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                                                    if (e.targetTouches[i].target == obj) {
                                                        e = e.targetTouches[i];
                                                        e.originalEvent = olde;
                                                        e.preventDefault = preventTouch;
                                                        e.stopPropagation = stopTouch;
                                                        break;
                                                    }
                                                }

                                                return fn.call(element, e, pos.x, pos.y);
                                            };
                                            obj.addEventListener(touchMap[type], _f, false);
                                        }

                                        return function () {
                                            obj.removeEventListener(type, f, false);

                                            if (supportsTouch && touchMap[type])
                                                obj.removeEventListener(touchMap[type], _f, false);

                                            return true;
                                        };
                                    };
                                } else if (g.doc.attachEvent) {
                                    return function (obj, type, fn, element) {
                                        var f = function (e) {
                                            e = e || g.win.event;
                                            var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                                                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                                                x = e.clientX + scrollX,
                                                y = e.clientY + scrollY;
                                            e.preventDefault = e.preventDefault || preventDefault;
                                            e.stopPropagation = e.stopPropagation || stopPropagation;
                                            return fn.call(element, e, x, y);
                                        };
                                        obj.attachEvent("on" + type, f);
                                        var detacher = function () {
                                            obj.detachEvent("on" + type, f);
                                            return true;
                                        };
                                        return detacher;
                                    };
                                }
                            })(),
                            drag = [],
                            dragMove = function (e) {
                                var x = e.clientX,
                                    y = e.clientY,
                                    scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                                    scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                                    dragi,
                                    j = drag.length;
                                while (j--) {
                                    dragi = drag[j];
                                    if (supportsTouch && e.touches) {
                                        var i = e.touches.length,
                                            touch;
                                        while (i--) {
                                            touch = e.touches[i];
                                            if (touch.identifier == dragi.el._drag.id) {
                                                x = touch.clientX;
                                                y = touch.clientY;
                                                (e.originalEvent ? e.originalEvent : e).preventDefault();
                                                break;
                                            }
                                        }
                                    } else {
                                        e.preventDefault();
                                    }
                                    var node = dragi.el.node,
                                        o,
                                        next = node.nextSibling,
                                        parent = node.parentNode,
                                        display = node.style.display;
                                    g.win.opera && parent.removeChild(node);
                                    node.style.display = "none";
                                    o = dragi.el.paper.getElementByPoint(x, y);
                                    node.style.display = display;
                                    g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
                                    o && eve("raphael.drag.over." + dragi.el.id, dragi.el, o);
                                    x += scrollX;
                                    y += scrollY;
                                    eve("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
                                }
                            },
                            dragUp = function (e) {
                                R.unmousemove(dragMove).unmouseup(dragUp);
                                var i = drag.length,
                                    dragi;
                                while (i--) {
                                    dragi = drag[i];
                                    dragi.el._drag = {};
                                    eve("raphael.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
                                }
                                drag = [];
                            },
                                /*\
                                 * Raphael.el
                                 [ property (object) ]
                                 **
                                 * You can add your own method to elements. This is useful when you want to hack default functionality or
                                 * want to wrap some common transformation or attributes in one method. In difference to canvas methods,
                                 * you can redefine element method at any time. Expending element methods wouldn’t affect set.
                                 > Usage
                                 | Raphael.el.red = function () {
                                 |     this.attr({fill: "#f00"});
                                 | };
                                 | // then use it
                                 | paper.circle(100, 100, 20).red();
                                 \*/
                            elproto = R.el = {};
                        /*\
                         * Element.click
                         [ method ]
                         **
                         * Adds event handler for click for the element.
                         > Parameters
                         - handler (function) handler for the event
                         = (object) @Element
                         \*/
                        /*\
                         * Element.unclick
                         [ method ]
                         **
                         * Removes event handler for click for the element.
                         > Parameters
                         - handler (function) #optional handler for the event
                         = (object) @Element
                         \*/

                        /*\
                         * Element.dblclick
                         [ method ]
                         **
                         * Adds event handler for double click for the element.
                         > Parameters
                         - handler (function) handler for the event
                         = (object) @Element
                         \*/
                        /*\
                         * Element.undblclick
                         [ method ]
                         **
                         * Removes event handler for double click for the element.
                         > Parameters
                         - handler (function) #optional handler for the event
                         = (object) @Element
                         \*/

                        /*\
                         * Element.mousedown
                         [ method ]
                         **
                         * Adds event handler for mousedown for the element.
                         > Parameters
                         - handler (function) handler for the event
                         = (object) @Element
                         \*/
                        /*\
                         * Element.unmousedown
                         [ method ]
                         **
                         * Removes event handler for mousedown for the element.
                         > Parameters
                         - handler (function) #optional handler for the event
                         = (object) @Element
                         \*/

                        /*\
                         * Element.mousemove
                         [ method ]
                         **
                         * Adds event handler for mousemove for the element.
                         > Parameters
                         - handler (function) handler for the event
                         = (object) @Element
                         \*/
                        /*\
                         * Element.unmousemove
                         [ method ]
                         **
                         * Removes event handler for mousemove for the element.
                         > Parameters
                         - handler (function) #optional handler for the event
                         = (object) @Element
                         \*/

                        /*\
                         * Element.mouseout
                         [ method ]
                         **
                         * Adds event handler for mouseout for the element.
                         > Parameters
                         - handler (function) handler for the event
                         = (object) @Element
                         \*/
                        /*\
                         * Element.unmouseout
                         [ method ]
                         **
                         * Removes event handler for mouseout for the element.
                         > Parameters
                         - handler (function) #optional handler for the event
                         = (object) @Element
                         \*/

                        /*\
                         * Element.mouseover
                         [ method ]
                         **
                         * Adds event handler for mouseover for the element.
                         > Parameters
                         - handler (function) handler for the event
                         = (object) @Element
                         \*/
                        /*\
                         * Element.unmouseover
                         [ method ]
                         **
                         * Removes event handler for mouseover for the element.
                         > Parameters
                         - handler (function) #optional handler for the event
                         = (object) @Element
                         \*/

                        /*\
                         * Element.mouseup
                         [ method ]
                         **
                         * Adds event handler for mouseup for the element.
                         > Parameters
                         - handler (function) handler for the event
                         = (object) @Element
                         \*/
                        /*\
                         * Element.unmouseup
                         [ method ]
                         **
                         * Removes event handler for mouseup for the element.
                         > Parameters
                         - handler (function) #optional handler for the event
                         = (object) @Element
                         \*/

                        /*\
                         * Element.touchstart
                         [ method ]
                         **
                         * Adds event handler for touchstart for the element.
                         > Parameters
                         - handler (function) handler for the event
                         = (object) @Element
                         \*/
                        /*\
                         * Element.untouchstart
                         [ method ]
                         **
                         * Removes event handler for touchstart for the element.
                         > Parameters
                         - handler (function) #optional handler for the event
                         = (object) @Element
                         \*/

                        /*\
                         * Element.touchmove
                         [ method ]
                         **
                         * Adds event handler for touchmove for the element.
                         > Parameters
                         - handler (function) handler for the event
                         = (object) @Element
                         \*/
                        /*\
                         * Element.untouchmove
                         [ method ]
                         **
                         * Removes event handler for touchmove for the element.
                         > Parameters
                         - handler (function) #optional handler for the event
                         = (object) @Element
                         \*/

                        /*\
                         * Element.touchend
                         [ method ]
                         **
                         * Adds event handler for touchend for the element.
                         > Parameters
                         - handler (function) handler for the event
                         = (object) @Element
                         \*/
                        /*\
                         * Element.untouchend
                         [ method ]
                         **
                         * Removes event handler for touchend for the element.
                         > Parameters
                         - handler (function) #optional handler for the event
                         = (object) @Element
                         \*/

                        /*\
                         * Element.touchcancel
                         [ method ]
                         **
                         * Adds event handler for touchcancel for the element.
                         > Parameters
                         - handler (function) handler for the event
                         = (object) @Element
                         \*/
                        /*\
                         * Element.untouchcancel
                         [ method ]
                         **
                         * Removes event handler for touchcancel for the element.
                         > Parameters
                         - handler (function) #optional handler for the event
                         = (object) @Element
                         \*/
                        for (var i = events.length; i--;) {
                            (function (eventName) {
                                R[eventName] = elproto[eventName] = function (fn, scope) {
                                    if (R.is(fn, "function")) {
                                        this.events = this.events || [];
                                        this.events.push({name: eventName, f: fn, unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)});
                                    }
                                    return this;
                                };
                                R["un" + eventName] = elproto["un" + eventName] = function (fn) {
                                    var events = this.events || [],
                                        l = events.length;
                                    while (l--){
                                        if (events[l].name == eventName && (R.is(fn, "undefined") || events[l].f == fn)) {
                                            events[l].unbind();
                                            events.splice(l, 1);
                                            !events.length && delete this.events;
                                        }
                                    }
                                    return this;
                                };
                            })(events[i]);
                        }

                        /*\
                         * Element.data
                         [ method ]
                         **
                         * Adds or retrieves given value associated with given key.
                         **
                         * See also @Element.removeData
                         > Parameters
                         - key (string) key to store data
                         - value (any) #optional value to store
                         = (object) @Element
                         * or, if value is not specified:
                         = (any) value
                         * or, if key and value are not specified:
                         = (object) Key/value pairs for all the data associated with the element.
                         > Usage
                         | for (var i = 0, i < 5, i++) {
                         |     paper.circle(10 + 15 * i, 10, 10)
                         |          .attr({fill: "#000"})
                         |          .data("i", i)
                         |          .click(function () {
                         |             alert(this.data("i"));
                         |          });
                         | }
                         \*/
                        elproto.data = function (key, value) {
                            var data = eldata[this.id] = eldata[this.id] || {};
                            if (arguments.length == 0) {
                                return data;
                            }
                            if (arguments.length == 1) {
                                if (R.is(key, "object")) {
                                    for (var i in key) if (key[has](i)) {
                                        this.data(i, key[i]);
                                    }
                                    return this;
                                }
                                eve("raphael.data.get." + this.id, this, data[key], key);
                                return data[key];
                            }
                            data[key] = value;
                            eve("raphael.data.set." + this.id, this, value, key);
                            return this;
                        };
                        /*\
                         * Element.removeData
                         [ method ]
                         **
                         * Removes value associated with an element by given key.
                         * If key is not provided, removes all the data of the element.
                         > Parameters
                         - key (string) #optional key
                         = (object) @Element
                         \*/
                        elproto.removeData = function (key) {
                            if (key == null) {
                                eldata[this.id] = {};
                            } else {
                                eldata[this.id] && delete eldata[this.id][key];
                            }
                            return this;
                        };
                        /*\
                         * Element.getData
                         [ method ]
                         **
                         * Retrieves the element data
                         = (object) data
                         \*/
                        elproto.getData = function () {
                            return clone(eldata[this.id] || {});
                        };
                        /*\
                         * Element.hover
                         [ method ]
                         **
                         * Adds event handlers for hover for the element.
                         > Parameters
                         - f_in (function) handler for hover in
                         - f_out (function) handler for hover out
                         - icontext (object) #optional context for hover in handler
                         - ocontext (object) #optional context for hover out handler
                         = (object) @Element
                         \*/
                        elproto.hover = function (f_in, f_out, scope_in, scope_out) {
                            return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
                        };
                        /*\
                         * Element.unhover
                         [ method ]
                         **
                         * Removes event handlers for hover for the element.
                         > Parameters
                         - f_in (function) handler for hover in
                         - f_out (function) handler for hover out
                         = (object) @Element
                         \*/
                        elproto.unhover = function (f_in, f_out) {
                            return this.unmouseover(f_in).unmouseout(f_out);
                        };
                        var draggable = [];
                        /*\
                         * Element.drag
                         [ method ]
                         **
                         * Adds event handlers for drag of the element.
                         > Parameters
                         - onmove (function) handler for moving
                         - onstart (function) handler for drag start
                         - onend (function) handler for drag end
                         - mcontext (object) #optional context for moving handler
                         - scontext (object) #optional context for drag start handler
                         - econtext (object) #optional context for drag end handler
                         * Additionally following `drag` events will be triggered: `drag.start.<id>` on start,
                         * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element
                         * `drag.over.<id>` will be fired as well.
                         *
                         * Start event and start handler will be called in specified context or in context of the element with following parameters:
                         o x (number) x position of the mouse
                         o y (number) y position of the mouse
                         o event (object) DOM event object
                         * Move event and move handler will be called in specified context or in context of the element with following parameters:
                         o dx (number) shift by x from the start point
                         o dy (number) shift by y from the start point
                         o x (number) x position of the mouse
                         o y (number) y position of the mouse
                         o event (object) DOM event object
                         * End event and end handler will be called in specified context or in context of the element with following parameters:
                         o event (object) DOM event object
                         = (object) @Element
                         \*/
                        elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
                            function start(e) {
                                (e.originalEvent || e).preventDefault();
                                var x = e.clientX,
                                    y = e.clientY,
                                    scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                                    scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
                                this._drag.id = e.identifier;
                                if (supportsTouch && e.touches) {
                                    var i = e.touches.length, touch;
                                    while (i--) {
                                        touch = e.touches[i];
                                        this._drag.id = touch.identifier;
                                        if (touch.identifier == this._drag.id) {
                                            x = touch.clientX;
                                            y = touch.clientY;
                                            break;
                                        }
                                    }
                                }
                                this._drag.x = x + scrollX;
                                this._drag.y = y + scrollY;
                                !drag.length && R.mousemove(dragMove).mouseup(dragUp);
                                drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
                                onstart && eve.on("raphael.drag.start." + this.id, onstart);
                                onmove && eve.on("raphael.drag.move." + this.id, onmove);
                                onend && eve.on("raphael.drag.end." + this.id, onend);
                                eve("raphael.drag.start." + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
                            }
                            this._drag = {};
                            draggable.push({el: this, start: start});
                            this.mousedown(start);
                            return this;
                        };
                        /*\
                         * Element.onDragOver
                         [ method ]
                         **
                         * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).
                         > Parameters
                         - f (function) handler for event, first argument would be the element you are dragging over
                         \*/
                        elproto.onDragOver = function (f) {
                            f ? eve.on("raphael.drag.over." + this.id, f) : eve.unbind("raphael.drag.over." + this.id);
                        };
                        /*\
                         * Element.undrag
                         [ method ]
                         **
                         * Removes all drag event handlers from given element.
                         \*/
                        elproto.undrag = function () {
                            var i = draggable.length;
                            while (i--) if (draggable[i].el == this) {
                                this.unmousedown(draggable[i].start);
                                draggable.splice(i, 1);
                                eve.unbind("raphael.drag.*." + this.id);
                            }
                            !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
                            drag = [];
                        };
                        /*\
                         * Paper.circle
                         [ method ]
                         **
                         * Draws a circle.
                         **
                         > Parameters
                         **
                         - x (number) x coordinate of the centre
                         - y (number) y coordinate of the centre
                         - r (number) radius
                         = (object) Raphaël element object with type “circle”
                         **
                         > Usage
                         | var c = paper.circle(50, 50, 40);
                         \*/
                        paperproto.circle = function (x, y, r) {
                            var out = R._engine.circle(this, x || 0, y || 0, r || 0);
                            this.__set__ && this.__set__.push(out);
                            return out;
                        };
                        /*\
                         * Paper.rect
                         [ method ]
                         *
                         * Draws a rectangle.
                         **
                         > Parameters
                         **
                         - x (number) x coordinate of the top left corner
                         - y (number) y coordinate of the top left corner
                         - width (number) width
                         - height (number) height
                         - r (number) #optional radius for rounded corners, default is 0
                         = (object) Raphaël element object with type “rect”
                         **
                         > Usage
                         | // regular rectangle
                         | var c = paper.rect(10, 10, 50, 50);
                         | // rectangle with rounded corners
                         | var c = paper.rect(40, 40, 50, 50, 10);
                         \*/
                        paperproto.rect = function (x, y, w, h, r) {
                            var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
                            this.__set__ && this.__set__.push(out);
                            return out;
                        };
                        /*\
                         * Paper.ellipse
                         [ method ]
                         **
                         * Draws an ellipse.
                         **
                         > Parameters
                         **
                         - x (number) x coordinate of the centre
                         - y (number) y coordinate of the centre
                         - rx (number) horizontal radius
                         - ry (number) vertical radius
                         = (object) Raphaël element object with type “ellipse”
                         **
                         > Usage
                         | var c = paper.ellipse(50, 50, 40, 20);
                         \*/
                        paperproto.ellipse = function (x, y, rx, ry) {
                            var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);
                            this.__set__ && this.__set__.push(out);
                            return out;
                        };
                        /*\
                         * Paper.path
                         [ method ]
                         **
                         * Creates a path element by given path data string.
                         > Parameters
                         - pathString (string) #optional path string in SVG format.
                         * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:
                         | "M10,20L30,40"
                         * Here we can see two commands: “M”, with arguments `(10, 20)` and “L” with arguments `(30, 40)`. Upper case letter mean command is absolute, lower case—relative.
                         *
                         # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a>.</p>
                         # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
                         # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
                         # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
                         # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
                         # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
                         # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
                         # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
                         # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
                         # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>
                         # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>
                         # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
                         # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
                         * * “Catmull-Rom curveto” is a not standard SVG command and added in 2.0 to make life easier.
                         * Note: there is a special case when path consist of just three commands: “M10,10R…z”. In this case path will smoothly connects to its beginning.
                         > Usage
                         | var c = paper.path("M10 10L90 90");
                         | // draw a diagonal line:
                         | // move to 10,10, line to 90,90
                         * For example of path strings, check out these icons: http://raphaeljs.com/icons/
                         \*/
                        paperproto.path = function (pathString) {
                            pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
                            var out = R._engine.path(R.format[apply](R, arguments), this);
                            this.__set__ && this.__set__.push(out);
                            return out;
                        };
                        /*\
                         * Paper.image
                         [ method ]
                         **
                         * Embeds an image into the surface.
                         **
                         > Parameters
                         **
                         - src (string) URI of the source image
                         - x (number) x coordinate position
                         - y (number) y coordinate position
                         - width (number) width of the image
                         - height (number) height of the image
                         = (object) Raphaël element object with type “image”
                         **
                         > Usage
                         | var c = paper.image("apple.png", 10, 10, 80, 80);
                         \*/
                        paperproto.image = function (src, x, y, w, h) {
                            var out = R._engine.image(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
                            this.__set__ && this.__set__.push(out);
                            return out;
                        };
                        /*\
                         * Paper.text
                         [ method ]
                         **
                         * Draws a text string. If you need line breaks, put “\n” in the string.
                         **
                         > Parameters
                         **
                         - x (number) x coordinate position
                         - y (number) y coordinate position
                         - text (string) The text string to draw
                         = (object) Raphaël element object with type “text”
                         **
                         > Usage
                         | var t = paper.text(50, 50, "Raphaël\nkicks\nbutt!");
                         \*/
                        paperproto.text = function (x, y, text) {
                            var out = R._engine.text(this, x || 0, y || 0, Str(text));
                            this.__set__ && this.__set__.push(out);
                            return out;
                        };
                        /*\
                         * Paper.set
                         [ method ]
                         **
                         * Creates array-like object to keep and operate several elements at once.
                         * Warning: it doesn’t create any elements for itself in the page, it just groups existing elements.
                         * Sets act as pseudo elements — all methods available to an element can be used on a set.
                         = (object) array-like object that represents set of elements
                         **
                         > Usage
                         | var st = paper.set();
                         | st.push(
                         |     paper.circle(10, 10, 5),
                         |     paper.circle(30, 10, 5)
                         | );
                         | st.attr({fill: "red"}); // changes the fill of both circles
                         \*/
                        paperproto.set = function (itemsArray) {
                            !R.is(itemsArray, "array") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));
                            var out = new Set(itemsArray);
                            this.__set__ && this.__set__.push(out);
                            out["paper"] = this;
                            out["type"] = "set";
                            return out;
                        };
                        /*\
                         * Paper.setStart
                         [ method ]
                         **
                         * Creates @Paper.set. All elements that will be created after calling this method and before calling
                         * @Paper.setFinish will be added to the set.
                         **
                         > Usage
                         | paper.setStart();
                         | paper.circle(10, 10, 5),
                         | paper.circle(30, 10, 5)
                         | var st = paper.setFinish();
                         | st.attr({fill: "red"}); // changes the fill of both circles
                         \*/
                        paperproto.setStart = function (set) {
                            this.__set__ = set || this.set();
                        };
                        /*\
                         * Paper.setFinish
                         [ method ]
                         **
                         * See @Paper.setStart. This method finishes catching and returns resulting set.
                         **
                         = (object) set
                         \*/
                        paperproto.setFinish = function (set) {
                            var out = this.__set__;
                            delete this.__set__;
                            return out;
                        };
                        /*\
                         * Paper.getSize
                         [ method ]
                         **
                         * Obtains current paper actual size.
                         **
                         = (object)
                         \*/
                        paperproto.getSize = function () {
                            var container = this.canvas.parentNode;
                            return {
                                width: container.offsetWidth,
                                height: container.offsetHeight
                            };
                        };
                        /*\
                         * Paper.setSize
                         [ method ]
                         **
                         * If you need to change dimensions of the canvas call this method
                         **
                         > Parameters
                         **
                         - width (number) new width of the canvas
                         - height (number) new height of the canvas
                         \*/
                        paperproto.setSize = function (width, height) {
                            return R._engine.setSize.call(this, width, height);
                        };
                        /*\
                         * Paper.setViewBox
                         [ method ]
                         **
                         * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by
                         * specifying new boundaries.
                         **
                         > Parameters
                         **
                         - x (number) new x position, default is `0`
                         - y (number) new y position, default is `0`
                         - w (number) new width of the canvas
                         - h (number) new height of the canvas
                         - fit (boolean) `true` if you want graphics to fit into new boundary box
                         \*/
                        paperproto.setViewBox = function (x, y, w, h, fit) {
                            return R._engine.setViewBox.call(this, x, y, w, h, fit);
                        };
                        /*\
                         * Paper.top
                         [ property ]
                         **
                         * Points to the topmost element on the paper
                         \*/
                        /*\
                         * Paper.bottom
                         [ property ]
                         **
                         * Points to the bottom element on the paper
                         \*/
                        paperproto.top = paperproto.bottom = null;
                        /*\
                         * Paper.raphael
                         [ property ]
                         **
                         * Points to the @Raphael object/function
                         \*/
                        paperproto.raphael = R;
                        var getOffset = function (elem) {
                            var box = elem.getBoundingClientRect(),
                                doc = elem.ownerDocument,
                                body = doc.body,
                                docElem = doc.documentElement,
                                clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
                                top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
                                left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
                            return {
                                y: top,
                                x: left
                            };
                        };
                        /*\
                         * Paper.getElementByPoint
                         [ method ]
                         **
                         * Returns you topmost element under given point.
                         **
                         = (object) Raphaël element object
                         > Parameters
                         **
                         - x (number) x coordinate from the top left corner of the window
                         - y (number) y coordinate from the top left corner of the window
                         > Usage
                         | paper.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
                         \*/
                        paperproto.getElementByPoint = function (x, y) {
                            var paper = this,
                                svg = paper.canvas,
                                target = g.doc.elementFromPoint(x, y);
                            if (g.win.opera && target.tagName == "svg") {
                                var so = getOffset(svg),
                                    sr = svg.createSVGRect();
                                sr.x = x - so.x;
                                sr.y = y - so.y;
                                sr.width = sr.height = 1;
                                var hits = svg.getIntersectionList(sr, null);
                                if (hits.length) {
                                    target = hits[hits.length - 1];
                                }
                            }
                            if (!target) {
                                return null;
                            }
                            while (target.parentNode && target != svg.parentNode && !target.raphael) {
                                target = target.parentNode;
                            }
                            target == paper.canvas.parentNode && (target = svg);
                            target = target && target.raphael ? paper.getById(target.raphaelid) : null;
                            return target;
                        };

                        /*\
                         * Paper.getElementsByBBox
                         [ method ]
                         **
                         * Returns set of elements that have an intersecting bounding box
                         **
                         > Parameters
                         **
                         - bbox (object) bbox to check with
                         = (object) @Set
                         \*/
                        paperproto.getElementsByBBox = function (bbox) {
                            var set = this.set();
                            this.forEach(function (el) {
                                if (R.isBBoxIntersect(el.getBBox(), bbox)) {
                                    set.push(el);
                                }
                            });
                            return set;
                        };

                        /*\
                         * Paper.getById
                         [ method ]
                         **
                         * Returns you element by its internal ID.
                         **
                         > Parameters
                         **
                         - id (number) id
                         = (object) Raphaël element object
                         \*/
                        paperproto.getById = function (id) {
                            var bot = this.bottom;
                            while (bot) {
                                if (bot.id == id) {
                                    return bot;
                                }
                                bot = bot.next;
                            }
                            return null;
                        };
                        /*\
                         * Paper.forEach
                         [ method ]
                         **
                         * Executes given function for each element on the paper
                         *
                         * If callback function returns `false` it will stop loop running.
                         **
                         > Parameters
                         **
                         - callback (function) function to run
                         - thisArg (object) context object for the callback
                         = (object) Paper object
                         > Usage
                         | paper.forEach(function (el) {
                         |     el.attr({ stroke: "blue" });
                         | });
                         \*/
                        paperproto.forEach = function (callback, thisArg) {
                            var bot = this.bottom;
                            while (bot) {
                                if (callback.call(thisArg, bot) === false) {
                                    return this;
                                }
                                bot = bot.next;
                            }
                            return this;
                        };
                        /*\
                         * Paper.getElementsByPoint
                         [ method ]
                         **
                         * Returns set of elements that have common point inside
                         **
                         > Parameters
                         **
                         - x (number) x coordinate of the point
                         - y (number) y coordinate of the point
                         = (object) @Set
                         \*/
                        paperproto.getElementsByPoint = function (x, y) {
                            var set = this.set();
                            this.forEach(function (el) {
                                if (el.isPointInside(x, y)) {
                                    set.push(el);
                                }
                            });
                            return set;
                        };
                        function x_y() {
                            return this.x + S + this.y;
                        }
                        function x_y_w_h() {
                            return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
                        }
                        /*\
                         * Element.isPointInside
                         [ method ]
                         **
                         * Determine if given point is inside this element’s shape
                         **
                         > Parameters
                         **
                         - x (number) x coordinate of the point
                         - y (number) y coordinate of the point
                         = (boolean) `true` if point inside the shape
                         \*/
                        elproto.isPointInside = function (x, y) {
                            var rp = this.realPath = getPath[this.type](this);
                            if (this.attr('transform') && this.attr('transform').length) {
                                rp = R.transformPath(rp, this.attr('transform'));
                            }
                            return R.isPointInsidePath(rp, x, y);
                        };
                        /*\
                         * Element.getBBox
                         [ method ]
                         **
                         * Return bounding box for a given element
                         **
                         > Parameters
                         **
                         - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.
                         = (object) Bounding box object:
                         o {
                         o     x: (number) top left corner x
                         o     y: (number) top left corner y
                         o     x2: (number) bottom right corner x
                         o     y2: (number) bottom right corner y
                         o     width: (number) width
                         o     height: (number) height
                         o }
                         \*/
                        elproto.getBBox = function (isWithoutTransform) {
                            if (this.removed) {
                                return {};
                            }
                            var _ = this._;
                            if (isWithoutTransform) {
                                if (_.dirty || !_.bboxwt) {
                                    this.realPath = getPath[this.type](this);
                                    _.bboxwt = pathDimensions(this.realPath);
                                    _.bboxwt.toString = x_y_w_h;
                                    _.dirty = 0;
                                }
                                return _.bboxwt;
                            }
                            if (_.dirty || _.dirtyT || !_.bbox) {
                                if (_.dirty || !this.realPath) {
                                    _.bboxwt = 0;
                                    this.realPath = getPath[this.type](this);
                                }
                                _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
                                _.bbox.toString = x_y_w_h;
                                _.dirty = _.dirtyT = 0;
                            }
                            return _.bbox;
                        };
                        /*\
                         * Element.clone
                         [ method ]
                         **
                         = (object) clone of a given element
                         **
                         \*/
                        elproto.clone = function () {
                            if (this.removed) {
                                return null;
                            }
                            var out = this.paper[this.type]().attr(this.attr());
                            this.__set__ && this.__set__.push(out);
                            return out;
                        };
                        /*\
                         * Element.glow
                         [ method ]
                         **
                         * Return set of elements that create glow-like effect around given element. See @Paper.set.
                         *
                         * Note: Glow is not connected to the element. If you change element attributes it won’t adjust itself.
                         **
                         > Parameters
                         **
                         - glow (object) #optional parameters object with all properties optional:
                         o {
                         o     width (number) size of the glow, default is `10`
                         o     fill (boolean) will it be filled, default is `false`
                         o     opacity (number) opacity, default is `0.5`
                         o     offsetx (number) horizontal offset, default is `0`
                         o     offsety (number) vertical offset, default is `0`
                         o     color (string) glow colour, default is `black`
                         o }
                         = (object) @Paper.set of elements that represents glow
                         \*/
                        elproto.glow = function (glow) {
                            if (this.type == "text") {
                                return null;
                            }
                            glow = glow || {};
                            var s = {
                                    width: (glow.width || 10) + (+this.attr("stroke-width") || 1),
                                    fill: glow.fill || false,
                                    opacity: glow.opacity == null ? .5 : glow.opacity,
                                    offsetx: glow.offsetx || 0,
                                    offsety: glow.offsety || 0,
                                    color: glow.color || "#000"
                                },
                                c = s.width / 2,
                                r = this.paper,
                                out = r.set(),
                                path = this.realPath || getPath[this.type](this);
                            path = this.matrix ? mapPath(path, this.matrix) : path;
                            for (var i = 1; i < c + 1; i++) {
                                out.push(r.path(path).attr({
                                    stroke: s.color,
                                    fill: s.fill ? s.color : "none",
                                    "stroke-linejoin": "round",
                                    "stroke-linecap": "round",
                                    "stroke-width": +(s.width / c * i).toFixed(3),
                                    opacity: +(s.opacity / c).toFixed(3)
                                }));
                            }
                            return out.insertBefore(this).translate(s.offsetx, s.offsety);
                        };
                        var curveslengths = {},
                            getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
                                if (length == null) {
                                    return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
                                } else {
                                    return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
                                }
                            },
                            getLengthFactory = function (istotal, subpath) {
                                return function (path, length, onlystart) {
                                    path = path2curve(path);
                                    var x, y, p, l, sp = "", subpaths = {}, point,
                                        len = 0;
                                    for (var i = 0, ii = path.length; i < ii; i++) {
                                        p = path[i];
                                        if (p[0] == "M") {
                                            x = +p[1];
                                            y = +p[2];
                                        } else {
                                            l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                                            if (len + l > length) {
                                                if (subpath && !subpaths.start) {
                                                    point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                                    sp += ["C" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                                                    if (onlystart) {return sp;}
                                                    subpaths.start = sp;
                                                    sp = ["M" + point.x, point.y + "C" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();
                                                    len += l;
                                                    x = +p[5];
                                                    y = +p[6];
                                                    continue;
                                                }
                                                if (!istotal && !subpath) {
                                                    point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                                    return {x: point.x, y: point.y, alpha: point.alpha};
                                                }
                                            }
                                            len += l;
                                            x = +p[5];
                                            y = +p[6];
                                        }
                                        sp += p.shift() + p;
                                    }
                                    subpaths.end = sp;
                                    point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
                                    point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});
                                    return point;
                                };
                            };
                        var getTotalLength = getLengthFactory(1),
                            getPointAtLength = getLengthFactory(),
                            getSubpathsAtLength = getLengthFactory(0, 1);
                        /*\
                         * Raphael.getTotalLength
                         [ method ]
                         **
                         * Returns length of the given path in pixels.
                         **
                         > Parameters
                         **
                         - path (string) SVG path string.
                         **
                         = (number) length.
                         \*/
                        R.getTotalLength = getTotalLength;
                        /*\
                         * Raphael.getPointAtLength
                         [ method ]
                         **
                         * Return coordinates of the point located at the given length on the given path.
                         **
                         > Parameters
                         **
                         - path (string) SVG path string
                         - length (number)
                         **
                         = (object) representation of the point:
                         o {
                         o     x: (number) x coordinate
                         o     y: (number) y coordinate
                         o     alpha: (number) angle of derivative
                         o }
                         \*/
                        R.getPointAtLength = getPointAtLength;
                        /*\
                         * Raphael.getSubpath
                         [ method ]
                         **
                         * Return subpath of a given path from given length to given length.
                         **
                         > Parameters
                         **
                         - path (string) SVG path string
                         - from (number) position of the start of the segment
                         - to (number) position of the end of the segment
                         **
                         = (string) pathstring for the segment
                         \*/
                        R.getSubpath = function (path, from, to) {
                            if (this.getTotalLength(path) - to < 1e-6) {
                                return getSubpathsAtLength(path, from).end;
                            }
                            var a = getSubpathsAtLength(path, to, 1);
                            return from ? getSubpathsAtLength(a, from).end : a;
                        };
                        /*\
                         * Element.getTotalLength
                         [ method ]
                         **
                         * Returns length of the path in pixels. Only works for element of “path” type.
                         = (number) length.
                         \*/
                        elproto.getTotalLength = function () {
                            var path = this.getPath();
                            if (!path) {
                                return;
                            }

                            if (this.node.getTotalLength) {
                                return this.node.getTotalLength();
                            }

                            return getTotalLength(path);
                        };
                        /*\
                         * Element.getPointAtLength
                         [ method ]
                         **
                         * Return coordinates of the point located at the given length on the given path. Only works for element of “path” type.
                         **
                         > Parameters
                         **
                         - length (number)
                         **
                         = (object) representation of the point:
                         o {
                         o     x: (number) x coordinate
                         o     y: (number) y coordinate
                         o     alpha: (number) angle of derivative
                         o }
                         \*/
                        elproto.getPointAtLength = function (length) {
                            var path = this.getPath();
                            if (!path) {
                                return;
                            }

                            return getPointAtLength(path, length);
                        };
                        /*\
                         * Element.getPath
                         [ method ]
                         **
                         * Returns path of the element. Only works for elements of “path” type and simple elements like circle.
                         = (object) path
                         **
                         \*/
                        elproto.getPath = function () {
                            var path,
                                getPath = R._getPath[this.type];

                            if (this.type == "text" || this.type == "set") {
                                return;
                            }

                            if (getPath) {
                                path = getPath(this);
                            }

                            return path;
                        };
                        /*\
                         * Element.getSubpath
                         [ method ]
                         **
                         * Return subpath of a given element from given length to given length. Only works for element of “path” type.
                         **
                         > Parameters
                         **
                         - from (number) position of the start of the segment
                         - to (number) position of the end of the segment
                         **
                         = (string) pathstring for the segment
                         \*/
                        elproto.getSubpath = function (from, to) {
                            var path = this.getPath();
                            if (!path) {
                                return;
                            }

                            return R.getSubpath(path, from, to);
                        };
                        /*\
                         * Raphael.easing_formulas
                         [ property ]
                         **
                         * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:
                         # <ul>
                         #     <li>“linear”</li>
                         #     <li>“&lt;” or “easeIn” or “ease-in”</li>
                         #     <li>“>” or “easeOut” or “ease-out”</li>
                         #     <li>“&lt;>” or “easeInOut” or “ease-in-out”</li>
                         #     <li>“backIn” or “back-in”</li>
                         #     <li>“backOut” or “back-out”</li>
                         #     <li>“elastic”</li>
                         #     <li>“bounce”</li>
                         # </ul>
                         # <p>See also <a href="http://raphaeljs.com/easing.html">Easing demo</a>.</p>
                         \*/
                        var ef = R.easing_formulas = {
                            linear: function (n) {
                                return n;
                            },
                            "<": function (n) {
                                return pow(n, 1.7);
                            },
                            ">": function (n) {
                                return pow(n, .48);
                            },
                            "<>": function (n) {
                                var q = .48 - n / 1.04,
                                    Q = math.sqrt(.1734 + q * q),
                                    x = Q - q,
                                    X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),
                                    y = -Q - q,
                                    Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),
                                    t = X + Y + .5;
                                return (1 - t) * 3 * t * t + t * t * t;
                            },
                            backIn: function (n) {
                                var s = 1.70158;
                                return n * n * ((s + 1) * n - s);
                            },
                            backOut: function (n) {
                                n = n - 1;
                                var s = 1.70158;
                                return n * n * ((s + 1) * n + s) + 1;
                            },
                            elastic: function (n) {
                                if (n == !!n) {
                                    return n;
                                }
                                return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;
                            },
                            bounce: function (n) {
                                var s = 7.5625,
                                    p = 2.75,
                                    l;
                                if (n < (1 / p)) {
                                    l = s * n * n;
                                } else {
                                    if (n < (2 / p)) {
                                        n -= (1.5 / p);
                                        l = s * n * n + .75;
                                    } else {
                                        if (n < (2.5 / p)) {
                                            n -= (2.25 / p);
                                            l = s * n * n + .9375;
                                        } else {
                                            n -= (2.625 / p);
                                            l = s * n * n + .984375;
                                        }
                                    }
                                }
                                return l;
                            }
                        };
                        ef.easeIn = ef["ease-in"] = ef["<"];
                        ef.easeOut = ef["ease-out"] = ef[">"];
                        ef.easeInOut = ef["ease-in-out"] = ef["<>"];
                        ef["back-in"] = ef.backIn;
                        ef["back-out"] = ef.backOut;

                        var animationElements = [],
                            requestAnimFrame = window.requestAnimationFrame       ||
                                window.webkitRequestAnimationFrame ||
                                window.mozRequestAnimationFrame    ||
                                window.oRequestAnimationFrame      ||
                                window.msRequestAnimationFrame     ||
                                function (callback) {
                                    setTimeout(callback, 16);
                                },
                            animation = function () {
                                var Now = +new Date,
                                    l = 0;
                                for (; l < animationElements.length; l++) {
                                    var e = animationElements[l];
                                    if (e.el.removed || e.paused) {
                                        continue;
                                    }
                                    var time = Now - e.start,
                                        ms = e.ms,
                                        easing = e.easing,
                                        from = e.from,
                                        diff = e.diff,
                                        to = e.to,
                                        t = e.t,
                                        that = e.el,
                                        set = {},
                                        now,
                                        init = {},
                                        key;
                                    if (e.initstatus) {
                                        time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
                                        e.status = e.initstatus;
                                        delete e.initstatus;
                                        e.stop && animationElements.splice(l--, 1);
                                    } else {
                                        e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
                                    }
                                    if (time < 0) {
                                        continue;
                                    }
                                    if (time < ms) {
                                        var pos = easing(time / ms);
                                        for (var attr in from) if (from[has](attr)) {
                                            switch (availableAnimAttrs[attr]) {
                                                case nu:
                                                    now = +from[attr] + pos * ms * diff[attr];
                                                    break;
                                                case "colour":
                                                    now = "rgb(" + [
                                                            upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                                            upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                                            upto255(round(from[attr].b + pos * ms * diff[attr].b))
                                                        ].join(",") + ")";
                                                    break;
                                                case "path":
                                                    now = [];
                                                    for (var i = 0, ii = from[attr].length; i < ii; i++) {
                                                        now[i] = [from[attr][i][0]];
                                                        for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                                            now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                                                        }
                                                        now[i] = now[i].join(S);
                                                    }
                                                    now = now.join(S);
                                                    break;
                                                case "transform":
                                                    if (diff[attr].real) {
                                                        now = [];
                                                        for (i = 0, ii = from[attr].length; i < ii; i++) {
                                                            now[i] = [from[attr][i][0]];
                                                            for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                                                now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                                            }
                                                        }
                                                    } else {
                                                        var get = function (i) {
                                                            return +from[attr][i] + pos * ms * diff[attr][i];
                                                        };
                                                        // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                                                        now = [["m", get(0), get(1), get(2), get(3), get(4), get(5)]];
                                                    }
                                                    break;
                                                case "csv":
                                                    if (attr == "clip-rect") {
                                                        now = [];
                                                        i = 4;
                                                        while (i--) {
                                                            now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                                                        }
                                                    }
                                                    break;
                                                default:
                                                    var from2 = [][concat](from[attr]);
                                                    now = [];
                                                    i = that.paper.customAttributes[attr].length;
                                                    while (i--) {
                                                        now[i] = +from2[i] + pos * ms * diff[attr][i];
                                                    }
                                                    break;
                                            }
                                            set[attr] = now;
                                        }
                                        that.attr(set);
                                        (function (id, that, anim) {
                                            setTimeout(function () {
                                                eve("raphael.anim.frame." + id, that, anim);
                                            });
                                        })(that.id, that, e.anim);
                                    } else {
                                        (function(f, el, a) {
                                            setTimeout(function() {
                                                eve("raphael.anim.frame." + el.id, el, a);
                                                eve("raphael.anim.finish." + el.id, el, a);
                                                R.is(f, "function") && f.call(el);
                                            });
                                        })(e.callback, that, e.anim);
                                        that.attr(to);
                                        animationElements.splice(l--, 1);
                                        if (e.repeat > 1 && !e.next) {
                                            for (key in to) if (to[has](key)) {
                                                init[key] = e.totalOrigin[key];
                                            }
                                            e.el.attr(init);
                                            runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
                                        }
                                        if (e.next && !e.stop) {
                                            runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
                                        }
                                    }
                                }
                                animationElements.length && requestAnimFrame(animation);
                            },
                            upto255 = function (color) {
                                return color > 255 ? 255 : color < 0 ? 0 : color;
                            };
                        /*\
                         * Element.animateWith
                         [ method ]
                         **
                         * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.
                         **
                         > Parameters
                         **
                         - el (object) element to sync with
                         - anim (object) animation to sync with
                         - params (object) #optional final attributes for the element, see also @Element.attr
                         - ms (number) #optional number of milliseconds for animation to run
                         - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
                         - callback (function) #optional callback function. Will be called at the end of animation.
                         * or
                         - element (object) element to sync with
                         - anim (object) animation to sync with
                         - animation (object) #optional animation object, see @Raphael.animation
                         **
                         = (object) original element
                         \*/
                        elproto.animateWith = function (el, anim, params, ms, easing, callback) {
                            var element = this;
                            if (element.removed) {
                                callback && callback.call(element);
                                return element;
                            }
                            var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),
                                x, y;
                            runAnimation(a, element, a.percents[0], null, element.attr());
                            for (var i = 0, ii = animationElements.length; i < ii; i++) {
                                if (animationElements[i].anim == anim && animationElements[i].el == el) {
                                    animationElements[ii - 1].start = animationElements[i].start;
                                    break;
                                }
                            }
                            return element;
                            //
                            //
                            // var a = params ? R.animation(params, ms, easing, callback) : anim,
                            //     status = element.status(anim);
                            // return this.animate(a).status(a, status * anim.ms / a.ms);
                        };
                        function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
                            var cx = 3 * p1x,
                                bx = 3 * (p2x - p1x) - cx,
                                ax = 1 - cx - bx,
                                cy = 3 * p1y,
                                by = 3 * (p2y - p1y) - cy,
                                ay = 1 - cy - by;
                            function sampleCurveX(t) {
                                return ((ax * t + bx) * t + cx) * t;
                            }
                            function solve(x, epsilon) {
                                var t = solveCurveX(x, epsilon);
                                return ((ay * t + by) * t + cy) * t;
                            }
                            function solveCurveX(x, epsilon) {
                                var t0, t1, t2, x2, d2, i;
                                for(t2 = x, i = 0; i < 8; i++) {
                                    x2 = sampleCurveX(t2) - x;
                                    if (abs(x2) < epsilon) {
                                        return t2;
                                    }
                                    d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                                    if (abs(d2) < 1e-6) {
                                        break;
                                    }
                                    t2 = t2 - x2 / d2;
                                }
                                t0 = 0;
                                t1 = 1;
                                t2 = x;
                                if (t2 < t0) {
                                    return t0;
                                }
                                if (t2 > t1) {
                                    return t1;
                                }
                                while (t0 < t1) {
                                    x2 = sampleCurveX(t2);
                                    if (abs(x2 - x) < epsilon) {
                                        return t2;
                                    }
                                    if (x > x2) {
                                        t0 = t2;
                                    } else {
                                        t1 = t2;
                                    }
                                    t2 = (t1 - t0) / 2 + t0;
                                }
                                return t2;
                            }
                            return solve(t, 1 / (200 * duration));
                        }
                        elproto.onAnimation = function (f) {
                            f ? eve.on("raphael.anim.frame." + this.id, f) : eve.unbind("raphael.anim.frame." + this.id);
                            return this;
                        };
                        function Animation(anim, ms) {
                            var percents = [],
                                newAnim = {};
                            this.ms = ms;
                            this.times = 1;
                            if (anim) {
                                for (var attr in anim) if (anim[has](attr)) {
                                    newAnim[toFloat(attr)] = anim[attr];
                                    percents.push(toFloat(attr));
                                }
                                percents.sort(sortByNumber);
                            }
                            this.anim = newAnim;
                            this.top = percents[percents.length - 1];
                            this.percents = percents;
                        }
                        /*\
                         * Animation.delay
                         [ method ]
                         **
                         * Creates a copy of existing animation object with given delay.
                         **
                         > Parameters
                         **
                         - delay (number) number of ms to pass between animation start and actual animation
                         **
                         = (object) new altered Animation object
                         | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);
                         | circle1.animate(anim); // run the given animation immediately
                         | circle2.animate(anim.delay(500)); // run the given animation after 500 ms
                         \*/
                        Animation.prototype.delay = function (delay) {
                            var a = new Animation(this.anim, this.ms);
                            a.times = this.times;
                            a.del = +delay || 0;
                            return a;
                        };
                        /*\
                         * Animation.repeat
                         [ method ]
                         **
                         * Creates a copy of existing animation object with given repetition.
                         **
                         > Parameters
                         **
                         - repeat (number) number iterations of animation. For infinite animation pass `Infinity`
                         **
                         = (object) new altered Animation object
                         \*/
                        Animation.prototype.repeat = function (times) {
                            var a = new Animation(this.anim, this.ms);
                            a.del = this.del;
                            a.times = math.floor(mmax(times, 0)) || 1;
                            return a;
                        };
                        function runAnimation(anim, element, percent, status, totalOrigin, times) {
                            percent = toFloat(percent);
                            var params,
                                isInAnim,
                                isInAnimSet,
                                percents = [],
                                next,
                                prev,
                                timestamp,
                                ms = anim.ms,
                                from = {},
                                to = {},
                                diff = {};
                            if (status) {
                                for (i = 0, ii = animationElements.length; i < ii; i++) {
                                    var e = animationElements[i];
                                    if (e.el.id == element.id && e.anim == anim) {
                                        if (e.percent != percent) {
                                            animationElements.splice(i, 1);
                                            isInAnimSet = 1;
                                        } else {
                                            isInAnim = e;
                                        }
                                        element.attr(e.totalOrigin);
                                        break;
                                    }
                                }
                            } else {
                                status = +to; // NaN
                            }
                            for (var i = 0, ii = anim.percents.length; i < ii; i++) {
                                if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
                                    percent = anim.percents[i];
                                    prev = anim.percents[i - 1] || 0;
                                    ms = ms / anim.top * (percent - prev);
                                    next = anim.percents[i + 1];
                                    params = anim.anim[percent];
                                    break;
                                } else if (status) {
                                    element.attr(anim.anim[anim.percents[i]]);
                                }
                            }
                            if (!params) {
                                return;
                            }
                            if (!isInAnim) {
                                for (var attr in params) if (params[has](attr)) {
                                    if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
                                        from[attr] = element.attr(attr);
                                        (from[attr] == null) && (from[attr] = availableAttrs[attr]);
                                        to[attr] = params[attr];
                                        switch (availableAnimAttrs[attr]) {
                                            case nu:
                                                diff[attr] = (to[attr] - from[attr]) / ms;
                                                break;
                                            case "colour":
                                                from[attr] = R.getRGB(from[attr]);
                                                var toColour = R.getRGB(to[attr]);
                                                diff[attr] = {
                                                    r: (toColour.r - from[attr].r) / ms,
                                                    g: (toColour.g - from[attr].g) / ms,
                                                    b: (toColour.b - from[attr].b) / ms
                                                };
                                                break;
                                            case "path":
                                                var pathes = path2curve(from[attr], to[attr]),
                                                    toPath = pathes[1];
                                                from[attr] = pathes[0];
                                                diff[attr] = [];
                                                for (i = 0, ii = from[attr].length; i < ii; i++) {
                                                    diff[attr][i] = [0];
                                                    for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                                        diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                                                    }
                                                }
                                                break;
                                            case "transform":
                                                var _ = element._,
                                                    eq = equaliseTransform(_[attr], to[attr]);
                                                if (eq) {
                                                    from[attr] = eq.from;
                                                    to[attr] = eq.to;
                                                    diff[attr] = [];
                                                    diff[attr].real = true;
                                                    for (i = 0, ii = from[attr].length; i < ii; i++) {
                                                        diff[attr][i] = [from[attr][i][0]];
                                                        for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                                            diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                                        }
                                                    }
                                                } else {
                                                    var m = (element.matrix || new Matrix),
                                                        to2 = {
                                                            _: {transform: _.transform},
                                                            getBBox: function () {
                                                                return element.getBBox(1);
                                                            }
                                                        };
                                                    from[attr] = [
                                                        m.a,
                                                        m.b,
                                                        m.c,
                                                        m.d,
                                                        m.e,
                                                        m.f
                                                    ];
                                                    extractTransform(to2, to[attr]);
                                                    to[attr] = to2._.transform;
                                                    diff[attr] = [
                                                        (to2.matrix.a - m.a) / ms,
                                                        (to2.matrix.b - m.b) / ms,
                                                        (to2.matrix.c - m.c) / ms,
                                                        (to2.matrix.d - m.d) / ms,
                                                        (to2.matrix.e - m.e) / ms,
                                                        (to2.matrix.f - m.f) / ms
                                                    ];
                                                    // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                                                    // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                                                    // extractTransform(to2, to[attr]);
                                                    // diff[attr] = [
                                                    //     (to2._.sx - _.sx) / ms,
                                                    //     (to2._.sy - _.sy) / ms,
                                                    //     (to2._.deg - _.deg) / ms,
                                                    //     (to2._.dx - _.dx) / ms,
                                                    //     (to2._.dy - _.dy) / ms
                                                    // ];
                                                }
                                                break;
                                            case "csv":
                                                var values = Str(params[attr])[split](separator),
                                                    from2 = Str(from[attr])[split](separator);
                                                if (attr == "clip-rect") {
                                                    from[attr] = from2;
                                                    diff[attr] = [];
                                                    i = from2.length;
                                                    while (i--) {
                                                        diff[attr][i] = (values[i] - from[attr][i]) / ms;
                                                    }
                                                }
                                                to[attr] = values;
                                                break;
                                            default:
                                                values = [][concat](params[attr]);
                                                from2 = [][concat](from[attr]);
                                                diff[attr] = [];
                                                i = element.paper.customAttributes[attr].length;
                                                while (i--) {
                                                    diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                                                }
                                                break;
                                        }
                                    }
                                }
                                var easing = params.easing,
                                    easyeasy = R.easing_formulas[easing];
                                if (!easyeasy) {
                                    easyeasy = Str(easing).match(bezierrg);
                                    if (easyeasy && easyeasy.length == 5) {
                                        var curve = easyeasy;
                                        easyeasy = function (t) {
                                            return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                                        };
                                    } else {
                                        easyeasy = pipe;
                                    }
                                }
                                timestamp = params.start || anim.start || +new Date;
                                e = {
                                    anim: anim,
                                    percent: percent,
                                    timestamp: timestamp,
                                    start: timestamp + (anim.del || 0),
                                    status: 0,
                                    initstatus: status || 0,
                                    stop: false,
                                    ms: ms,
                                    easing: easyeasy,
                                    from: from,
                                    diff: diff,
                                    to: to,
                                    el: element,
                                    callback: params.callback,
                                    prev: prev,
                                    next: next,
                                    repeat: times || anim.times,
                                    origin: element.attr(),
                                    totalOrigin: totalOrigin
                                };
                                animationElements.push(e);
                                if (status && !isInAnim && !isInAnimSet) {
                                    e.stop = true;
                                    e.start = new Date - ms * status;
                                    if (animationElements.length == 1) {
                                        return animation();
                                    }
                                }
                                if (isInAnimSet) {
                                    e.start = new Date - e.ms * status;
                                }
                                animationElements.length == 1 && requestAnimFrame(animation);
                            } else {
                                isInAnim.initstatus = status;
                                isInAnim.start = new Date - isInAnim.ms * status;
                            }
                            eve("raphael.anim.start." + element.id, element, anim);
                        }
                        /*\
                         * Raphael.animation
                         [ method ]
                         **
                         * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.
                         * See also @Animation.delay and @Animation.repeat methods.
                         **
                         > Parameters
                         **
                         - params (object) final attributes for the element, see also @Element.attr
                         - ms (number) number of milliseconds for animation to run
                         - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
                         - callback (function) #optional callback function. Will be called at the end of animation.
                         **
                         = (object) @Animation
                         \*/
                        R.animation = function (params, ms, easing, callback) {
                            if (params instanceof Animation) {
                                return params;
                            }
                            if (R.is(easing, "function") || !easing) {
                                callback = callback || easing || null;
                                easing = null;
                            }
                            params = Object(params);
                            ms = +ms || 0;
                            var p = {},
                                json,
                                attr;
                            for (attr in params) if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + "%" != attr) {
                                json = true;
                                p[attr] = params[attr];
                            }
                            if (!json) {
                                // if percent-like syntax is used and end-of-all animation callback used
                                if(callback){
                                    // find the last one
                                    var lastKey = 0;
                                    for(var i in params){
                                        var percent = toInt(i);
                                        if(params[has](i) && percent > lastKey){
                                            lastKey = percent;
                                        }
                                    }
                                    lastKey += '%';
                                    // if already defined callback in the last keyframe, skip
                                    !params[lastKey].callback && (params[lastKey].callback = callback);
                                }
                                return new Animation(params, ms);
                            } else {
                                easing && (p.easing = easing);
                                callback && (p.callback = callback);
                                return new Animation({100: p}, ms);
                            }
                        };
                        /*\
                         * Element.animate
                         [ method ]
                         **
                         * Creates and starts animation for given element.
                         **
                         > Parameters
                         **
                         - params (object) final attributes for the element, see also @Element.attr
                         - ms (number) number of milliseconds for animation to run
                         - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
                         - callback (function) #optional callback function. Will be called at the end of animation.
                         * or
                         - animation (object) animation object, see @Raphael.animation
                         **
                         = (object) original element
                         \*/
                        elproto.animate = function (params, ms, easing, callback) {
                            var element = this;
                            if (element.removed) {
                                callback && callback.call(element);
                                return element;
                            }
                            var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
                            runAnimation(anim, element, anim.percents[0], null, element.attr());
                            return element;
                        };
                        /*\
                         * Element.setTime
                         [ method ]
                         **
                         * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.
                         **
                         > Parameters
                         **
                         - anim (object) animation object
                         - value (number) number of milliseconds from the beginning of the animation
                         **
                         = (object) original element if `value` is specified
                         * Note, that during animation following events are triggered:
                         *
                         * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.
                         \*/
                        elproto.setTime = function (anim, value) {
                            if (anim && value != null) {
                                this.status(anim, mmin(value, anim.ms) / anim.ms);
                            }
                            return this;
                        };
                        /*\
                         * Element.status
                         [ method ]
                         **
                         * Gets or sets the status of animation of the element.
                         **
                         > Parameters
                         **
                         - anim (object) #optional animation object
                         - value (number) #optional 0 – 1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.
                         **
                         = (number) status
                         * or
                         = (array) status if `anim` is not specified. Array of objects in format:
                         o {
                         o     anim: (object) animation object
                         o     status: (number) status
                         o }
                         * or
                         = (object) original element if `value` is specified
                         \*/
                        elproto.status = function (anim, value) {
                            var out = [],
                                i = 0,
                                len,
                                e;
                            if (value != null) {
                                runAnimation(anim, this, -1, mmin(value, 1));
                                return this;
                            } else {
                                len = animationElements.length;
                                for (; i < len; i++) {
                                    e = animationElements[i];
                                    if (e.el.id == this.id && (!anim || e.anim == anim)) {
                                        if (anim) {
                                            return e.status;
                                        }
                                        out.push({
                                            anim: e.anim,
                                            status: e.status
                                        });
                                    }
                                }
                                if (anim) {
                                    return 0;
                                }
                                return out;
                            }
                        };
                        /*\
                         * Element.pause
                         [ method ]
                         **
                         * Stops animation of the element with ability to resume it later on.
                         **
                         > Parameters
                         **
                         - anim (object) #optional animation object
                         **
                         = (object) original element
                         \*/
                        elproto.pause = function (anim) {
                            for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                                if (eve("raphael.anim.pause." + this.id, this, animationElements[i].anim) !== false) {
                                    animationElements[i].paused = true;
                                }
                            }
                            return this;
                        };
                        /*\
                         * Element.resume
                         [ method ]
                         **
                         * Resumes animation if it was paused with @Element.pause method.
                         **
                         > Parameters
                         **
                         - anim (object) #optional animation object
                         **
                         = (object) original element
                         \*/
                        elproto.resume = function (anim) {
                            for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                                var e = animationElements[i];
                                if (eve("raphael.anim.resume." + this.id, this, e.anim) !== false) {
                                    delete e.paused;
                                    this.status(e.anim, e.status);
                                }
                            }
                            return this;
                        };
                        /*\
                         * Element.stop
                         [ method ]
                         **
                         * Stops animation of the element.
                         **
                         > Parameters
                         **
                         - anim (object) #optional animation object
                         **
                         = (object) original element
                         \*/
                        elproto.stop = function (anim) {
                            for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                                if (eve("raphael.anim.stop." + this.id, this, animationElements[i].anim) !== false) {
                                    animationElements.splice(i--, 1);
                                }
                            }
                            return this;
                        };
                        function stopAnimation(paper) {
                            for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.paper == paper) {
                                animationElements.splice(i--, 1);
                            }
                        }
                        eve.on("raphael.remove", stopAnimation);
                        eve.on("raphael.clear", stopAnimation);
                        elproto.toString = function () {
                            return "Rapha\xebl\u2019s object";
                        };

                        // Set
                        var Set = function (items) {
                                this.items = [];
                                this.length = 0;
                                this.type = "set";
                                if (items) {
                                    for (var i = 0, ii = items.length; i < ii; i++) {
                                        if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                                            this[this.items.length] = this.items[this.items.length] = items[i];
                                            this.length++;
                                        }
                                    }
                                }
                            },
                            setproto = Set.prototype;
                        /*\
                         * Set.push
                         [ method ]
                         **
                         * Adds each argument to the current set.
                         = (object) original element
                         \*/
                        setproto.push = function () {
                            var item,
                                len;
                            for (var i = 0, ii = arguments.length; i < ii; i++) {
                                item = arguments[i];
                                if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
                                    len = this.items.length;
                                    this[len] = this.items[len] = item;
                                    this.length++;
                                }
                            }
                            return this;
                        };
                        /*\
                         * Set.pop
                         [ method ]
                         **
                         * Removes last element and returns it.
                         = (object) element
                         \*/
                        setproto.pop = function () {
                            this.length && delete this[this.length--];
                            return this.items.pop();
                        };
                        /*\
                         * Set.forEach
                         [ method ]
                         **
                         * Executes given function for each element in the set.
                         *
                         * If function returns `false` it will stop loop running.
                         **
                         > Parameters
                         **
                         - callback (function) function to run
                         - thisArg (object) context object for the callback
                         = (object) Set object
                         \*/
                        setproto.forEach = function (callback, thisArg) {
                            for (var i = 0, ii = this.items.length; i < ii; i++) {
                                if (callback.call(thisArg, this.items[i], i) === false) {
                                    return this;
                                }
                            }
                            return this;
                        };
                        for (var method in elproto) if (elproto[has](method)) {
                            setproto[method] = (function (methodname) {
                                return function () {
                                    var arg = arguments;
                                    return this.forEach(function (el) {
                                        el[methodname][apply](el, arg);
                                    });
                                };
                            })(method);
                        }
                        setproto.attr = function (name, value) {
                            if (name && R.is(name, array) && R.is(name[0], "object")) {
                                for (var j = 0, jj = name.length; j < jj; j++) {
                                    this.items[j].attr(name[j]);
                                }
                            } else {
                                for (var i = 0, ii = this.items.length; i < ii; i++) {
                                    this.items[i].attr(name, value);
                                }
                            }
                            return this;
                        };
                        /*\
                         * Set.clear
                         [ method ]
                         **
                         * Removes all elements from the set
                         \*/
                        setproto.clear = function () {
                            while (this.length) {
                                this.pop();
                            }
                        };
                        /*\
                         * Set.splice
                         [ method ]
                         **
                         * Removes given element from the set
                         **
                         > Parameters
                         **
                         - index (number) position of the deletion
                         - count (number) number of element to remove
                         - insertion… (object) #optional elements to insert
                         = (object) set elements that were deleted
                         \*/
                        setproto.splice = function (index, count, insertion) {
                            index = index < 0 ? mmax(this.length + index, 0) : index;
                            count = mmax(0, mmin(this.length - index, count));
                            var tail = [],
                                todel = [],
                                args = [],
                                i;
                            for (i = 2; i < arguments.length; i++) {
                                args.push(arguments[i]);
                            }
                            for (i = 0; i < count; i++) {
                                todel.push(this[index + i]);
                            }
                            for (; i < this.length - index; i++) {
                                tail.push(this[index + i]);
                            }
                            var arglen = args.length;
                            for (i = 0; i < arglen + tail.length; i++) {
                                this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
                            }
                            i = this.items.length = this.length -= count - arglen;
                            while (this[i]) {
                                delete this[i++];
                            }
                            return new Set(todel);
                        };
                        /*\
                         * Set.exclude
                         [ method ]
                         **
                         * Removes given element from the set
                         **
                         > Parameters
                         **
                         - element (object) element to remove
                         = (boolean) `true` if object was found & removed from the set
                         \*/
                        setproto.exclude = function (el) {
                            for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
                                this.splice(i, 1);
                                return true;
                            }
                        };
                        setproto.animate = function (params, ms, easing, callback) {
                            (R.is(easing, "function") || !easing) && (callback = easing || null);
                            var len = this.items.length,
                                i = len,
                                item,
                                set = this,
                                collector;
                            if (!len) {
                                return this;
                            }
                            callback && (collector = function () {
                                !--len && callback.call(set);
                            });
                            easing = R.is(easing, string) ? easing : collector;
                            var anim = R.animation(params, ms, easing, collector);
                            item = this.items[--i].animate(anim);
                            while (i--) {
                                this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
                                (this.items[i] && !this.items[i].removed) || len--;
                            }
                            return this;
                        };
                        setproto.insertAfter = function (el) {
                            var i = this.items.length;
                            while (i--) {
                                this.items[i].insertAfter(el);
                            }
                            return this;
                        };
                        setproto.getBBox = function () {
                            var x = [],
                                y = [],
                                x2 = [],
                                y2 = [];
                            for (var i = this.items.length; i--;) if (!this.items[i].removed) {
                                var box = this.items[i].getBBox();
                                x.push(box.x);
                                y.push(box.y);
                                x2.push(box.x + box.width);
                                y2.push(box.y + box.height);
                            }
                            x = mmin[apply](0, x);
                            y = mmin[apply](0, y);
                            x2 = mmax[apply](0, x2);
                            y2 = mmax[apply](0, y2);
                            return {
                                x: x,
                                y: y,
                                x2: x2,
                                y2: y2,
                                width: x2 - x,
                                height: y2 - y
                            };
                        };
                        setproto.clone = function (s) {
                            s = this.paper.set();
                            for (var i = 0, ii = this.items.length; i < ii; i++) {
                                s.push(this.items[i].clone());
                            }
                            return s;
                        };
                        setproto.toString = function () {
                            return "Rapha\xebl\u2018s set";
                        };

                        setproto.glow = function(glowConfig) {
                            var ret = this.paper.set();
                            this.forEach(function(shape, index){
                                var g = shape.glow(glowConfig);
                                if(g != null){
                                    g.forEach(function(shape2, index2){
                                        ret.push(shape2);
                                    });
                                }
                            });
                            return ret;
                        };


                        /*\
                         * Set.isPointInside
                         [ method ]
                         **
                         * Determine if given point is inside this set’s elements
                         **
                         > Parameters
                         **
                         - x (number) x coordinate of the point
                         - y (number) y coordinate of the point
                         = (boolean) `true` if point is inside any of the set's elements
                         \*/
                        setproto.isPointInside = function (x, y) {
                            var isPointInside = false;
                            this.forEach(function (el) {
                                if (el.isPointInside(x, y)) {
                                    isPointInside = true;
                                    return false; // stop loop
                                }
                            });
                            return isPointInside;
                        };

                        /*\
                         * Raphael.registerFont
                         [ method ]
                         **
                         * Adds given font to the registered set of fonts for Raphaël. Should be used as an internal call from within Cufón’s font file.
                         * Returns original parameter, so it could be used with chaining.
                         # <a href="http://wiki.github.com/sorccu/cufon/about">More about Cufón and how to convert your font form TTF, OTF, etc to JavaScript file.</a>
                         **
                         > Parameters
                         **
                         - font (object) the font to register
                         = (object) the font you passed in
                         > Usage
                         | Cufon.registerFont(Raphael.registerFont({…}));
                         \*/
                        R.registerFont = function (font) {
                            if (!font.face) {
                                return font;
                            }
                            this.fonts = this.fonts || {};
                            var fontcopy = {
                                    w: font.w,
                                    face: {},
                                    glyphs: {}
                                },
                                family = font.face["font-family"];
                            for (var prop in font.face) if (font.face[has](prop)) {
                                fontcopy.face[prop] = font.face[prop];
                            }
                            if (this.fonts[family]) {
                                this.fonts[family].push(fontcopy);
                            } else {
                                this.fonts[family] = [fontcopy];
                            }
                            if (!font.svg) {
                                fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
                                for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {
                                    var path = font.glyphs[glyph];
                                    fontcopy.glyphs[glyph] = {
                                        w: path.w,
                                        k: {},
                                        d: path.d && "M" + path.d.replace(/[mlcxtrv]/g, function (command) {
                                            return {l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[command] || "M";
                                        }) + "z"
                                    };
                                    if (path.k) {
                                        for (var k in path.k) if (path[has](k)) {
                                            fontcopy.glyphs[glyph].k[k] = path.k[k];
                                        }
                                    }
                                }
                            }
                            return font;
                        };
                        /*\
                         * Paper.getFont
                         [ method ]
                         **
                         * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like “Myriad” for “Myriad Pro”.
                         **
                         > Parameters
                         **
                         - family (string) font family name or any word from it
                         - weight (string) #optional font weight
                         - style (string) #optional font style
                         - stretch (string) #optional font stretch
                         = (object) the font object
                         > Usage
                         | paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
                         \*/
                        paperproto.getFont = function (family, weight, style, stretch) {
                            stretch = stretch || "normal";
                            style = style || "normal";
                            weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;
                            if (!R.fonts) {
                                return;
                            }
                            var font = R.fonts[family];
                            if (!font) {
                                var name = new RegExp("(^|\\s)" + family.replace(/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
                                for (var fontName in R.fonts) if (R.fonts[has](fontName)) {
                                    if (name.test(fontName)) {
                                        font = R.fonts[fontName];
                                        break;
                                    }
                                }
                            }
                            var thefont;
                            if (font) {
                                for (var i = 0, ii = font.length; i < ii; i++) {
                                    thefont = font[i];
                                    if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
                                        break;
                                    }
                                }
                            }
                            return thefont;
                        };
                        /*\
                         * Paper.print
                         [ method ]
                         **
                         * Creates path that represent given text written using given font at given position with given size.
                         * Result of the method is path element that contains whole text as a separate path.
                         **
                         > Parameters
                         **
                         - x (number) x position of the text
                         - y (number) y position of the text
                         - string (string) text to print
                         - font (object) font object, see @Paper.getFont
                         - size (number) #optional size of the font, default is `16`
                         - origin (string) #optional could be `"baseline"` or `"middle"`, default is `"middle"`
                         - letter_spacing (number) #optional number in range `-1..1`, default is `0`
                         - line_spacing (number) #optional number in range `1..3`, default is `1`
                         = (object) resulting path element, which consist of all letters
                         > Usage
                         | var txt = r.print(10, 50, "print", r.getFont("Museo"), 30).attr({fill: "#fff"});
                         \*/
                        paperproto.print = function (x, y, string, font, size, origin, letter_spacing, line_spacing) {
                            origin = origin || "middle"; // baseline|middle
                            letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
                            line_spacing = mmax(mmin(line_spacing || 1, 3), 1);
                            var letters = Str(string)[split](E),
                                shift = 0,
                                notfirst = 0,
                                path = E,
                                scale;
                            R.is(font, "string") && (font = this.getFont(font));
                            if (font) {
                                scale = (size || 16) / font.face["units-per-em"];
                                var bb = font.face.bbox[split](separator),
                                    top = +bb[0],
                                    lineHeight = bb[3] - bb[1],
                                    shifty = 0,
                                    height = +bb[1] + (origin == "baseline" ? lineHeight + (+font.face.descent) : lineHeight / 2);
                                for (var i = 0, ii = letters.length; i < ii; i++) {
                                    if (letters[i] == "\n") {
                                        shift = 0;
                                        curr = 0;
                                        notfirst = 0;
                                        shifty += lineHeight * line_spacing;
                                    } else {
                                        var prev = notfirst && font.glyphs[letters[i - 1]] || {},
                                            curr = font.glyphs[letters[i]];
                                        shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
                                        notfirst = 1;
                                    }
                                    if (curr && curr.d) {
                                        path += R.transformPath(curr.d, ["t", shift * scale, shifty * scale, "s", scale, scale, top, height, "t", (x - top) / scale, (y - height) / scale]);
                                    }
                                }
                            }
                            return this.path(path).attr({
                                fill: "#000",
                                stroke: "none"
                            });
                        };

                        /*\
                         * Paper.add
                         [ method ]
                         **
                         * Imports elements in JSON array in format `{type: type, <attributes>}`
                         **
                         > Parameters
                         **
                         - json (array)
                         = (object) resulting set of imported elements
                         > Usage
                         | paper.add([
                         |     {
                         |         type: "circle",
                         |         cx: 10,
                         |         cy: 10,
                         |         r: 5
                         |     },
                         |     {
                         |         type: "rect",
                         |         x: 10,
                         |         y: 10,
                         |         width: 10,
                         |         height: 10,
                         |         fill: "#fc0"
                         |     }
                         | ]);
                         \*/
                        paperproto.add = function (json) {
                            if (R.is(json, "array")) {
                                var res = this.set(),
                                    i = 0,
                                    ii = json.length,
                                    j;
                                for (; i < ii; i++) {
                                    j = json[i] || {};
                                    elements[has](j.type) && res.push(this[j.type]().attr(j));
                                }
                            }
                            return res;
                        };

                        /*\
                         * Raphael.format
                         [ method ]
                         **
                         * Simple format function. Replaces construction of type “`{<number>}`” to the corresponding argument.
                         **
                         > Parameters
                         **
                         - token (string) string to format
                         - … (string) rest of arguments will be treated as parameters for replacement
                         = (string) formated string
                         > Usage
                         | var x = 10,
                         |     y = 20,
                         |     width = 40,
                         |     height = 50;
                         | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
                         | paper.path(Raphael.format("M{0},{1}h{2}v{3}h{4}z", x, y, width, height, -width));
                         \*/
                        R.format = function (token, params) {
                            var args = R.is(params, array) ? [0][concat](params) : arguments;
                            token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {
                                return args[++i] == null ? E : args[i];
                            }));
                            return token || E;
                        };
                        /*\
                         * Raphael.fullfill
                         [ method ]
                         **
                         * A little bit more advanced format function than @Raphael.format. Replaces construction of type “`{<name>}`” to the corresponding argument.
                         **
                         > Parameters
                         **
                         - token (string) string to format
                         - json (object) object which properties will be used as a replacement
                         = (string) formated string
                         > Usage
                         | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
                         | paper.path(Raphael.fullfill("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
                         |     x: 10,
                         |     y: 20,
                         |     dim: {
                         |         width: 40,
                         |         height: 50,
                         |         "negative width": -40
                         |     }
                         | }));
                         \*/
                        R.fullfill = (function () {
                            var tokenRegex = /\{([^\}]+)\}/g,
                                objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
                                replacer = function (all, key, obj) {
                                    var res = obj;
                                    key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                                        name = name || quotedName;
                                        if (res) {
                                            if (name in res) {
                                                res = res[name];
                                            }
                                            typeof res == "function" && isFunc && (res = res());
                                        }
                                    });
                                    res = (res == null || res == obj ? all : res) + "";
                                    return res;
                                };
                            return function (str, obj) {
                                return String(str).replace(tokenRegex, function (all, key) {
                                    return replacer(all, key, obj);
                                });
                            };
                        })();
                        /*\
                         * Raphael.ninja
                         [ method ]
                         **
                         * If you want to leave no trace of Raphaël (Well, Raphaël creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.
                         * Beware, that in this case plugins could stop working, because they are depending on global variable existence.
                         **
                         = (object) Raphael object
                         > Usage
                         | (function (local_raphael) {
                         |     var paper = local_raphael(10, 10, 320, 200);
                         |     …
                         | })(Raphael.ninja());
                         \*/
                        R.ninja = function () {
                            if (oldRaphael.was) {
                                g.win.Raphael = oldRaphael.is;
                            } else {
                                // IE8 raises an error when deleting window property
                                window.Raphael = undefined;
                                try {
                                    delete window.Raphael;
                                } catch(e) {}
                            }
                            return R;
                        };
                        /*\
                         * Raphael.st
                         [ property (object) ]
                         **
                         * You can add your own method to elements and sets. It is wise to add a set method for each element method
                         * you added, so you will be able to call the same method on sets too.
                         **
                         * See also @Raphael.el.
                         > Usage
                         | Raphael.el.red = function () {
                         |     this.attr({fill: "#f00"});
                         | };
                         | Raphael.st.red = function () {
                         |     this.forEach(function (el) {
                         |         el.red();
                         |     });
                         | };
                         | // then use it
                         | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();
                         \*/
                        R.st = setproto;

                        eve.on("raphael.DOMload", function () {
                            loaded = true;
                        });

                        // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
                        (function (doc, loaded, f) {
                            if (doc.readyState == null && doc.addEventListener){
                                doc.addEventListener(loaded, f = function () {
                                    doc.removeEventListener(loaded, f, false);
                                    doc.readyState = "complete";
                                }, false);
                                doc.readyState = "loading";
                            }
                            function isLoaded() {
                                (/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve("raphael.DOMload");
                            }
                            isLoaded();
                        })(document, "DOMContentLoaded");

                        return R;
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


                    /***/ },
                /* 2 */
                /***/ function(module, exports, __webpack_require__) {

                    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
                    //
                    // Licensed under the Apache License, Version 2.0 (the "License");
                    // you may not use this file except in compliance with the License.
                    // You may obtain a copy of the License at
                    //
                    // http://www.apache.org/licenses/LICENSE-2.0
                    //
                    // Unless required by applicable law or agreed to in writing, software
                    // distributed under the License is distributed on an "AS IS" BASIS,
                    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                    // See the License for the specific language governing permissions and
                    // limitations under the License.
                    // ┌────────────────────────────────────────────────────────────┐ \\
                    // │ Eve 0.5.0 - JavaScript Events Library                      │ \\
                    // ├────────────────────────────────────────────────────────────┤ \\
                    // │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\
                    // └────────────────────────────────────────────────────────────┘ \\

                    (function (glob) {
                        var version = "0.5.0",
                            has = "hasOwnProperty",
                            separator = /[\.\/]/,
                            comaseparator = /\s*,\s*/,
                            wildcard = "*",
                            fun = function () {},
                            numsort = function (a, b) {
                                return a - b;
                            },
                            current_event,
                            stop,
                            events = {n: {}},
                            firstDefined = function () {
                                for (var i = 0, ii = this.length; i < ii; i++) {
                                    if (typeof this[i] != "undefined") {
                                        return this[i];
                                    }
                                }
                            },
                            lastDefined = function () {
                                var i = this.length;
                                while (--i) {
                                    if (typeof this[i] != "undefined") {
                                        return this[i];
                                    }
                                }
                            },
                            objtos = Object.prototype.toString,
                            Str = String,
                            isArray = Array.isArray || function (ar) {
                                    return ar instanceof Array || objtos.call(ar) == "[object Array]";
                                };
                        /*\
                         * eve
                         [ method ]

                         * Fires event with given `name`, given scope and other parameters.

                         > Arguments

                         - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
                         - scope (object) context for the event handlers
                         - varargs (...) the rest of arguments will be sent to event handlers

                         = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
                         \*/
                        eve = function (name, scope) {
                            var e = events,
                                oldstop = stop,
                                args = Array.prototype.slice.call(arguments, 2),
                                listeners = eve.listeners(name),
                                z = 0,
                                f = false,
                                l,
                                indexed = [],
                                queue = {},
                                out = [],
                                ce = current_event,
                                errors = [];
                            out.firstDefined = firstDefined;
                            out.lastDefined = lastDefined;
                            current_event = name;
                            stop = 0;
                            for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
                                indexed.push(listeners[i].zIndex);
                                if (listeners[i].zIndex < 0) {
                                    queue[listeners[i].zIndex] = listeners[i];
                                }
                            }
                            indexed.sort(numsort);
                            while (indexed[z] < 0) {
                                l = queue[indexed[z++]];
                                out.push(l.apply(scope, args));
                                if (stop) {
                                    stop = oldstop;
                                    return out;
                                }
                            }
                            for (i = 0; i < ii; i++) {
                                l = listeners[i];
                                if ("zIndex" in l) {
                                    if (l.zIndex == indexed[z]) {
                                        out.push(l.apply(scope, args));
                                        if (stop) {
                                            break;
                                        }
                                        do {
                                            z++;
                                            l = queue[indexed[z]];
                                            l && out.push(l.apply(scope, args));
                                            if (stop) {
                                                break;
                                            }
                                        } while (l)
                                    } else {
                                        queue[l.zIndex] = l;
                                    }
                                } else {
                                    out.push(l.apply(scope, args));
                                    if (stop) {
                                        break;
                                    }
                                }
                            }
                            stop = oldstop;
                            current_event = ce;
                            return out;
                        };
                        // Undocumented. Debug only.
                        eve._events = events;
                        /*\
                         * eve.listeners
                         [ method ]

                         * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

                         > Arguments

                         - name (string) name of the event, dot (`.`) or slash (`/`) separated

                         = (array) array of event handlers
                         \*/
                        eve.listeners = function (name) {
                            var names = isArray(name) ? name : name.split(separator),
                                e = events,
                                item,
                                items,
                                k,
                                i,
                                ii,
                                j,
                                jj,
                                nes,
                                es = [e],
                                out = [];
                            for (i = 0, ii = names.length; i < ii; i++) {
                                nes = [];
                                for (j = 0, jj = es.length; j < jj; j++) {
                                    e = es[j].n;
                                    items = [e[names[i]], e[wildcard]];
                                    k = 2;
                                    while (k--) {
                                        item = items[k];
                                        if (item) {
                                            nes.push(item);
                                            out = out.concat(item.f || []);
                                        }
                                    }
                                }
                                es = nes;
                            }
                            return out;
                        };
                        /*\
                         * eve.separator
                         [ method ]

                         * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours
                         * here. Be aware that if you pass a string longer than one character it will be treated as
                         * a list of characters.

                         - separator (string) new separator. Empty string resets to default: `.` or `/`.
                         \*/
                        eve.separator = function (sep) {
                            if (sep) {
                                sep = Str(sep).replace(/(?=[\.\^\]\[\-])/g, "\\");
                                sep = "[" + sep + "]";
                                separator = new RegExp(sep);
                            } else {
                                separator = /[\.\/]/;
                            }
                        };
                        /*\
                         * eve.on
                         [ method ]
                         **
                         * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
                         | eve.on("*.under.*", f);
                         | eve("mouse.under.floor"); // triggers f
                         * Use @eve to trigger the listener.
                         **
                         - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
                         - f (function) event handler function
                         **
                         - name (array) if you don’t want to use separators, you can use array of strings
                         - f (function) event handler function
                         **
                         = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.
                         > Example:
                         | eve.on("mouse", eatIt)(2);
                         | eve.on("mouse", scream);
                         | eve.on("mouse", catchIt)(1);
                         * This will ensure that `catchIt` function will be called before `eatIt`.
                         *
                         * If you want to put your handler before non-indexed handlers, specify a negative value.
                         * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
                         \*/
                        eve.on = function (name, f) {
                            if (typeof f != "function") {
                                return function () {};
                            }
                            var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);
                            for (var i = 0, ii = names.length; i < ii; i++) {
                                (function (name) {
                                    var names = isArray(name) ? name : Str(name).split(separator),
                                        e = events,
                                        exist;
                                    for (var i = 0, ii = names.length; i < ii; i++) {
                                        e = e.n;
                                        e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
                                    }
                                    e.f = e.f || [];
                                    for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
                                        exist = true;
                                        break;
                                    }
                                    !exist && e.f.push(f);
                                }(names[i]));
                            }
                            return function (zIndex) {
                                if (+zIndex == +zIndex) {
                                    f.zIndex = +zIndex;
                                }
                            };
                        };
                        /*\
                         * eve.f
                         [ method ]
                         **
                         * Returns function that will fire given event with optional arguments.
                         * Arguments that will be passed to the result function will be also
                         * concated to the list of final arguments.
                         | el.onclick = eve.f("click", 1, 2);
                         | eve.on("click", function (a, b, c) {
                         |     console.log(a, b, c); // 1, 2, [event object]
                         | });
                         > Arguments
                         - event (string) event name
                         - varargs (…) and any other arguments
                         = (function) possible event handler function
                         \*/
                        eve.f = function (event) {
                            var attrs = [].slice.call(arguments, 1);
                            return function () {
                                eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
                            };
                        };
                        /*\
                         * eve.stop
                         [ method ]
                         **
                         * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
                         \*/
                        eve.stop = function () {
                            stop = 1;
                        };
                        /*\
                         * eve.nt
                         [ method ]
                         **
                         * Could be used inside event handler to figure out actual name of the event.
                         **
                         > Arguments
                         **
                         - subname (string) #optional subname of the event
                         **
                         = (string) name of the event, if `subname` is not specified
                         * or
                         = (boolean) `true`, if current event’s name contains `subname`
                         \*/
                        eve.nt = function (subname) {
                            var cur = isArray(current_event) ? current_event.join(".") : current_event;
                            if (subname) {
                                return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(cur);
                            }
                            return cur;
                        };
                        /*\
                         * eve.nts
                         [ method ]
                         **
                         * Could be used inside event handler to figure out actual name of the event.
                         **
                         **
                         = (array) names of the event
                         \*/
                        eve.nts = function () {
                            return isArray(current_event) ? current_event : current_event.split(separator);
                        };
                        /*\
                         * eve.off
                         [ method ]
                         **
                         * Removes given function from the list of event listeners assigned to given name.
                         * If no arguments specified all the events will be cleared.
                         **
                         > Arguments
                         **
                         - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
                         - f (function) event handler function
                         \*/
                        /*\
                         * eve.unbind
                         [ method ]
                         **
                         * See @eve.off
                         \*/
                        eve.off = eve.unbind = function (name, f) {
                            if (!name) {
                                eve._events = events = {n: {}};
                                return;
                            }
                            var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);
                            if (names.length > 1) {
                                for (var i = 0, ii = names.length; i < ii; i++) {
                                    eve.off(names[i], f);
                                }
                                return;
                            }
                            names = isArray(name) ? name : Str(name).split(separator);
                            var e,
                                key,
                                splice,
                                i, ii, j, jj,
                                cur = [events];
                            for (i = 0, ii = names.length; i < ii; i++) {
                                for (j = 0; j < cur.length; j += splice.length - 2) {
                                    splice = [j, 1];
                                    e = cur[j].n;
                                    if (names[i] != wildcard) {
                                        if (e[names[i]]) {
                                            splice.push(e[names[i]]);
                                        }
                                    } else {
                                        for (key in e) if (e[has](key)) {
                                            splice.push(e[key]);
                                        }
                                    }
                                    cur.splice.apply(cur, splice);
                                }
                            }
                            for (i = 0, ii = cur.length; i < ii; i++) {
                                e = cur[i];
                                while (e.n) {
                                    if (f) {
                                        if (e.f) {
                                            for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                                                e.f.splice(j, 1);
                                                break;
                                            }
                                            !e.f.length && delete e.f;
                                        }
                                        for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                                            var funcs = e.n[key].f;
                                            for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                                                funcs.splice(j, 1);
                                                break;
                                            }
                                            !funcs.length && delete e.n[key].f;
                                        }
                                    } else {
                                        delete e.f;
                                        for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                                            delete e.n[key].f;
                                        }
                                    }
                                    e = e.n;
                                }
                            }
                        };
                        /*\
                         * eve.once
                         [ method ]
                         **
                         * Binds given event handler with a given name to only run once then unbind itself.
                         | eve.once("login", f);
                         | eve("login"); // triggers f
                         | eve("login"); // no listeners
                         * Use @eve to trigger the listener.
                         **
                         > Arguments
                         **
                         - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
                         - f (function) event handler function
                         **
                         = (function) same return function as @eve.on
                         \*/
                        eve.once = function (name, f) {
                            var f2 = function () {
                                eve.off(name, f2);
                                return f.apply(this, arguments);
                            };
                            return eve.on(name, f2);
                        };
                        /*\
                         * eve.version
                         [ property (string) ]
                         **
                         * Current version of the library.
                         \*/
                        eve.version = version;
                        eve.toString = function () {
                            return "You are running Eve " + version;
                        };
                        (typeof module != "undefined" && module.exports) ? (module.exports = eve) : ( true ? (!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() { return eve; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))) : (glob.eve = eve));
                    })(this);


                    /***/ },
                /* 3 */
                /***/ function(module, exports, __webpack_require__) {

                    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function(R) {
                        if (R && !R.svg) {
                            return;
                        }

                        var has = "hasOwnProperty",
                            Str = String,
                            toFloat = parseFloat,
                            toInt = parseInt,
                            math = Math,
                            mmax = math.max,
                            abs = math.abs,
                            pow = math.pow,
                            separator = /[, ]+/,
                            eve = R.eve,
                            E = "",
                            S = " ";
                        var xlink = "http://www.w3.org/1999/xlink",
                            markers = {
                                block: "M5,0 0,2.5 5,5z",
                                classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
                                diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
                                open: "M6,1 1,3.5 6,6",
                                oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
                            },
                            markerCounter = {};
                        R.toString = function () {
                            return  "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
                        };
                        var $ = function (el, attr) {
                                if (attr) {
                                    if (typeof el == "string") {
                                        el = $(el);
                                    }
                                    for (var key in attr) if (attr[has](key)) {
                                        if (key.substring(0, 6) == "xlink:") {
                                            el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
                                        } else {
                                            el.setAttribute(key, Str(attr[key]));
                                        }
                                    }
                                } else {
                                    el = R._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
                                    el.style && (el.style.webkitTapHighlightColor = "rgba(0,0,0,0)");
                                }
                                return el;
                            },
                            addGradientFill = function (element, gradient) {
                                var type = "linear",
                                    id = element.id + gradient,
                                    fx = .5, fy = .5,
                                    o = element.node,
                                    SVG = element.paper,
                                    s = o.style,
                                    el = R._g.doc.getElementById(id);
                                if (!el) {
                                    gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {
                                        type = "radial";
                                        if (_fx && _fy) {
                                            fx = toFloat(_fx);
                                            fy = toFloat(_fy);
                                            var dir = ((fy > .5) * 2 - 1);
                                            pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&
                                            (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&
                                            fy != .5 &&
                                            (fy = fy.toFixed(5) - 1e-5 * dir);
                                        }
                                        return E;
                                    });
                                    gradient = gradient.split(/\s*\-\s*/);
                                    if (type == "linear") {
                                        var angle = gradient.shift();
                                        angle = -toFloat(angle);
                                        if (isNaN(angle)) {
                                            return null;
                                        }
                                        var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],
                                            max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                                        vector[2] *= max;
                                        vector[3] *= max;
                                        if (vector[2] < 0) {
                                            vector[0] = -vector[2];
                                            vector[2] = 0;
                                        }
                                        if (vector[3] < 0) {
                                            vector[1] = -vector[3];
                                            vector[3] = 0;
                                        }
                                    }
                                    var dots = R._parseDots(gradient);
                                    if (!dots) {
                                        return null;
                                    }
                                    id = id.replace(/[\(\)\s,\xb0#]/g, "_");

                                    if (element.gradient && id != element.gradient.id) {
                                        SVG.defs.removeChild(element.gradient);
                                        delete element.gradient;
                                    }

                                    if (!element.gradient) {
                                        el = $(type + "Gradient", {id: id});
                                        element.gradient = el;
                                        $(el, type == "radial" ? {
                                                fx: fx,
                                                fy: fy
                                            } : {
                                                x1: vector[0],
                                                y1: vector[1],
                                                x2: vector[2],
                                                y2: vector[3],
                                                gradientTransform: element.matrix.invert()
                                            });
                                        SVG.defs.appendChild(el);
                                        for (var i = 0, ii = dots.length; i < ii; i++) {
                                            el.appendChild($("stop", {
                                                offset: dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
                                                "stop-color": dots[i].color || "#fff",
                                                "stop-opacity": isFinite(dots[i].opacity) ? dots[i].opacity : 1
                                            }));
                                        }
                                    }
                                }
                                $(o, {
                                    fill: fillurl(id),
                                    opacity: 1,
                                    "fill-opacity": 1
                                });
                                s.fill = E;
                                s.opacity = 1;
                                s.fillOpacity = 1;
                                return 1;
                            },
                            isIE9or10 = function () {
                                var mode = document.documentMode;
                                return mode && (mode === 9 || mode === 10);
                            },
                            fillurl = function (id) {
                                if (isIE9or10()) {
                                    return "url('#" + id + "')";
                                }
                                var location = document.location;
                                var locationString = (
                                    location.protocol + '//' +
                                    location.host +
                                    location.pathname +
                                    location.search
                                );
                                return "url('" + locationString + "#" + id + "')";
                            },
                            updatePosition = function (o) {
                                var bbox = o.getBBox(1);
                                $(o.pattern, {patternTransform: o.matrix.invert() + " translate(" + bbox.x + "," + bbox.y + ")"});
                            },
                            addArrow = function (o, value, isEnd) {
                                if (o.type == "path") {
                                    var values = Str(value).toLowerCase().split("-"),
                                        p = o.paper,
                                        se = isEnd ? "end" : "start",
                                        node = o.node,
                                        attrs = o.attrs,
                                        stroke = attrs["stroke-width"],
                                        i = values.length,
                                        type = "classic",
                                        from,
                                        to,
                                        dx,
                                        refX,
                                        attr,
                                        w = 3,
                                        h = 3,
                                        t = 5;
                                    while (i--) {
                                        switch (values[i]) {
                                            case "block":
                                            case "classic":
                                            case "oval":
                                            case "diamond":
                                            case "open":
                                            case "none":
                                                type = values[i];
                                                break;
                                            case "wide": h = 5; break;
                                            case "narrow": h = 2; break;
                                            case "long": w = 5; break;
                                            case "short": w = 2; break;
                                        }
                                    }
                                    if (type == "open") {
                                        w += 2;
                                        h += 2;
                                        t += 2;
                                        dx = 1;
                                        refX = isEnd ? 4 : 1;
                                        attr = {
                                            fill: "none",
                                            stroke: attrs.stroke
                                        };
                                    } else {
                                        refX = dx = w / 2;
                                        attr = {
                                            fill: attrs.stroke,
                                            stroke: "none"
                                        };
                                    }
                                    if (o._.arrows) {
                                        if (isEnd) {
                                            o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
                                            o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
                                        } else {
                                            o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
                                            o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
                                        }
                                    } else {
                                        o._.arrows = {};
                                    }
                                    if (type != "none") {
                                        var pathId = "raphael-marker-" + type,
                                            markerId = "raphael-marker-" + se + type + w + h + "-obj" + o.id;
                                        if (!R._g.doc.getElementById(pathId)) {
                                            p.defs.appendChild($($("path"), {
                                                "stroke-linecap": "round",
                                                d: markers[type],
                                                id: pathId
                                            }));
                                            markerCounter[pathId] = 1;
                                        } else {
                                            markerCounter[pathId]++;
                                        }
                                        var marker = R._g.doc.getElementById(markerId),
                                            use;
                                        if (!marker) {
                                            marker = $($("marker"), {
                                                id: markerId,
                                                markerHeight: h,
                                                markerWidth: w,
                                                orient: "auto",
                                                refX: refX,
                                                refY: h / 2
                                            });
                                            use = $($("use"), {
                                                "xlink:href": "#" + pathId,
                                                transform: (isEnd ? "rotate(180 " + w / 2 + " " + h / 2 + ") " : E) + "scale(" + w / t + "," + h / t + ")",
                                                "stroke-width": (1 / ((w / t + h / t) / 2)).toFixed(4)
                                            });
                                            marker.appendChild(use);
                                            p.defs.appendChild(marker);
                                            markerCounter[markerId] = 1;
                                        } else {
                                            markerCounter[markerId]++;
                                            use = marker.getElementsByTagName("use")[0];
                                        }
                                        $(use, attr);
                                        var delta = dx * (type != "diamond" && type != "oval");
                                        if (isEnd) {
                                            from = o._.arrows.startdx * stroke || 0;
                                            to = R.getTotalLength(attrs.path) - delta * stroke;
                                        } else {
                                            from = delta * stroke;
                                            to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                                        }
                                        attr = {};
                                        attr["marker-" + se] = "url(#" + markerId + ")";
                                        if (to || from) {
                                            attr.d = R.getSubpath(attrs.path, from, to);
                                        }
                                        $(node, attr);
                                        o._.arrows[se + "Path"] = pathId;
                                        o._.arrows[se + "Marker"] = markerId;
                                        o._.arrows[se + "dx"] = delta;
                                        o._.arrows[se + "Type"] = type;
                                        o._.arrows[se + "String"] = value;
                                    } else {
                                        if (isEnd) {
                                            from = o._.arrows.startdx * stroke || 0;
                                            to = R.getTotalLength(attrs.path) - from;
                                        } else {
                                            from = 0;
                                            to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                                        }
                                        o._.arrows[se + "Path"] && $(node, {d: R.getSubpath(attrs.path, from, to)});
                                        delete o._.arrows[se + "Path"];
                                        delete o._.arrows[se + "Marker"];
                                        delete o._.arrows[se + "dx"];
                                        delete o._.arrows[se + "Type"];
                                        delete o._.arrows[se + "String"];
                                    }
                                    for (attr in markerCounter) if (markerCounter[has](attr) && !markerCounter[attr]) {
                                        var item = R._g.doc.getElementById(attr);
                                        item && item.parentNode.removeChild(item);
                                    }
                                }
                            },
                            dasharray = {
                                "-": [3, 1],
                                ".": [1, 1],
                                "-.": [3, 1, 1, 1],
                                "-..": [3, 1, 1, 1, 1, 1],
                                ". ": [1, 3],
                                "- ": [4, 3],
                                "--": [8, 3],
                                "- .": [4, 3, 1, 3],
                                "--.": [8, 3, 1, 3],
                                "--..": [8, 3, 1, 3, 1, 3]
                            },
                            addDashes = function (o, value, params) {
                                value = dasharray[Str(value).toLowerCase()];
                                if (value) {
                                    var width = o.attrs["stroke-width"] || "1",
                                        butt = {round: width, square: width, butt: 0}[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
                                        dashes = [],
                                        i = value.length;
                                    while (i--) {
                                        dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;
                                    }
                                    $(o.node, {"stroke-dasharray": dashes.join(",")});
                                }
                                else {
                                    $(o.node, {"stroke-dasharray": "none"});
                                }
                            },
                            setFillAndStroke = function (o, params) {
                                var node = o.node,
                                    attrs = o.attrs,
                                    vis = node.style.visibility;
                                node.style.visibility = "hidden";
                                for (var att in params) {
                                    if (params[has](att)) {
                                        if (!R._availableAttrs[has](att)) {
                                            continue;
                                        }
                                        var value = params[att];
                                        attrs[att] = value;
                                        switch (att) {
                                            case "blur":
                                                o.blur(value);
                                                break;
                                            case "title":
                                                var title = node.getElementsByTagName("title");

                                                // Use the existing <title>.
                                                if (title.length && (title = title[0])) {
                                                    title.firstChild.nodeValue = value;
                                                } else {
                                                    title = $("title");
                                                    var val = R._g.doc.createTextNode(value);
                                                    title.appendChild(val);
                                                    node.appendChild(title);
                                                }
                                                break;
                                            case "href":
                                            case "target":
                                                var pn = node.parentNode;
                                                if (pn.tagName.toLowerCase() != "a") {
                                                    var hl = $("a");
                                                    pn.insertBefore(hl, node);
                                                    hl.appendChild(node);
                                                    pn = hl;
                                                }
                                                if (att == "target") {
                                                    pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
                                                } else {
                                                    pn.setAttributeNS(xlink, att, value);
                                                }
                                                break;
                                            case "cursor":
                                                node.style.cursor = value;
                                                break;
                                            case "transform":
                                                o.transform(value);
                                                break;
                                            case "arrow-start":
                                                addArrow(o, value);
                                                break;
                                            case "arrow-end":
                                                addArrow(o, value, 1);
                                                break;
                                            case "clip-rect":
                                                var rect = Str(value).split(separator);
                                                if (rect.length == 4) {
                                                    o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                                                    var el = $("clipPath"),
                                                        rc = $("rect");
                                                    el.id = R.createUUID();
                                                    $(rc, {
                                                        x: rect[0],
                                                        y: rect[1],
                                                        width: rect[2],
                                                        height: rect[3]
                                                    });
                                                    el.appendChild(rc);
                                                    o.paper.defs.appendChild(el);
                                                    $(node, {"clip-path": "url(#" + el.id + ")"});
                                                    o.clip = rc;
                                                }
                                                if (!value) {
                                                    var path = node.getAttribute("clip-path");
                                                    if (path) {
                                                        var clip = R._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                                                        clip && clip.parentNode.removeChild(clip);
                                                        $(node, {"clip-path": E});
                                                        delete o.clip;
                                                    }
                                                }
                                                break;
                                            case "path":
                                                if (o.type == "path") {
                                                    $(node, {d: value ? attrs.path = R._pathToAbsolute(value) : "M0,0"});
                                                    o._.dirty = 1;
                                                    if (o._.arrows) {
                                                        "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                                        "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                                                    }
                                                }
                                                break;
                                            case "width":
                                                node.setAttribute(att, value);
                                                o._.dirty = 1;
                                                if (attrs.fx) {
                                                    att = "x";
                                                    value = attrs.x;
                                                } else {
                                                    break;
                                                }
                                            case "x":
                                                if (attrs.fx) {
                                                    value = -attrs.x - (attrs.width || 0);
                                                }
                                            case "rx":
                                                if (att == "rx" && o.type == "rect") {
                                                    break;
                                                }
                                            case "cx":
                                                node.setAttribute(att, value);
                                                o.pattern && updatePosition(o);
                                                o._.dirty = 1;
                                                break;
                                            case "height":
                                                node.setAttribute(att, value);
                                                o._.dirty = 1;
                                                if (attrs.fy) {
                                                    att = "y";
                                                    value = attrs.y;
                                                } else {
                                                    break;
                                                }
                                            case "y":
                                                if (attrs.fy) {
                                                    value = -attrs.y - (attrs.height || 0);
                                                }
                                            case "ry":
                                                if (att == "ry" && o.type == "rect") {
                                                    break;
                                                }
                                            case "cy":
                                                node.setAttribute(att, value);
                                                o.pattern && updatePosition(o);
                                                o._.dirty = 1;
                                                break;
                                            case "r":
                                                if (o.type == "rect") {
                                                    $(node, {rx: value, ry: value});
                                                } else {
                                                    node.setAttribute(att, value);
                                                }
                                                o._.dirty = 1;
                                                break;
                                            case "src":
                                                if (o.type == "image") {
                                                    node.setAttributeNS(xlink, "href", value);
                                                }
                                                break;
                                            case "stroke-width":
                                                if (o._.sx != 1 || o._.sy != 1) {
                                                    value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                                                }
                                                node.setAttribute(att, value);
                                                if (attrs["stroke-dasharray"]) {
                                                    addDashes(o, attrs["stroke-dasharray"], params);
                                                }
                                                if (o._.arrows) {
                                                    "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                                    "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                                                }
                                                break;
                                            case "stroke-dasharray":
                                                addDashes(o, value, params);
                                                break;
                                            case "fill":
                                                var isURL = Str(value).match(R._ISURL);
                                                if (isURL) {
                                                    el = $("pattern");
                                                    var ig = $("image");
                                                    el.id = R.createUUID();
                                                    $(el, {x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1});
                                                    $(ig, {x: 0, y: 0, "xlink:href": isURL[1]});
                                                    el.appendChild(ig);

                                                    (function (el) {
                                                        R._preload(isURL[1], function () {
                                                            var w = this.offsetWidth,
                                                                h = this.offsetHeight;
                                                            $(el, {width: w, height: h});
                                                            $(ig, {width: w, height: h});
                                                        });
                                                    })(el);
                                                    o.paper.defs.appendChild(el);
                                                    $(node, {fill: "url(#" + el.id + ")"});
                                                    o.pattern = el;
                                                    o.pattern && updatePosition(o);
                                                    break;
                                                }
                                                var clr = R.getRGB(value);
                                                if (!clr.error) {
                                                    delete params.gradient;
                                                    delete attrs.gradient;
                                                    !R.is(attrs.opacity, "undefined") &&
                                                    R.is(params.opacity, "undefined") &&
                                                    $(node, {opacity: attrs.opacity});
                                                    !R.is(attrs["fill-opacity"], "undefined") &&
                                                    R.is(params["fill-opacity"], "undefined") &&
                                                    $(node, {"fill-opacity": attrs["fill-opacity"]});
                                                } else if ((o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value)) {
                                                    if ("opacity" in attrs || "fill-opacity" in attrs) {
                                                        var gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                                        if (gradient) {
                                                            var stops = gradient.getElementsByTagName("stop");
                                                            $(stops[stops.length - 1], {"stop-opacity": ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1)});
                                                        }
                                                    }
                                                    attrs.gradient = value;
                                                    attrs.fill = "none";
                                                    break;
                                                }
                                                clr[has]("opacity") && $(node, {"fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                                            case "stroke":
                                                clr = R.getRGB(value);
                                                node.setAttribute(att, clr.hex);
                                                att == "stroke" && clr[has]("opacity") && $(node, {"stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                                                if (att == "stroke" && o._.arrows) {
                                                    "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                                    "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                                                }
                                                break;
                                            case "gradient":
                                                (o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value);
                                                break;
                                            case "opacity":
                                                if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                                                    $(node, {"stroke-opacity": value > 1 ? value / 100 : value});
                                                }
                                            // fall
                                            case "fill-opacity":
                                                if (attrs.gradient) {
                                                    gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                                    if (gradient) {
                                                        stops = gradient.getElementsByTagName("stop");
                                                        $(stops[stops.length - 1], {"stop-opacity": value});
                                                    }
                                                    break;
                                                }
                                            default:
                                                att == "font-size" && (value = toInt(value, 10) + "px");
                                                var cssrule = att.replace(/(\-.)/g, function (w) {
                                                    return w.substring(1).toUpperCase();
                                                });
                                                node.style[cssrule] = value;
                                                o._.dirty = 1;
                                                node.setAttribute(att, value);
                                                break;
                                        }
                                    }
                                }

                                tuneText(o, params);
                                node.style.visibility = vis;
                            },
                            leading = 1.2,
                            tuneText = function (el, params) {
                                if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
                                    return;
                                }
                                var a = el.attrs,
                                    node = el.node,
                                    fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;

                                if (params[has]("text")) {
                                    a.text = params.text;
                                    while (node.firstChild) {
                                        node.removeChild(node.firstChild);
                                    }
                                    var texts = Str(params.text).split("\n"),
                                        tspans = [],
                                        tspan;
                                    for (var i = 0, ii = texts.length; i < ii; i++) {
                                        tspan = $("tspan");
                                        i && $(tspan, {dy: fontSize * leading, x: a.x});
                                        tspan.appendChild(R._g.doc.createTextNode(texts[i]));
                                        node.appendChild(tspan);
                                        tspans[i] = tspan;
                                    }
                                } else {
                                    tspans = node.getElementsByTagName("tspan");
                                    for (i = 0, ii = tspans.length; i < ii; i++) if (i) {
                                        $(tspans[i], {dy: fontSize * leading, x: a.x});
                                    } else {
                                        $(tspans[0], {dy: 0});
                                    }
                                }
                                $(node, {x: a.x, y: a.y});
                                el._.dirty = 1;
                                var bb = el._getBBox(),
                                    dif = a.y - (bb.y + bb.height / 2);
                                dif && R.is(dif, "finite") && $(tspans[0], {dy: dif});
                            },
                            getRealNode = function (node) {
                                if (node.parentNode && node.parentNode.tagName.toLowerCase() === "a") {
                                    return node.parentNode;
                                } else {
                                    return node;
                                }
                            },
                            Element = function (node, svg) {
                                var X = 0,
                                    Y = 0;
                                /*\
                                 * Element.node
                                 [ property (object) ]
                                 **
                                 * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
                                 **
                                 * Note: Don’t mess with it.
                                 > Usage
                                 | // draw a circle at coordinate 10,10 with radius of 10
                                 | var c = paper.circle(10, 10, 10);
                                 | c.node.onclick = function () {
                                 |     c.attr("fill", "red");
                                 | };
                                 \*/
                                this[0] = this.node = node;
                                /*\
                                 * Element.raphael
                                 [ property (object) ]
                                 **
                                 * Internal reference to @Raphael object. In case it is not available.
                                 > Usage
                                 | Raphael.el.red = function () {
                                 |     var hsb = this.paper.raphael.rgb2hsb(this.attr("fill"));
                                 |     hsb.h = 1;
                                 |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});
                                 | }
                                 \*/
                                node.raphael = true;
                                /*\
                                 * Element.id
                                 [ property (number) ]
                                 **
                                 * Unique id of the element. Especially useful when you want to listen to events of the element,
                                 * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.
                                 \*/
                                this.id = guid();
                                node.raphaelid = this.id;

                                /**
                                 * Method that returns a 5 letter/digit id, enough for 36^5 = 60466176 elements
                                 * @returns {string} id
                                 */
                                function guid() {
                                    return ("0000" + (Math.random()*Math.pow(36,5) << 0).toString(36)).slice(-5);
                                }

                                this.matrix = R.matrix();
                                this.realPath = null;
                                /*\
                                 * Element.paper
                                 [ property (object) ]
                                 **
                                 * Internal reference to “paper” where object drawn. Mainly for use in plugins and element extensions.
                                 > Usage
                                 | Raphael.el.cross = function () {
                                 |     this.attr({fill: "red"});
                                 |     this.paper.path("M10,10L50,50M50,10L10,50")
                                 |         .attr({stroke: "red"});
                                 | }
                                 \*/
                                this.paper = svg;
                                this.attrs = this.attrs || {};
                                this._ = {
                                    transform: [],
                                    sx: 1,
                                    sy: 1,
                                    deg: 0,
                                    dx: 0,
                                    dy: 0,
                                    dirty: 1
                                };
                                !svg.bottom && (svg.bottom = this);
                                /*\
                                 * Element.prev
                                 [ property (object) ]
                                 **
                                 * Reference to the previous element in the hierarchy.
                                 \*/
                                this.prev = svg.top;
                                svg.top && (svg.top.next = this);
                                svg.top = this;
                                /*\
                                 * Element.next
                                 [ property (object) ]
                                 **
                                 * Reference to the next element in the hierarchy.
                                 \*/
                                this.next = null;
                            },
                            elproto = R.el;

                        Element.prototype = elproto;
                        elproto.constructor = Element;

                        R._engine.path = function (pathString, SVG) {
                            var el = $("path");
                            SVG.canvas && SVG.canvas.appendChild(el);
                            var p = new Element(el, SVG);
                            p.type = "path";
                            setFillAndStroke(p, {
                                fill: "none",
                                stroke: "#000",
                                path: pathString
                            });
                            return p;
                        };
                        /*\
                         * Element.rotate
                         [ method ]
                         **
                         * Deprecated! Use @Element.transform instead.
                         * Adds rotation by given angle around given point to the list of
                         * transformations of the element.
                         > Parameters
                         - deg (number) angle in degrees
                         - cx (number) #optional x coordinate of the centre of rotation
                         - cy (number) #optional y coordinate of the centre of rotation
                         * If cx & cy aren’t specified centre of the shape is used as a point of rotation.
                         = (object) @Element
                         \*/
                        elproto.rotate = function (deg, cx, cy) {
                            if (this.removed) {
                                return this;
                            }
                            deg = Str(deg).split(separator);
                            if (deg.length - 1) {
                                cx = toFloat(deg[1]);
                                cy = toFloat(deg[2]);
                            }
                            deg = toFloat(deg[0]);
                            (cy == null) && (cx = cy);
                            if (cx == null || cy == null) {
                                var bbox = this.getBBox(1);
                                cx = bbox.x + bbox.width / 2;
                                cy = bbox.y + bbox.height / 2;
                            }
                            this.transform(this._.transform.concat([["r", deg, cx, cy]]));
                            return this;
                        };
                        /*\
                         * Element.scale
                         [ method ]
                         **
                         * Deprecated! Use @Element.transform instead.
                         * Adds scale by given amount relative to given point to the list of
                         * transformations of the element.
                         > Parameters
                         - sx (number) horisontal scale amount
                         - sy (number) vertical scale amount
                         - cx (number) #optional x coordinate of the centre of scale
                         - cy (number) #optional y coordinate of the centre of scale
                         * If cx & cy aren’t specified centre of the shape is used instead.
                         = (object) @Element
                         \*/
                        elproto.scale = function (sx, sy, cx, cy) {
                            if (this.removed) {
                                return this;
                            }
                            sx = Str(sx).split(separator);
                            if (sx.length - 1) {
                                sy = toFloat(sx[1]);
                                cx = toFloat(sx[2]);
                                cy = toFloat(sx[3]);
                            }
                            sx = toFloat(sx[0]);
                            (sy == null) && (sy = sx);
                            (cy == null) && (cx = cy);
                            if (cx == null || cy == null) {
                                var bbox = this.getBBox(1);
                            }
                            cx = cx == null ? bbox.x + bbox.width / 2 : cx;
                            cy = cy == null ? bbox.y + bbox.height / 2 : cy;
                            this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
                            return this;
                        };
                        /*\
                         * Element.translate
                         [ method ]
                         **
                         * Deprecated! Use @Element.transform instead.
                         * Adds translation by given amount to the list of transformations of the element.
                         > Parameters
                         - dx (number) horisontal shift
                         - dy (number) vertical shift
                         = (object) @Element
                         \*/
                        elproto.translate = function (dx, dy) {
                            if (this.removed) {
                                return this;
                            }
                            dx = Str(dx).split(separator);
                            if (dx.length - 1) {
                                dy = toFloat(dx[1]);
                            }
                            dx = toFloat(dx[0]) || 0;
                            dy = +dy || 0;
                            this.transform(this._.transform.concat([["t", dx, dy]]));
                            return this;
                        };
                        /*\
                         * Element.transform
                         [ method ]
                         **
                         * Adds transformation to the element which is separate to other attributes,
                         * i.e. translation doesn’t change `x` or `y` of the rectange. The format
                         * of transformation string is similar to the path string syntax:
                         | "t100,100r30,100,100s2,2,100,100r45s1.5"
                         * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for
                         * scale and `m` is for matrix.
                         *
                         * There are also alternative “absolute” translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.
                         *
                         * So, the example line above could be read like “translate by 100, 100; rotate 30° around 100, 100; scale twice around 100, 100;
                         * rotate 45° around centre; scale 1.5 times relative to centre”. As you can see rotate and scale commands have origin
                         * coordinates as optional parameters, the default is the centre point of the element.
                         * Matrix accepts six parameters.
                         > Usage
                         | var el = paper.rect(10, 20, 300, 200);
                         | // translate 100, 100, rotate 45°, translate -100, 0
                         | el.transform("t100,100r45t-100,0");
                         | // if you want you can append or prepend transformations
                         | el.transform("...t50,50");
                         | el.transform("s2...");
                         | // or even wrap
                         | el.transform("t50,50...t-50-50");
                         | // to reset transformation call method with empty string
                         | el.transform("");
                         | // to get current value call it without parameters
                         | console.log(el.transform());
                         > Parameters
                         - tstr (string) #optional transformation string
                         * If tstr isn’t specified
                         = (string) current transformation string
                         * else
                         = (object) @Element
                         \*/
                        elproto.transform = function (tstr) {
                            var _ = this._;
                            if (tstr == null) {
                                return _.transform;
                            }
                            R._extractTransform(this, tstr);

                            this.clip && $(this.clip, {transform: this.matrix.invert()});
                            this.pattern && updatePosition(this);
                            this.node && $(this.node, {transform: this.matrix});

                            if (_.sx != 1 || _.sy != 1) {
                                var sw = this.attrs[has]("stroke-width") ? this.attrs["stroke-width"] : 1;
                                this.attr({"stroke-width": sw});
                            }

                            return this;
                        };
                        /*\
                         * Element.hide
                         [ method ]
                         **
                         * Makes element invisible. See @Element.show.
                         = (object) @Element
                         \*/
                        elproto.hide = function () {
                            if(!this.removed) this.node.style.display = "none";
                            return this;
                        };
                        /*\
                         * Element.show
                         [ method ]
                         **
                         * Makes element visible. See @Element.hide.
                         = (object) @Element
                         \*/
                        elproto.show = function () {
                            if(!this.removed) this.node.style.display = "";
                            return this;
                        };
                        /*\
                         * Element.remove
                         [ method ]
                         **
                         * Removes element from the paper.
                         \*/
                        elproto.remove = function () {
                            var node = getRealNode(this.node);
                            if (this.removed || !node.parentNode) {
                                return;
                            }
                            var paper = this.paper;
                            paper.__set__ && paper.__set__.exclude(this);
                            eve.unbind("raphael.*.*." + this.id);
                            if (this.gradient) {
                                paper.defs.removeChild(this.gradient);
                            }
                            R._tear(this, paper);

                            node.parentNode.removeChild(node);

                            // Remove custom data for element
                            this.removeData();

                            for (var i in this) {
                                this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
                            }
                            this.removed = true;
                        };
                        elproto._getBBox = function () {
                            if (this.node.style.display == "none") {
                                this.show();
                                var hide = true;
                            }
                            var canvasHidden = false,
                                containerStyle;
                            if (this.paper.canvas.parentElement) {
                                containerStyle = this.paper.canvas.parentElement.style;
                            } //IE10+ can't find parentElement
                            else if (this.paper.canvas.parentNode) {
                                containerStyle = this.paper.canvas.parentNode.style;
                            }

                            if(containerStyle && containerStyle.display == "none") {
                                canvasHidden = true;
                                containerStyle.display = "";
                            }
                            var bbox = {};
                            try {
                                bbox = this.node.getBBox();
                            } catch(e) {
                                // Firefox 3.0.x, 25.0.1 (probably more versions affected) play badly here - possible fix
                                bbox = {
                                    x: this.node.clientLeft,
                                    y: this.node.clientTop,
                                    width: this.node.clientWidth,
                                    height: this.node.clientHeight
                                }
                            } finally {
                                bbox = bbox || {};
                                if(canvasHidden){
                                    containerStyle.display = "none";
                                }
                            }
                            hide && this.hide();
                            return bbox;
                        };
                        /*\
                         * Element.attr
                         [ method ]
                         **
                         * Sets the attributes of the element.
                         > Parameters
                         - attrName (string) attribute’s name
                         - value (string) value
                         * or
                         - params (object) object of name/value pairs
                         * or
                         - attrName (string) attribute’s name
                         * or
                         - attrNames (array) in this case method returns array of current values for given attribute names
                         = (object) @Element if attrsName & value or params are passed in.
                         = (...) value of the attribute if only attrsName is passed in.
                         = (array) array of values of the attribute if attrsNames is passed in.
                         = (object) object of attributes if nothing is passed in.
                         > Possible parameters
                         # <p>Please refer to the <a href="http://www.w3.org/TR/SVG/" title="The W3C Recommendation for the SVG language describes these properties in detail.">SVG specification</a> for an explanation of these parameters.</p>
                         o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.
                         o clip-rect (string) comma or space separated values: x, y, width and height
                         o cursor (string) CSS type of the cursor
                         o cx (number) the x-axis coordinate of the center of the circle, or ellipse
                         o cy (number) the y-axis coordinate of the center of the circle, or ellipse
                         o fill (string) colour, gradient or image
                         o fill-opacity (number)
                         o font (string)
                         o font-family (string)
                         o font-size (number) font size in pixels
                         o font-weight (string)
                         o height (number)
                         o href (string) URL, if specified element behaves as hyperlink
                         o opacity (number)
                         o path (string) SVG path string format
                         o r (number) radius of the circle, ellipse or rounded corner on the rect
                         o rx (number) horisontal radius of the ellipse
                         o ry (number) vertical radius of the ellipse
                         o src (string) image URL, only works for @Element.image element
                         o stroke (string) stroke colour
                         o stroke-dasharray (string) [“”, “none”, “`-`”, “`.`”, “`-.`”, “`-..`”, “`. `”, “`- `”, “`--`”, “`- .`”, “`--.`”, “`--..`”]
                         o stroke-linecap (string) [“`butt`”, “`square`”, “`round`”]
                         o stroke-linejoin (string) [“`bevel`”, “`round`”, “`miter`”]
                         o stroke-miterlimit (number)
                         o stroke-opacity (number)
                         o stroke-width (number) stroke width in pixels, default is '1'
                         o target (string) used with href
                         o text (string) contents of the text element. Use `\n` for multiline text
                         o text-anchor (string) [“`start`”, “`middle`”, “`end`”], default is “`middle`”
                         o title (string) will create tooltip with a given text
                         o transform (string) see @Element.transform
                         o width (number)
                         o x (number)
                         o y (number)
                         > Gradients
                         * Linear gradient format: “`‹angle›-‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`90-#fff-#000`” – 90°
                         * gradient from white to black or “`0-#fff-#f00:20-#000`” – 0° gradient from white via red (at 20%) to black.
                         *
                         * radial gradient: “`r[(‹fx›, ‹fy›)]‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`r#fff-#000`” –
                         * gradient from white to black or “`r(0.25, 0.75)#fff-#000`” – gradient from white to black with focus point
                         * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.
                         > Path String
                         # <p>Please refer to <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path’s data attribute’s format are described in the SVG specification.">SVG documentation regarding path string</a>. Raphaël fully supports it.</p>
                         > Colour Parsing
                         # <ul>
                         #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>
                         #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>
                         #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>
                         #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>
                         #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>
                         #     <li>rgba(•••, •••, •••, •••) — red, green and blue channels’ values: (“<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>”)</li>
                         #     <li>rgba(•••%, •••%, •••%, •••%) — same as above, but in %: (“<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>”)</li>
                         #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>
                         #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
                         #     <li>hsba(•••, •••, •••, •••) — same as above, but with opacity</li>
                         #     <li>hsl(•••, •••, •••) — almost the same as hsb, see <a href="http://en.wikipedia.org/wiki/HSL_and_HSV" title="HSL and HSV - Wikipedia, the free encyclopedia">Wikipedia page</a></li>
                         #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>
                         #     <li>hsla(•••, •••, •••, •••) — same as above, but with opacity</li>
                         #     <li>Optionally for hsb and hsl you could specify hue as a degree: “<code>hsl(240deg,&nbsp;1,&nbsp;.5)</code>” or, if you want to go fancy, “<code>hsl(240°,&nbsp;1,&nbsp;.5)</code>”</li>
                         # </ul>
                         \*/
                        elproto.attr = function (name, value) {
                            if (this.removed) {
                                return this;
                            }
                            if (name == null) {
                                var res = {};
                                for (var a in this.attrs) if (this.attrs[has](a)) {
                                    res[a] = this.attrs[a];
                                }
                                res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
                                res.transform = this._.transform;
                                return res;
                            }
                            if (value == null && R.is(name, "string")) {
                                if (name == "fill" && this.attrs.fill == "none" && this.attrs.gradient) {
                                    return this.attrs.gradient;
                                }
                                if (name == "transform") {
                                    return this._.transform;
                                }
                                var names = name.split(separator),
                                    out = {};
                                for (var i = 0, ii = names.length; i < ii; i++) {
                                    name = names[i];
                                    if (name in this.attrs) {
                                        out[name] = this.attrs[name];
                                    } else if (R.is(this.paper.customAttributes[name], "function")) {
                                        out[name] = this.paper.customAttributes[name].def;
                                    } else {
                                        out[name] = R._availableAttrs[name];
                                    }
                                }
                                return ii - 1 ? out : out[names[0]];
                            }
                            if (value == null && R.is(name, "array")) {
                                out = {};
                                for (i = 0, ii = name.length; i < ii; i++) {
                                    out[name[i]] = this.attr(name[i]);
                                }
                                return out;
                            }
                            if (value != null) {
                                var params = {};
                                params[name] = value;
                            } else if (name != null && R.is(name, "object")) {
                                params = name;
                            }
                            for (var key in params) {
                                eve("raphael.attr." + key + "." + this.id, this, params[key]);
                            }
                            for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
                                var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
                                this.attrs[key] = params[key];
                                for (var subkey in par) if (par[has](subkey)) {
                                    params[subkey] = par[subkey];
                                }
                            }
                            setFillAndStroke(this, params);
                            return this;
                        };
                        /*\
                         * Element.toFront
                         [ method ]
                         **
                         * Moves the element so it is the closest to the viewer’s eyes, on top of other elements.
                         = (object) @Element
                         \*/
                        elproto.toFront = function () {
                            if (this.removed) {
                                return this;
                            }
                            var node = getRealNode(this.node);
                            node.parentNode.appendChild(node);
                            var svg = this.paper;
                            svg.top != this && R._tofront(this, svg);
                            return this;
                        };
                        /*\
                         * Element.toBack
                         [ method ]
                         **
                         * Moves the element so it is the furthest from the viewer’s eyes, behind other elements.
                         = (object) @Element
                         \*/
                        elproto.toBack = function () {
                            if (this.removed) {
                                return this;
                            }
                            var node = getRealNode(this.node);
                            var parentNode = node.parentNode;
                            parentNode.insertBefore(node, parentNode.firstChild);
                            R._toback(this, this.paper);
                            var svg = this.paper;
                            return this;
                        };
                        /*\
                         * Element.insertAfter
                         [ method ]
                         **
                         * Inserts current object after the given one.
                         = (object) @Element
                         \*/
                        elproto.insertAfter = function (element) {
                            if (this.removed || !element) {
                                return this;
                            }

                            var node = getRealNode(this.node);
                            var afterNode = getRealNode(element.node || element[element.length - 1].node);
                            if (afterNode.nextSibling) {
                                afterNode.parentNode.insertBefore(node, afterNode.nextSibling);
                            } else {
                                afterNode.parentNode.appendChild(node);
                            }
                            R._insertafter(this, element, this.paper);
                            return this;
                        };
                        /*\
                         * Element.insertBefore
                         [ method ]
                         **
                         * Inserts current object before the given one.
                         = (object) @Element
                         \*/
                        elproto.insertBefore = function (element) {
                            if (this.removed || !element) {
                                return this;
                            }

                            var node = getRealNode(this.node);
                            var beforeNode = getRealNode(element.node || element[0].node);
                            beforeNode.parentNode.insertBefore(node, beforeNode);
                            R._insertbefore(this, element, this.paper);
                            return this;
                        };
                        elproto.blur = function (size) {
                            // Experimental. No Safari support. Use it on your own risk.
                            var t = this;
                            if (+size !== 0) {
                                var fltr = $("filter"),
                                    blur = $("feGaussianBlur");
                                t.attrs.blur = size;
                                fltr.id = R.createUUID();
                                $(blur, {stdDeviation: +size || 1.5});
                                fltr.appendChild(blur);
                                t.paper.defs.appendChild(fltr);
                                t._blur = fltr;
                                $(t.node, {filter: "url(#" + fltr.id + ")"});
                            } else {
                                if (t._blur) {
                                    t._blur.parentNode.removeChild(t._blur);
                                    delete t._blur;
                                    delete t.attrs.blur;
                                }
                                t.node.removeAttribute("filter");
                            }
                            return t;
                        };
                        R._engine.circle = function (svg, x, y, r) {
                            var el = $("circle");
                            svg.canvas && svg.canvas.appendChild(el);
                            var res = new Element(el, svg);
                            res.attrs = {cx: x, cy: y, r: r, fill: "none", stroke: "#000"};
                            res.type = "circle";
                            $(el, res.attrs);
                            return res;
                        };
                        R._engine.rect = function (svg, x, y, w, h, r) {
                            var el = $("rect");
                            svg.canvas && svg.canvas.appendChild(el);
                            var res = new Element(el, svg);
                            res.attrs = {x: x, y: y, width: w, height: h, rx: r || 0, ry: r || 0, fill: "none", stroke: "#000"};
                            res.type = "rect";
                            $(el, res.attrs);
                            return res;
                        };
                        R._engine.ellipse = function (svg, x, y, rx, ry) {
                            var el = $("ellipse");
                            svg.canvas && svg.canvas.appendChild(el);
                            var res = new Element(el, svg);
                            res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: "none", stroke: "#000"};
                            res.type = "ellipse";
                            $(el, res.attrs);
                            return res;
                        };
                        R._engine.image = function (svg, src, x, y, w, h) {
                            var el = $("image");
                            $(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: "none"});
                            el.setAttributeNS(xlink, "href", src);
                            svg.canvas && svg.canvas.appendChild(el);
                            var res = new Element(el, svg);
                            res.attrs = {x: x, y: y, width: w, height: h, src: src};
                            res.type = "image";
                            return res;
                        };
                        R._engine.text = function (svg, x, y, text) {
                            var el = $("text");
                            svg.canvas && svg.canvas.appendChild(el);
                            var res = new Element(el, svg);
                            res.attrs = {
                                x: x,
                                y: y,
                                "text-anchor": "middle",
                                text: text,
                                "font-family": R._availableAttrs["font-family"],
                                "font-size": R._availableAttrs["font-size"],
                                stroke: "none",
                                fill: "#000"
                            };
                            res.type = "text";
                            setFillAndStroke(res, res.attrs);
                            return res;
                        };
                        R._engine.setSize = function (width, height) {
                            this.width = width || this.width;
                            this.height = height || this.height;
                            this.canvas.setAttribute("width", this.width);
                            this.canvas.setAttribute("height", this.height);
                            if (this._viewBox) {
                                this.setViewBox.apply(this, this._viewBox);
                            }
                            return this;
                        };
                        R._engine.create = function () {
                            var con = R._getContainer.apply(0, arguments),
                                container = con && con.container,
                                x = con.x,
                                y = con.y,
                                width = con.width,
                                height = con.height;
                            if (!container) {
                                throw new Error("SVG container not found.");
                            }
                            var cnvs = $("svg"),
                                css = "overflow:hidden;",
                                isFloating;
                            x = x || 0;
                            y = y || 0;
                            width = width || 512;
                            height = height || 342;
                            $(cnvs, {
                                height: height,
                                version: 1.1,
                                width: width,
                                xmlns: "http://www.w3.org/2000/svg",
                                "xmlns:xlink": "http://www.w3.org/1999/xlink"
                            });
                            if (container == 1) {
                                cnvs.style.cssText = css + "position:absolute;left:" + x + "px;top:" + y + "px";
                                R._g.doc.body.appendChild(cnvs);
                                isFloating = 1;
                            } else {
                                cnvs.style.cssText = css + "position:relative";
                                if (container.firstChild) {
                                    container.insertBefore(cnvs, container.firstChild);
                                } else {
                                    container.appendChild(cnvs);
                                }
                            }
                            container = new R._Paper;
                            container.width = width;
                            container.height = height;
                            container.canvas = cnvs;
                            container.clear();
                            container._left = container._top = 0;
                            isFloating && (container.renderfix = function () {});
                            container.renderfix();
                            return container;
                        };
                        R._engine.setViewBox = function (x, y, w, h, fit) {
                            eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
                            var paperSize = this.getSize(),
                                size = mmax(w / paperSize.width, h / paperSize.height),
                                top = this.top,
                                aspectRatio = fit ? "xMidYMid meet" : "xMinYMin",
                                vb,
                                sw;
                            if (x == null) {
                                if (this._vbSize) {
                                    size = 1;
                                }
                                delete this._vbSize;
                                vb = "0 0 " + this.width + S + this.height;
                            } else {
                                this._vbSize = size;
                                vb = x + S + y + S + w + S + h;
                            }
                            $(this.canvas, {
                                viewBox: vb,
                                preserveAspectRatio: aspectRatio
                            });
                            while (size && top) {
                                sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
                                top.attr({"stroke-width": sw});
                                top._.dirty = 1;
                                top._.dirtyT = 1;
                                top = top.prev;
                            }
                            this._viewBox = [x, y, w, h, !!fit];
                            return this;
                        };
                        /*\
                         * Paper.renderfix
                         [ method ]
                         **
                         * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependent
                         * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.
                         * This method fixes the issue.
                         **
                         Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.
                         \*/
                        R.prototype.renderfix = function () {
                            var cnvs = this.canvas,
                                s = cnvs.style,
                                pos;
                            try {
                                pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
                            } catch (e) {
                                pos = cnvs.createSVGMatrix();
                            }
                            var left = -pos.e % 1,
                                top = -pos.f % 1;
                            if (left || top) {
                                if (left) {
                                    this._left = (this._left + left) % 1;
                                    s.left = this._left + "px";
                                }
                                if (top) {
                                    this._top = (this._top + top) % 1;
                                    s.top = this._top + "px";
                                }
                            }
                        };
                        /*\
                         * Paper.clear
                         [ method ]
                         **
                         * Clears the paper, i.e. removes all the elements.
                         \*/
                        R.prototype.clear = function () {
                            R.eve("raphael.clear", this);
                            var c = this.canvas;
                            while (c.firstChild) {
                                c.removeChild(c.firstChild);
                            }
                            this.bottom = this.top = null;
                            (this.desc = $("desc")).appendChild(R._g.doc.createTextNode("Created with Rapha\xebl " + R.version));
                            c.appendChild(this.desc);
                            c.appendChild(this.defs = $("defs"));
                        };
                        /*\
                         * Paper.remove
                         [ method ]
                         **
                         * Removes the paper from the DOM.
                         \*/
                        R.prototype.remove = function () {
                            eve("raphael.remove", this);
                            this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
                            for (var i in this) {
                                this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
                            }
                        };
                        var setproto = R.st;
                        for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
                            setproto[method] = (function (methodname) {
                                return function () {
                                    var arg = arguments;
                                    return this.forEach(function (el) {
                                        el[methodname].apply(el, arg);
                                    });
                                };
                            })(method);
                        }
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


                    /***/ },
                /* 4 */
                /***/ function(module, exports, __webpack_require__) {

                    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function(R) {
                        if (R && !R.vml) {
                            return;
                        }

                        var has = "hasOwnProperty",
                            Str = String,
                            toFloat = parseFloat,
                            math = Math,
                            round = math.round,
                            mmax = math.max,
                            mmin = math.min,
                            abs = math.abs,
                            fillString = "fill",
                            separator = /[, ]+/,
                            eve = R.eve,
                            ms = " progid:DXImageTransform.Microsoft",
                            S = " ",
                            E = "",
                            map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"},
                            bites = /([clmz]),?([^clmz]*)/gi,
                            blurregexp = / progid:\S+Blur\([^\)]+\)/g,
                            val = /-?[^,\s-]+/g,
                            cssDot = "position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)",
                            zoom = 21600,
                            pathTypes = {path: 1, rect: 1, image: 1},
                            ovalTypes = {circle: 1, ellipse: 1},
                            path2vml = function (path) {
                                var total =  /[ahqstv]/ig,
                                    command = R._pathToAbsolute;
                                Str(path).match(total) && (command = R._path2curve);
                                total = /[clmz]/g;
                                if (command == R._pathToAbsolute && !Str(path).match(total)) {
                                    var res = Str(path).replace(bites, function (all, command, args) {
                                        var vals = [],
                                            isMove = command.toLowerCase() == "m",
                                            res = map[command];
                                        args.replace(val, function (value) {
                                            if (isMove && vals.length == 2) {
                                                res += vals + map[command == "m" ? "l" : "L"];
                                                vals = [];
                                            }
                                            vals.push(round(value * zoom));
                                        });
                                        return res + vals;
                                    });
                                    return res;
                                }
                                var pa = command(path), p, r;
                                res = [];
                                for (var i = 0, ii = pa.length; i < ii; i++) {
                                    p = pa[i];
                                    r = pa[i][0].toLowerCase();
                                    r == "z" && (r = "x");
                                    for (var j = 1, jj = p.length; j < jj; j++) {
                                        r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
                                    }
                                    res.push(r);
                                }
                                return res.join(S);
                            },
                            compensation = function (deg, dx, dy) {
                                var m = R.matrix();
                                m.rotate(-deg, .5, .5);
                                return {
                                    dx: m.x(dx, dy),
                                    dy: m.y(dx, dy)
                                };
                            },
                            setCoords = function (p, sx, sy, dx, dy, deg) {
                                var _ = p._,
                                    m = p.matrix,
                                    fillpos = _.fillpos,
                                    o = p.node,
                                    s = o.style,
                                    y = 1,
                                    flip = "",
                                    dxdy,
                                    kx = zoom / sx,
                                    ky = zoom / sy;
                                s.visibility = "hidden";
                                if (!sx || !sy) {
                                    return;
                                }
                                o.coordsize = abs(kx) + S + abs(ky);
                                s.rotation = deg * (sx * sy < 0 ? -1 : 1);
                                if (deg) {
                                    var c = compensation(deg, dx, dy);
                                    dx = c.dx;
                                    dy = c.dy;
                                }
                                sx < 0 && (flip += "x");
                                sy < 0 && (flip += " y") && (y = -1);
                                s.flip = flip;
                                o.coordorigin = (dx * -kx) + S + (dy * -ky);
                                if (fillpos || _.fillsize) {
                                    var fill = o.getElementsByTagName(fillString);
                                    fill = fill && fill[0];
                                    o.removeChild(fill);
                                    if (fillpos) {
                                        c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));
                                        fill.position = c.dx * y + S + c.dy * y;
                                    }
                                    if (_.fillsize) {
                                        fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);
                                    }
                                    o.appendChild(fill);
                                }
                                s.visibility = "visible";
                            };
                        R.toString = function () {
                            return  "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
                        };
                        var addArrow = function (o, value, isEnd) {
                                var values = Str(value).toLowerCase().split("-"),
                                    se = isEnd ? "end" : "start",
                                    i = values.length,
                                    type = "classic",
                                    w = "medium",
                                    h = "medium";
                                while (i--) {
                                    switch (values[i]) {
                                        case "block":
                                        case "classic":
                                        case "oval":
                                        case "diamond":
                                        case "open":
                                        case "none":
                                            type = values[i];
                                            break;
                                        case "wide":
                                        case "narrow": h = values[i]; break;
                                        case "long":
                                        case "short": w = values[i]; break;
                                    }
                                }
                                var stroke = o.node.getElementsByTagName("stroke")[0];
                                stroke[se + "arrow"] = type;
                                stroke[se + "arrowlength"] = w;
                                stroke[se + "arrowwidth"] = h;
                            },
                            setFillAndStroke = function (o, params) {
                                // o.paper.canvas.style.display = "none";
                                o.attrs = o.attrs || {};
                                var node = o.node,
                                    a = o.attrs,
                                    s = node.style,
                                    xy,
                                    newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),
                                    isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),
                                    res = o;


                                for (var par in params) if (params[has](par)) {
                                    a[par] = params[par];
                                }
                                if (newpath) {
                                    a.path = R._getPath[o.type](o);
                                    o._.dirty = 1;
                                }
                                params.href && (node.href = params.href);
                                params.title && (node.title = params.title);
                                params.target && (node.target = params.target);
                                params.cursor && (s.cursor = params.cursor);
                                "blur" in params && o.blur(params.blur);
                                if (params.path && o.type == "path" || newpath) {
                                    node.path = path2vml(~Str(a.path).toLowerCase().indexOf("r") ? R._pathToAbsolute(a.path) : a.path);
                                    o._.dirty = 1;
                                    if (o.type == "image") {
                                        o._.fillpos = [a.x, a.y];
                                        o._.fillsize = [a.width, a.height];
                                        setCoords(o, 1, 1, 0, 0, 0);
                                    }
                                }
                                "transform" in params && o.transform(params.transform);
                                if (isOval) {
                                    var cx = +a.cx,
                                        cy = +a.cy,
                                        rx = +a.rx || +a.r || 0,
                                        ry = +a.ry || +a.r || 0;
                                    node.path = R.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
                                    o._.dirty = 1;
                                }
                                if ("clip-rect" in params) {
                                    var rect = Str(params["clip-rect"]).split(separator);
                                    if (rect.length == 4) {
                                        rect[2] = +rect[2] + (+rect[0]);
                                        rect[3] = +rect[3] + (+rect[1]);
                                        var div = node.clipRect || R._g.doc.createElement("div"),
                                            dstyle = div.style;
                                        dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
                                        if (!node.clipRect) {
                                            dstyle.position = "absolute";
                                            dstyle.top = 0;
                                            dstyle.left = 0;
                                            dstyle.width = o.paper.width + "px";
                                            dstyle.height = o.paper.height + "px";
                                            node.parentNode.insertBefore(div, node);
                                            div.appendChild(node);
                                            node.clipRect = div;
                                        }
                                    }
                                    if (!params["clip-rect"]) {
                                        node.clipRect && (node.clipRect.style.clip = "auto");
                                    }
                                }
                                if (o.textpath) {
                                    var textpathStyle = o.textpath.style;
                                    params.font && (textpathStyle.font = params.font);
                                    params["font-family"] && (textpathStyle.fontFamily = '"' + params["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, E) + '"');
                                    params["font-size"] && (textpathStyle.fontSize = params["font-size"]);
                                    params["font-weight"] && (textpathStyle.fontWeight = params["font-weight"]);
                                    params["font-style"] && (textpathStyle.fontStyle = params["font-style"]);
                                }
                                if ("arrow-start" in params) {
                                    addArrow(res, params["arrow-start"]);
                                }
                                if ("arrow-end" in params) {
                                    addArrow(res, params["arrow-end"], 1);
                                }
                                if (params.opacity != null ||
                                    params.fill != null ||
                                    params.src != null ||
                                    params.stroke != null ||
                                    params["stroke-width"] != null ||
                                    params["stroke-opacity"] != null ||
                                    params["fill-opacity"] != null ||
                                    params["stroke-dasharray"] != null ||
                                    params["stroke-miterlimit"] != null ||
                                    params["stroke-linejoin"] != null ||
                                    params["stroke-linecap"] != null) {
                                    var fill = node.getElementsByTagName(fillString),
                                        newfill = false;
                                    fill = fill && fill[0];
                                    !fill && (newfill = fill = createNode(fillString));
                                    if (o.type == "image" && params.src) {
                                        fill.src = params.src;
                                    }
                                    params.fill && (fill.on = true);
                                    if (fill.on == null || params.fill == "none" || params.fill === null) {
                                        fill.on = false;
                                    }
                                    if (fill.on && params.fill) {
                                        var isURL = Str(params.fill).match(R._ISURL);
                                        if (isURL) {
                                            fill.parentNode == node && node.removeChild(fill);
                                            fill.rotate = true;
                                            fill.src = isURL[1];
                                            fill.type = "tile";
                                            var bbox = o.getBBox(1);
                                            fill.position = bbox.x + S + bbox.y;
                                            o._.fillpos = [bbox.x, bbox.y];

                                            R._preload(isURL[1], function () {
                                                o._.fillsize = [this.offsetWidth, this.offsetHeight];
                                            });
                                        } else {
                                            fill.color = R.getRGB(params.fill).hex;
                                            fill.src = E;
                                            fill.type = "solid";
                                            if (R.getRGB(params.fill).error && (res.type in {circle: 1, ellipse: 1} || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill, fill)) {
                                                a.fill = "none";
                                                a.gradient = params.fill;
                                                fill.rotate = false;
                                            }
                                        }
                                    }
                                    if ("fill-opacity" in params || "opacity" in params) {
                                        var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
                                        opacity = mmin(mmax(opacity, 0), 1);
                                        fill.opacity = opacity;
                                        if (fill.src) {
                                            fill.color = "none";
                                        }
                                    }
                                    node.appendChild(fill);
                                    var stroke = (node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0]),
                                        newstroke = false;
                                    !stroke && (newstroke = stroke = createNode("stroke"));
                                    if ((params.stroke && params.stroke != "none") ||
                                        params["stroke-width"] ||
                                        params["stroke-opacity"] != null ||
                                        params["stroke-dasharray"] ||
                                        params["stroke-miterlimit"] ||
                                        params["stroke-linejoin"] ||
                                        params["stroke-linecap"]) {
                                        stroke.on = true;
                                    }
                                    (params.stroke == "none" || params.stroke === null || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
                                    var strokeColor = R.getRGB(params.stroke);
                                    stroke.on && params.stroke && (stroke.color = strokeColor.hex);
                                    opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
                                    var width = (toFloat(params["stroke-width"]) || 1) * .75;
                                    opacity = mmin(mmax(opacity, 0), 1);
                                    params["stroke-width"] == null && (width = a["stroke-width"]);
                                    params["stroke-width"] && (stroke.weight = width);
                                    width && width < 1 && (opacity *= width) && (stroke.weight = 1);
                                    stroke.opacity = opacity;

                                    params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
                                    stroke.miterlimit = params["stroke-miterlimit"] || 8;
                                    params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
                                    if ("stroke-dasharray" in params) {
                                        var dasharray = {
                                            "-": "shortdash",
                                            ".": "shortdot",
                                            "-.": "shortdashdot",
                                            "-..": "shortdashdotdot",
                                            ". ": "dot",
                                            "- ": "dash",
                                            "--": "longdash",
                                            "- .": "dashdot",
                                            "--.": "longdashdot",
                                            "--..": "longdashdotdot"
                                        };
                                        stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
                                    }
                                    newstroke && node.appendChild(stroke);
                                }
                                if (res.type == "text") {
                                    res.paper.canvas.style.display = E;
                                    var span = res.paper.span,
                                        m = 100,
                                        fontSize = a.font && a.font.match(/\d+(?:\.\d*)?(?=px)/);
                                    s = span.style;
                                    a.font && (s.font = a.font);
                                    a["font-family"] && (s.fontFamily = a["font-family"]);
                                    a["font-weight"] && (s.fontWeight = a["font-weight"]);
                                    a["font-style"] && (s.fontStyle = a["font-style"]);
                                    fontSize = toFloat(a["font-size"] || fontSize && fontSize[0]) || 10;
                                    s.fontSize = fontSize * m + "px";
                                    res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>"));
                                    var brect = span.getBoundingClientRect();
                                    res.W = a.w = (brect.right - brect.left) / m;
                                    res.H = a.h = (brect.bottom - brect.top) / m;
                                    // res.paper.canvas.style.display = "none";
                                    res.X = a.x;
                                    res.Y = a.y + res.H / 2;

                                    ("x" in params || "y" in params) && (res.path.v = R.format("m{0},{1}l{2},{1}", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));
                                    var dirtyattrs = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size"];
                                    for (var d = 0, dd = dirtyattrs.length; d < dd; d++) if (dirtyattrs[d] in params) {
                                        res._.dirty = 1;
                                        break;
                                    }

                                    // text-anchor emulation
                                    switch (a["text-anchor"]) {
                                        case "start":
                                            res.textpath.style["v-text-align"] = "left";
                                            res.bbx = res.W / 2;
                                            break;
                                        case "end":
                                            res.textpath.style["v-text-align"] = "right";
                                            res.bbx = -res.W / 2;
                                            break;
                                        default:
                                            res.textpath.style["v-text-align"] = "center";
                                            res.bbx = 0;
                                            break;
                                    }
                                    res.textpath.style["v-text-kern"] = true;
                                }
                                // res.paper.canvas.style.display = E;
                            },
                            addGradientFill = function (o, gradient, fill) {
                                o.attrs = o.attrs || {};
                                var attrs = o.attrs,
                                    pow = Math.pow,
                                    opacity,
                                    oindex,
                                    type = "linear",
                                    fxfy = ".5 .5";
                                o.attrs.gradient = gradient;
                                gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {
                                    type = "radial";
                                    if (fx && fy) {
                                        fx = toFloat(fx);
                                        fy = toFloat(fy);
                                        pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
                                        fxfy = fx + S + fy;
                                    }
                                    return E;
                                });
                                gradient = gradient.split(/\s*\-\s*/);
                                if (type == "linear") {
                                    var angle = gradient.shift();
                                    angle = -toFloat(angle);
                                    if (isNaN(angle)) {
                                        return null;
                                    }
                                }
                                var dots = R._parseDots(gradient);
                                if (!dots) {
                                    return null;
                                }
                                o = o.shape || o.node;
                                if (dots.length) {
                                    o.removeChild(fill);
                                    fill.on = true;
                                    fill.method = "none";
                                    fill.color = dots[0].color;
                                    fill.color2 = dots[dots.length - 1].color;
                                    var clrs = [];
                                    for (var i = 0, ii = dots.length; i < ii; i++) {
                                        dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);
                                    }
                                    fill.colors = clrs.length ? clrs.join() : "0% " + fill.color;
                                    if (type == "radial") {
                                        fill.type = "gradientTitle";
                                        fill.focus = "100%";
                                        fill.focussize = "0 0";
                                        fill.focusposition = fxfy;
                                        fill.angle = 0;
                                    } else {
                                        // fill.rotate= true;
                                        fill.type = "gradient";
                                        fill.angle = (270 - angle) % 360;
                                    }
                                    o.appendChild(fill);
                                }
                                return 1;
                            },
                            Element = function (node, vml) {
                                this[0] = this.node = node;
                                node.raphael = true;
                                this.id = R._oid++;
                                node.raphaelid = this.id;
                                this.X = 0;
                                this.Y = 0;
                                this.attrs = {};
                                this.paper = vml;
                                this.matrix = R.matrix();
                                this._ = {
                                    transform: [],
                                    sx: 1,
                                    sy: 1,
                                    dx: 0,
                                    dy: 0,
                                    deg: 0,
                                    dirty: 1,
                                    dirtyT: 1
                                };
                                !vml.bottom && (vml.bottom = this);
                                this.prev = vml.top;
                                vml.top && (vml.top.next = this);
                                vml.top = this;
                                this.next = null;
                            };
                        var elproto = R.el;

                        Element.prototype = elproto;
                        elproto.constructor = Element;
                        elproto.transform = function (tstr) {
                            if (tstr == null) {
                                return this._.transform;
                            }
                            var vbs = this.paper._viewBoxShift,
                                vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
                                oldt;
                            if (vbs) {
                                oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, this._.transform || E);
                            }
                            R._extractTransform(this, vbt + tstr);
                            var matrix = this.matrix.clone(),
                                skew = this.skew,
                                o = this.node,
                                split,
                                isGrad = ~Str(this.attrs.fill).indexOf("-"),
                                isPatt = !Str(this.attrs.fill).indexOf("url(");
                            matrix.translate(1, 1);
                            if (isPatt || isGrad || this.type == "image") {
                                skew.matrix = "1 0 0 1";
                                skew.offset = "0 0";
                                split = matrix.split();
                                if ((isGrad && split.noRotation) || !split.isSimple) {
                                    o.style.filter = matrix.toFilter();
                                    var bb = this.getBBox(),
                                        bbt = this.getBBox(1),
                                        dx = bb.x - bbt.x,
                                        dy = bb.y - bbt.y;
                                    o.coordorigin = (dx * -zoom) + S + (dy * -zoom);
                                    setCoords(this, 1, 1, dx, dy, 0);
                                } else {
                                    o.style.filter = E;
                                    setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
                                }
                            } else {
                                o.style.filter = E;
                                skew.matrix = Str(matrix);
                                skew.offset = matrix.offset();
                            }
                            if (oldt !== null) { // empty string value is true as well
                                this._.transform = oldt;
                                R._extractTransform(this, oldt);
                            }
                            return this;
                        };
                        elproto.rotate = function (deg, cx, cy) {
                            if (this.removed) {
                                return this;
                            }
                            if (deg == null) {
                                return;
                            }
                            deg = Str(deg).split(separator);
                            if (deg.length - 1) {
                                cx = toFloat(deg[1]);
                                cy = toFloat(deg[2]);
                            }
                            deg = toFloat(deg[0]);
                            (cy == null) && (cx = cy);
                            if (cx == null || cy == null) {
                                var bbox = this.getBBox(1);
                                cx = bbox.x + bbox.width / 2;
                                cy = bbox.y + bbox.height / 2;
                            }
                            this._.dirtyT = 1;
                            this.transform(this._.transform.concat([["r", deg, cx, cy]]));
                            return this;
                        };
                        elproto.translate = function (dx, dy) {
                            if (this.removed) {
                                return this;
                            }
                            dx = Str(dx).split(separator);
                            if (dx.length - 1) {
                                dy = toFloat(dx[1]);
                            }
                            dx = toFloat(dx[0]) || 0;
                            dy = +dy || 0;
                            if (this._.bbox) {
                                this._.bbox.x += dx;
                                this._.bbox.y += dy;
                            }
                            this.transform(this._.transform.concat([["t", dx, dy]]));
                            return this;
                        };
                        elproto.scale = function (sx, sy, cx, cy) {
                            if (this.removed) {
                                return this;
                            }
                            sx = Str(sx).split(separator);
                            if (sx.length - 1) {
                                sy = toFloat(sx[1]);
                                cx = toFloat(sx[2]);
                                cy = toFloat(sx[3]);
                                isNaN(cx) && (cx = null);
                                isNaN(cy) && (cy = null);
                            }
                            sx = toFloat(sx[0]);
                            (sy == null) && (sy = sx);
                            (cy == null) && (cx = cy);
                            if (cx == null || cy == null) {
                                var bbox = this.getBBox(1);
                            }
                            cx = cx == null ? bbox.x + bbox.width / 2 : cx;
                            cy = cy == null ? bbox.y + bbox.height / 2 : cy;

                            this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
                            this._.dirtyT = 1;
                            return this;
                        };
                        elproto.hide = function () {
                            !this.removed && (this.node.style.display = "none");
                            return this;
                        };
                        elproto.show = function () {
                            !this.removed && (this.node.style.display = E);
                            return this;
                        };
                        // Needed to fix the vml setViewBox issues
                        elproto.auxGetBBox = R.el.getBBox;
                        elproto.getBBox = function(){
                            var b = this.auxGetBBox();
                            if (this.paper && this.paper._viewBoxShift)
                            {
                                var c = {};
                                var z = 1/this.paper._viewBoxShift.scale;
                                c.x = b.x - this.paper._viewBoxShift.dx;
                                c.x *= z;
                                c.y = b.y - this.paper._viewBoxShift.dy;
                                c.y *= z;
                                c.width  = b.width  * z;
                                c.height = b.height * z;
                                c.x2 = c.x + c.width;
                                c.y2 = c.y + c.height;
                                return c;
                            }
                            return b;
                        };
                        elproto._getBBox = function () {
                            if (this.removed) {
                                return {};
                            }
                            return {
                                x: this.X + (this.bbx || 0) - this.W / 2,
                                y: this.Y - this.H,
                                width: this.W,
                                height: this.H
                            };
                        };
                        elproto.remove = function () {
                            if (this.removed || !this.node.parentNode) {
                                return;
                            }
                            this.paper.__set__ && this.paper.__set__.exclude(this);
                            R.eve.unbind("raphael.*.*." + this.id);
                            R._tear(this, this.paper);
                            this.node.parentNode.removeChild(this.node);
                            this.shape && this.shape.parentNode.removeChild(this.shape);
                            for (var i in this) {
                                this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
                            }
                            this.removed = true;
                        };
                        elproto.attr = function (name, value) {
                            if (this.removed) {
                                return this;
                            }
                            if (name == null) {
                                var res = {};
                                for (var a in this.attrs) if (this.attrs[has](a)) {
                                    res[a] = this.attrs[a];
                                }
                                res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
                                res.transform = this._.transform;
                                return res;
                            }
                            if (value == null && R.is(name, "string")) {
                                if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
                                    return this.attrs.gradient;
                                }
                                var names = name.split(separator),
                                    out = {};
                                for (var i = 0, ii = names.length; i < ii; i++) {
                                    name = names[i];
                                    if (name in this.attrs) {
                                        out[name] = this.attrs[name];
                                    } else if (R.is(this.paper.customAttributes[name], "function")) {
                                        out[name] = this.paper.customAttributes[name].def;
                                    } else {
                                        out[name] = R._availableAttrs[name];
                                    }
                                }
                                return ii - 1 ? out : out[names[0]];
                            }
                            if (this.attrs && value == null && R.is(name, "array")) {
                                out = {};
                                for (i = 0, ii = name.length; i < ii; i++) {
                                    out[name[i]] = this.attr(name[i]);
                                }
                                return out;
                            }
                            var params;
                            if (value != null) {
                                params = {};
                                params[name] = value;
                            }
                            value == null && R.is(name, "object") && (params = name);
                            for (var key in params) {
                                eve("raphael.attr." + key + "." + this.id, this, params[key]);
                            }
                            if (params) {
                                for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
                                    var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
                                    this.attrs[key] = params[key];
                                    for (var subkey in par) if (par[has](subkey)) {
                                        params[subkey] = par[subkey];
                                    }
                                }
                                // this.paper.canvas.style.display = "none";
                                if (params.text && this.type == "text") {
                                    this.textpath.string = params.text;
                                }
                                setFillAndStroke(this, params);
                                // this.paper.canvas.style.display = E;
                            }
                            return this;
                        };
                        elproto.toFront = function () {
                            !this.removed && this.node.parentNode.appendChild(this.node);
                            this.paper && this.paper.top != this && R._tofront(this, this.paper);
                            return this;
                        };
                        elproto.toBack = function () {
                            if (this.removed) {
                                return this;
                            }
                            if (this.node.parentNode.firstChild != this.node) {
                                this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
                                R._toback(this, this.paper);
                            }
                            return this;
                        };
                        elproto.insertAfter = function (element) {
                            if (this.removed) {
                                return this;
                            }
                            if (element.constructor == R.st.constructor) {
                                element = element[element.length - 1];
                            }
                            if (element.node.nextSibling) {
                                element.node.parentNode.insertBefore(this.node, element.node.nextSibling);
                            } else {
                                element.node.parentNode.appendChild(this.node);
                            }
                            R._insertafter(this, element, this.paper);
                            return this;
                        };
                        elproto.insertBefore = function (element) {
                            if (this.removed) {
                                return this;
                            }
                            if (element.constructor == R.st.constructor) {
                                element = element[0];
                            }
                            element.node.parentNode.insertBefore(this.node, element.node);
                            R._insertbefore(this, element, this.paper);
                            return this;
                        };
                        elproto.blur = function (size) {
                            var s = this.node.runtimeStyle,
                                f = s.filter;
                            f = f.replace(blurregexp, E);
                            if (+size !== 0) {
                                this.attrs.blur = size;
                                s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
                                s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
                            } else {
                                s.filter = f;
                                s.margin = 0;
                                delete this.attrs.blur;
                            }
                            return this;
                        };

                        R._engine.path = function (pathString, vml) {
                            var el = createNode("shape");
                            el.style.cssText = cssDot;
                            el.coordsize = zoom + S + zoom;
                            el.coordorigin = vml.coordorigin;
                            var p = new Element(el, vml),
                                attr = {fill: "none", stroke: "#000"};
                            pathString && (attr.path = pathString);
                            p.type = "path";
                            p.path = [];
                            p.Path = E;
                            setFillAndStroke(p, attr);
                            vml.canvas && vml.canvas.appendChild(el);
                            var skew = createNode("skew");
                            skew.on = true;
                            el.appendChild(skew);
                            p.skew = skew;
                            p.transform(E);
                            return p;
                        };
                        R._engine.rect = function (vml, x, y, w, h, r) {
                            var path = R._rectPath(x, y, w, h, r),
                                res = vml.path(path),
                                a = res.attrs;
                            res.X = a.x = x;
                            res.Y = a.y = y;
                            res.W = a.width = w;
                            res.H = a.height = h;
                            a.r = r;
                            a.path = path;
                            res.type = "rect";
                            return res;
                        };
                        R._engine.ellipse = function (vml, x, y, rx, ry) {
                            var res = vml.path(),
                                a = res.attrs;
                            res.X = x - rx;
                            res.Y = y - ry;
                            res.W = rx * 2;
                            res.H = ry * 2;
                            res.type = "ellipse";
                            setFillAndStroke(res, {
                                cx: x,
                                cy: y,
                                rx: rx,
                                ry: ry
                            });
                            return res;
                        };
                        R._engine.circle = function (vml, x, y, r) {
                            var res = vml.path(),
                                a = res.attrs;
                            res.X = x - r;
                            res.Y = y - r;
                            res.W = res.H = r * 2;
                            res.type = "circle";
                            setFillAndStroke(res, {
                                cx: x,
                                cy: y,
                                r: r
                            });
                            return res;
                        };
                        R._engine.image = function (vml, src, x, y, w, h) {
                            var path = R._rectPath(x, y, w, h),
                                res = vml.path(path).attr({stroke: "none"}),
                                a = res.attrs,
                                node = res.node,
                                fill = node.getElementsByTagName(fillString)[0];
                            a.src = src;
                            res.X = a.x = x;
                            res.Y = a.y = y;
                            res.W = a.width = w;
                            res.H = a.height = h;
                            a.path = path;
                            res.type = "image";
                            fill.parentNode == node && node.removeChild(fill);
                            fill.rotate = true;
                            fill.src = src;
                            fill.type = "tile";
                            res._.fillpos = [x, y];
                            res._.fillsize = [w, h];
                            node.appendChild(fill);
                            setCoords(res, 1, 1, 0, 0, 0);
                            return res;
                        };
                        R._engine.text = function (vml, x, y, text) {
                            var el = createNode("shape"),
                                path = createNode("path"),
                                o = createNode("textpath");
                            x = x || 0;
                            y = y || 0;
                            text = text || "";
                            path.v = R.format("m{0},{1}l{2},{1}", round(x * zoom), round(y * zoom), round(x * zoom) + 1);
                            path.textpathok = true;
                            o.string = Str(text);
                            o.on = true;
                            el.style.cssText = cssDot;
                            el.coordsize = zoom + S + zoom;
                            el.coordorigin = "0 0";
                            var p = new Element(el, vml),
                                attr = {
                                    fill: "#000",
                                    stroke: "none",
                                    font: R._availableAttrs.font,
                                    text: text
                                };
                            p.shape = el;
                            p.path = path;
                            p.textpath = o;
                            p.type = "text";
                            p.attrs.text = Str(text);
                            p.attrs.x = x;
                            p.attrs.y = y;
                            p.attrs.w = 1;
                            p.attrs.h = 1;
                            setFillAndStroke(p, attr);
                            el.appendChild(o);
                            el.appendChild(path);
                            vml.canvas.appendChild(el);
                            var skew = createNode("skew");
                            skew.on = true;
                            el.appendChild(skew);
                            p.skew = skew;
                            p.transform(E);
                            return p;
                        };
                        R._engine.setSize = function (width, height) {
                            var cs = this.canvas.style;
                            this.width = width;
                            this.height = height;
                            width == +width && (width += "px");
                            height == +height && (height += "px");
                            cs.width = width;
                            cs.height = height;
                            cs.clip = "rect(0 " + width + " " + height + " 0)";
                            if (this._viewBox) {
                                R._engine.setViewBox.apply(this, this._viewBox);
                            }
                            return this;
                        };
                        R._engine.setViewBox = function (x, y, w, h, fit) {
                            R.eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
                            var paperSize = this.getSize(),
                                width = paperSize.width,
                                height = paperSize.height,
                                H, W;
                            if (fit) {
                                H = height / h;
                                W = width / w;
                                if (w * H < width) {
                                    x -= (width - w * H) / 2 / H;
                                }
                                if (h * W < height) {
                                    y -= (height - h * W) / 2 / W;
                                }
                            }
                            this._viewBox = [x, y, w, h, !!fit];
                            this._viewBoxShift = {
                                dx: -x,
                                dy: -y,
                                scale: paperSize
                            };
                            this.forEach(function (el) {
                                el.transform("...");
                            });
                            return this;
                        };
                        var createNode;
                        R._engine.initWin = function (win) {
                            var doc = win.document;
                            if (doc.styleSheets.length < 31) {
                                doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
                            } else {
                                // no more room, add to the existing one
                                // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
                                doc.styleSheets[0].addRule(".rvml", "behavior:url(#default#VML)");
                            }
                            try {
                                !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
                                createNode = function (tagName) {
                                    return doc.createElement('<rvml:' + tagName + ' class="rvml">');
                                };
                            } catch (e) {
                                createNode = function (tagName) {
                                    return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
                                };
                            }
                        };
                        R._engine.initWin(R._g.win);
                        R._engine.create = function () {
                            var con = R._getContainer.apply(0, arguments),
                                container = con.container,
                                height = con.height,
                                s,
                                width = con.width,
                                x = con.x,
                                y = con.y;
                            if (!container) {
                                throw new Error("VML container not found.");
                            }
                            var res = new R._Paper,
                                c = res.canvas = R._g.doc.createElement("div"),
                                cs = c.style;
                            x = x || 0;
                            y = y || 0;
                            width = width || 512;
                            height = height || 342;
                            res.width = width;
                            res.height = height;
                            width == +width && (width += "px");
                            height == +height && (height += "px");
                            res.coordsize = zoom * 1e3 + S + zoom * 1e3;
                            res.coordorigin = "0 0";
                            res.span = R._g.doc.createElement("span");
                            res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;";
                            c.appendChild(res.span);
                            cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
                            if (container == 1) {
                                R._g.doc.body.appendChild(c);
                                cs.left = x + "px";
                                cs.top = y + "px";
                                cs.position = "absolute";
                            } else {
                                if (container.firstChild) {
                                    container.insertBefore(c, container.firstChild);
                                } else {
                                    container.appendChild(c);
                                }
                            }
                            res.renderfix = function () {};
                            return res;
                        };
                        R.prototype.clear = function () {
                            R.eve("raphael.clear", this);
                            this.canvas.innerHTML = E;
                            this.span = R._g.doc.createElement("span");
                            this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
                            this.canvas.appendChild(this.span);
                            this.bottom = this.top = null;
                        };
                        R.prototype.remove = function () {
                            R.eve("raphael.remove", this);
                            this.canvas.parentNode.removeChild(this.canvas);
                            for (var i in this) {
                                this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
                            }
                            return true;
                        };

                        var setproto = R.st;
                        for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
                            setproto[method] = (function (methodname) {
                                return function () {
                                    var arg = arguments;
                                    return this.forEach(function (el) {
                                        el[methodname].apply(el, arg);
                                    });
                                };
                            })(method);
                        }
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


                    /***/ }
                /******/ ])
        });
        ;
    </script>
    <script>
        var rsr = Raphael('map', '960', '960');

        var regions=[];

        var path_a = rsr.path("M703 261c-1,-1 -2,-1 -3,-3 -1,0 -1,0 -1,-1 0,-2 -2,-2 -2,-2 0,-1 0,-2 0,-2 0,-1 -1,0 -2,-1 0,-1 1,-2 1,-2 0,0 -1,0 -1,0 -1,0 0,-1 -1,-2 0,0 -1,0 -1,-1 1,0 1,-1 1,-1 1,0 0,1 1,1 0,0 2,0 2,0 0,-1 -1,0 -1,-1 -1,-2 1,-2 1,-2 0,-1 -1,0 -1,0 0,-1 0,-2 0,-2 -1,0 -1,1 -2,0 0,0 1,-2 0,-2 0,-1 -1,0 -1,0 0,-1 0,-1 0,-1 0,-1 0,-1 0,-1 -1,-1 -2,-1 -2,-1 0,-1 1,-2 1,-2 0,-1 -2,1 -2,-1 -1,0 0,-1 0,-1 1,0 2,2 3,0 0,-1 -2,-1 -2,-1 -1,-1 -1,-1 -2,-1 0,-3 -1,-5 -1,-7l-4 -3 2 -3c-1,-1 -2,-2 -3,-3l1 -1c0,-1 0,-1 1,-3l-2 1c-1,0 -2,0 -2,-1 0,-1 1,-2 0,-2 -1,-1 -3,2 -3,0 0,-2 2,-2 1,-3 0,0 -1,0 -2,0 0,0 1,-1 0,-2 -1,-1 -2,-1 -3,-2 -1,-1 0,-2 -1,-2 0,0 -1,-1 -1,-1 0,0 1,-1 1,-2 1,-1 -1,0 0,-3 0,-1 -1,0 -1,1 -1,-1 0,-2 0,-2 -1,-1 -2,2 -2,2 -1,0 -1,-1 -2,-1 -1,-1 -1,0 -3,-1 0,0 0,-1 0,-1 -1,-2 2,0 3,0 0,-4 -4,-1 -5,-3 0,-1 2,-2 2,-3 -1,-1 -2,-1 -3,-1 0,0 -1,-1 -1,0 2,4 -1,2 -2,1 0,-1 2,0 2,-2 0,0 -2,1 -2,0 -1,0 -2,-1 -3,-2 0,0 0,-1 0,-2 -1,0 -2,1 -2,1 -1,0 -1,-1 -1,-2 0,-1 0,0 -1,-1 0,0 0,-1 -1,-1 0,0 0,1 -1,1 0,0 0,0 -1,0 -1,1 -2,0 -3,0 0,0 -1,1 -2,0 0,0 1,0 1,-1 0,0 -1,0 -1,0 0,0 1,1 0,1 -2,1 -2,-2 -3,-2 0,0 -1,2 -2,2 0,0 -1,1 -1,0 0,-1 0,-1 0,-2 -1,0 -1,1 -1,1 -1,1 -2,-3 -3,1l0 0 0 1 -1 0 0 0 -1 0 -1 -1 -1 2 0 2 -2 -1 0 1 -3 1 -1 -1 -3 0 0 0 -1 0 -1 0 0 1 -1 1 -1 0 0 1 -1 -1 -3 2 -1 0 0 -1 -1 0 -1 1 -1 -1 0 1 -2 0 -1 0 0 1 0 2 0 1 -1 1 -1 2 0 2 -1 1 -1 1 0 2 -1 2 -1 1 -2 2 -1 2 -1 1 -2 4 -3 1 0 0 -2 0 -1 0 -2 0 -1 0 0 0 0 0 1 5 1 1 2 1 1 1 0 1 2 0 1 1 1 1 0 0 -1 1 0 1 1 1 0 0 2 -1 0 0 1 0 1 0 0 0 2 1 1 2 1 0 0 1 0 0 0 1 2 0 0 0 0 1 0 0 0 1 0 0 2 1 0 0 0 2 1 1 1 0 1 0 0 1 1 0 0 -1 1 -1 2 0 1 0 2 1 1 1 0 2 1 1 1 0 2 1 1 1 1 6 0 0 0 3 0 2 1 1 2 3 1 1 -1 2 2 1 0 0 1 1 1 2 2 2 2 3 0 1 -1 2 -3 2 -2 1 0 0 1 2 0 0 1 1 1 0 0 1 -1 1 0 1 2 -1 6 -2 1 0 1 0 1 -1 1 0 1 -1 2 0 5 1 0 0 0 -1 0 -1 0 0 -2 -1 0 -1 0 -1 2 0 2 1 2 0 3 0 2 0 2 0 1 0 2 1 3 -1 1 0 1 1 1 2 1 1 2 0 2 -1 2 -1 1 -2 0 -2 0 -2 0 -1 2 -1 2 1 1 0 1 0 2 0 1 0 1 0 5 -4 3 -1 4 -1 1 0 1 0 1 -1 1 0c-1,0 -1,0 -1,0z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_b = rsr.path("M701 262l-1 0 -4 1 -3 1 -5 4 -1 0 -1 0 -2 0 -1 0 -1 0 -2 -1 -2 1 0 1 0 2 0 2 -1 2 -2 1 -2 1 -2 0 -1 -1 -1 -2 -1 -1 -1 0 -3 1 -2 -1 -1 0 -2 0 -2 0 -3 0 -2 0 -2 -1 -2 0 0 1 0 1 2 1 0 0 0 1 0 1 0 0 -5 -1 -2 0 -1 1 0 1 -1 1 0 2 0 2 1 2 1 2 1 1 -1 1 -1 0 -2 -1 -1 0 -1 1 0 0 1 2 0 1 0 1 -1 1 -4 -1 -1 0 -2 -1 -1 0 -2 -1 0 1 0 0 -1 1 0 1 1 1 0 4 1 1 0 0 1 1 1 1 0 2 -1 1 -1 0 -1 1 0 0 0 1 1 2 4 5 2 3 1 5 0 2 1 1 2 1 2 1 2 0 2 1 2 0 1 1 1 0 2 1 2 3 1 1 3 3 1 0 4 1 1 -1 0 0 1 0 1 -1 2 0 2 -1 1 -1 0 0 5 -3 3 -1 2 -1 1 1 2 0 0 1 2 2 1 2 0 3 -1 1 -1 1 -2 1 0 0 -1 0 0 0 -2 1 -1 1 0 1 0 1 1 2 3 3 2 2 3 4 9 1 3 -1 1 -1 3 -2 1 -1 1 0 1 0 1 1 2 3 2 1 2 0 1 0 1 0 1 -1 1 -1 1 -1 1 0 2 -1 3 1 0 -1 2 0 0 0 2 0 1 -1 0 -1 -1 -1 -1 -2 0 -2 0 0 1 -1 1 0 2 0 3 1 1 1 2 2 0 2 1 2 0 1 2 3 1 0 1 -4 1 -2 1 -1 1 0 1 0 1 2 1 2 0 3 0 2 1 1 3 0 1 1 1 5 0 0 1 0 1 -1 2 -2 1 -3 1 -1 2 0 1 2 1 1 1 1 1 0 3 0 1 -1 2 0 0 0 2 -1c0,0 0,0 0,0 0,-1 -1,-1 -1,-2 0,0 -1,0 -1,0 0,-1 2,-1 2,-1 -1,-1 0,-2 0,-2 -1,-1 -1,0 -1,0 0,0 0,0 0,0 -2,0 -2,-1 -2,-1 0,0 0,0 0,-1 1,0 1,0 2,0 0,0 1,-2 0,-2l0 0c-2,-1 0,-1 0,-1 -1,-1 -2,0 -2,-1 0,0 0,0 0,0 1,-1 1,0 1,0 0,-1 0,-1 0,-1 0,-1 0,0 -1,0 0,-1 1,-1 1,-1 -1,-1 -1,0 -2,-1 0,-1 1,0 1,-1 0,-1 1,-1 1,-1 -2,-1 -2,-2 -4,-3 0,0 0,0 0,0 0,0 0,0 0,0 -1,0 -1,-1 -1,-2 -1,0 -1,1 -1,0 1,-1 1,0 2,0 0,0 0,-1 0,-1 -1,-1 -1,0 -1,0 0,0 0,-1 -1,-1 -1,0 0,1 -1,1 -2,-1 -2,-2 -3,-2 -1,1 -1,-1 -2,-1 -1,0 0,0 0,0 0,-1 -1,0 -1,0 0,0 -1,0 -1,-1 0,0 2,0 1,-1l-1 0c0,0 -3,-1 -3,-1 0,0 -1,-1 -1,-1 -1,0 -1,-1 -1,-1 -1,-2 -1,-1 -1,-1 0,0 0,-1 0,-1 0,0 -1,-1 -1,-1 0,-1 -1,0 -1,0 -1,0 -1,0 0,-1 -1,0 -3,0 -3,-1 0,-1 1,-1 1,-1 0,0 0,1 1,1 0,-1 0,-1 0,-1 -1,-1 -3,-1 -3,-1 -1,0 -3,0 -3,-1 0,0 1,1 1,0 0,-1 -1,0 -1,-1 0,-1 1,0 1,0 1,-1 1,-1 1,-2 1,0 -1,0 -1,-1 0,0 1,-2 1,-2 0,-1 -2,1 -2,0 0,-1 1,-2 0,-2 0,-1 -1,1 -1,0 0,0 2,-2 1,-2 0,0 -2,0 -2,0 0,0 1,-1 1,-1 -1,-1 -2,0 -2,0 0,-1 1,-2 0,-2 0,0 -1,1 -1,0 0,-1 1,0 1,-1 0,-2 -1,1 -1,-1 0,0 1,1 1,0 0,0 -1,0 -1,-1 0,0 0,-1 0,-1 0,-1 0,0 -1,0 0,0 1,-1 0,-1 0,-1 0,-1 0,-2 0,0 -3,-1 -3,0 1,2 0,0 -1,1 0,0 0,1 -1,0 0,0 0,-3 0,-3 -1,1 0,1 -1,2 0,0 0,-1 0,-2 -1,1 -2,0 -2,1 0,0 0,1 0,1 0,0 -1,-1 -1,-1 0,-1 0,-1 0,-1 0,0 -1,0 -1,0 0,0 0,-1 0,-2 -1,0 -1,1 -1,1l-1 0c-1,1 2,-1 0,-1 0,0 0,1 0,1 0,0 -1,0 -1,0 0,-1 -1,-1 -1,-1 0,-1 1,0 2,0 0,0 1,-1 1,-2 -1,0 -1,1 -1,0 0,0 1,-1 0,-1 0,0 -1,1 -1,0 0,0 1,-2 1,-2 -1,-1 -2,1 -3,-1 0,0 1,0 1,-1 0,0 -1,1 -1,1 0,0 0,-3 0,-3 0,-1 1,0 1,-2 0,0 0,0 -1,0 0,0 0,-1 0,-1 0,-1 -1,-1 -2,-1 0,-2 1,0 1,-3 0,0 1,0 1,0 0,-1 0,-1 0,-2 -2,1 -3,-3 -3,-3 0,0 -1,0 -1,0 0,1 1,1 1,1 -1,0 -1,0 -2,0 0,0 0,1 0,1 -1,-1 0,-2 0,-2 -1,-1 -1,0 -1,0 0,1 -2,1 -2,1 0,-1 1,-1 1,-1 -1,-1 -2,0 -2,0 0,0 -1,-2 -1,-2 0,0 -1,0 -1,-1 0,0 0,-1 0,-1 0,0 1,-1 1,-1 0,-1 -1,1 -1,0 -1,0 -1,-1 -1,-1 0,0 2,0 1,-1 0,0 -2,0 -2,-1 0,0 1,1 0,0 0,0 -1,0 -1,-1 0,0 1,-1 1,-1 -1,0 -1,0 -1,0 -1,-2 1,-2 0,-2 0,-1 0,-1 0,-1 -5,1 -4,-2 -5,-4l-1 0 -1 0 0 1 -1 0z").attr({fill: 'green',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'iasi', 'region': 'iasi2'});

        var path_c = rsr.path("M713 357l-2 0 -2 -1 -2 -3 -1 -1 -1 0 -1 0 -1 1 -3 2 -1 1 -3 1 -9 -1 1 5 0 2 -3 5 0 2 1 2 0 0 0 0 3 2 1 0 3 2 1 0 0 0 1 1 0 1 0 2 -1 2 0 2 -1 3 1 2 2 4 3 6 2 4 1 1 3 4 1 1 2 3 2 4 0 3 0 3 2 4 3 4 1 1 0 1 1 6 0 7 0 1 -1 5 0 0 0 0 -1 2 1 2 1 1 3 3 0 3 0 1 -1 2 0 2 1 4 1 0 1 1 1 -1 1 -1 2 -3 2 -1 2 -4 1 -5 1 -2 1 0 1 0 5 -1 3 0 2 1 4 0 0 0 1 0 1 -1 3 -2 0 0 1 -1 1 1 2 1 1 1 3 1 3 0 1 1 5 0 2 0 2 1 1 0c0,0 0,0 0,0 0,-1 0,0 1,-1 -1,0 -1,-1 -1,-1 0,-2 -1,-1 0,-2 0,-1 0,0 0,0 1,0 1,-1 1,-1 0,-1 0,-1 0,-1 0,0 -1,-1 -1,-1 0,-1 2,0 1,-1 0,0 -1,1 -1,0 0,-1 1,0 1,0 0,-1 0,-1 0,-1 0,-1 -2,0 -2,0 0,-1 1,-1 1,-2 0,-1 -1,-1 -1,-1 0,1 0,2 -1,1 0,0 1,0 1,-1 0,0 -1,0 -1,0 0,-1 0,-1 0,-1 0,-1 0,-1 0,-1 1,-1 0,-2 1,-2 0,-1 0,1 0,1 1,-1 1,-2 2,-2 0,0 1,0 1,0 0,0 -1,-1 -1,-1l-1 0c0,-1 1,0 1,-1 0,0 0,-2 0,-2 2,-2 0,1 1,0 1,0 0,-1 0,-1 0,0 1,1 1,1 0,0 1,0 1,0 0,-3 1,-2 0,-1l1 0c0,0 1,0 0,-1 0,0 -1,0 0,0 1,-1 4,-3 2,-3 0,0 0,-1 0,-1 -1,0 -2,0 -1,0 -1,-1 0,-1 0,-1 0,0 0,0 0,0 0,-1 1,-1 1,-1 -1,-1 -1,0 -1,0 0,0 0,0 0,0 -1,-1 -1,-1 -1,-1 1,0 1,0 1,0 0,-1 0,-1 0,-1 0,0 1,0 2,0 -1,0 -1,0 -1,0 0,-1 0,-1 0,-1 0,-1 -1,0 -1,-1 1,0 2,0 2,0 0,-2 0,0 1,-1 -1,-1 0,-1 0,-1 -1,0 -1,-1 -1,-1 2,0 1,1 3,0 0,0 -1,-1 -1,-1 0,0 -1,1 -1,1 0,-1 1,-1 1,-1 -1,0 -1,-2 1,-1 1,-2 2,-3 1,-5 0,0 -1,0 -1,0 -1,-1 1,-1 1,-2 0,0 -1,0 -1,0 0,0 1,0 1,0 -1,0 -1,0 -1,-1 0,0 0,0 0,-1 0,0 -3,1 -1,0 -1,-1 0,-2 0,-2 0,0 -1,0 -1,0 0,0 0,-1 0,-1 0,0 -1,1 -1,0 0,0 0,0 0,0 0,-2 2,0 1,-2 -2,-1 0,0 0,0 0,0 1,-1 1,-2 -1,0 -3,0 -1,-1l0 -2c0,0 1,1 1,1l0 -2c-1,0 -1,0 -1,0 0,0 0,-2 0,-2 0,0 1,0 2,0 -1,0 -1,-1 -1,-1 0,0 1,0 0,-1 1,-1 1,-1 1,-1 0,-1 1,-1 0,-3 0,-1 0,0 -1,-1 0,0 1,0 1,-1 0,0 -1,0 -1,0 0,-1 1,-1 1,-1 -2,-1 0,-2 -1,-3 0,-1 0,-2 0,-1 0,1 -1,1 -1,0 0,0 0,-1 0,-2 -1,0 -1,1 -1,1 0,0 -1,0 -1,0l1 -1c0,-1 -1,0 -1,-1 0,0 1,0 1,-1 -1,-1 -4,-3 -2,-3 0,-1 -1,1 -1,-1 0,-1 -1,-1 -1,-2 1,-1 1,1 1,-1 0,0 0,1 0,0 0,0 0,-1 0,-1 0,0 -1,0 -1,0 0,-1 0,-1 -1,-1 0,0 1,0 2,0 0,0 -1,-1 -1,-1 -1,0 0,-1 -1,-1 0,0 0,1 0,1 -2,-3 -1,-1 -3,-2 0,-1 0,-1 0,-2 0,0 -1,0 0,0 0,-2 -1,0 -1,-1 0,0 1,-1 -1,-2 1,-1 1,-1 1,-1 1,0 1,0 1,-1 0,0 -1,0 -1,0l-2 1 0 0 -2 0 -1 1 -3 0 -1 0 -1 -1 -1 -1 -1 -2 -2 0 -1 1 -1 3 -2 2 -1 1 -1 0 0 0 -1 -5 -1 -1 -3 0 -1 -1 0 -2 0 -3 -1 -2 -1 -2 -1 0 -1 0 -1 1 -1 2 -1 4 -1 0 -2 -3 0 -1 -1 -2 0 -2 -2 -2 -1 -1 -3 -1 -2 0 -1 0 -1 1 0 0 0 2 1 2 1 1 0 1 -1 1 -2 0 0 0 -2 0 0 1 -3 -1 -2 1 -1 0 -1 1 -1 1 -1 1 -1 0 -1 0z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_d = rsr.path("M 671,369 674,369 675,369 677,370 679,373 680,373 681,373 683,373 684,373 685,372 685,372 686,372 686,372 685,370 685,368 688,363 688,361 687,356 684,352 682,350 679,347 678,345 678,344 678,343 679,342 681,341 681,341 682,341 682,341 684,340 685,339 686,338 686,335 685,333 683,330 681,330 680,329 678,330 675,331 670,334 670,334 669,335 667,336 665,336 664,337 663,337 663,337 662,338 658,337 657,337 654,334 653,333 651,330 649,329 647,328 645,328 643,327 641,327 639,326 637,325 636,324 636,322 635,317 633,314 629,309 628,307 628,306 628,306 627,306 624,302 621,301 620,299 620,299 618,297 615,295 614,295 608,295 603,295 599,295 596,295 592,296 590,296 586,296 585,297 580,297 577,298 575,299 572,300 570,302 569,302 568,301 565,298 563,297 561,296 560,295 560,295 558,295 558,295 557,296 557,297 558,300 559,303 560,305 559,306 559,307 558,308 557,309 556,309 556,309 555,310 553,311 552,312 550,314 549,318 546,322 546,325 547,325 547,326 550,327 552,329 553,332 554,336 554,339 555,342 556,343 557,343 560,344 561,344 561,344 562,345 563,348 563,349 563,350 563,351 562,351 560,348 558,348 557,349 556,351 556,355 556,359 557,360 557,360 559,360 560,360 561,360 561,361 561,362 559,363 559,365 560,366 561,368 561,372 561,378 561,382 564,388 565,392 566,393 567,393 568,393 569,390 570,389 571,388 572,388 574,388 574,387 575,387 577,386 577,386 578,385 579,385 580,385 582,385 585,387 586,387 587,387 591,386 592,386 594,384 595,382 596,381 598,380 599,381 600,381 601,384 602,384 604,384 606,384 607,384 609,383 611,382 611,382 612,382 614,381 614,381 617,380 623,380 626,380 627,380 628,379 630,375 632,374 634,373 635,371 636,371 637,370 638,370 638,370 642,370 645,371 647,372 650,372 651,371 652,371 652,371 653,370 656,365 658,363 659,363 659,364 660,364 660,365 660,369 660,369 660,369 660,370 661,370 661,371 662,371 663,372 666,372 667,372 668,371 669,370 669,370 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_e = rsr.path("M 487,322 491,323 493,323 496,321 498,321 501,321 504,322 505,322 509,323 510,323 510,323 512,321 513,321 515,319 517,315 520,315 521,316 521,316 523,317 525,317 526,317 527,317 528,317 529,317 530,317 531,318 531,319 530,321 529,322 529,323 529,324 529,326 531,327 532,328 534,328 536,328 538,328 541,327 541,327 542,327 544,326 546,325 546,325 546,322 549,318 550,314 552,312 553,311 555,310 556,309 556,309 557,309 558,308 559,307 559,306 560,305 559,303 558,300 557,297 557,296 558,295 558,295 560,295 560,295 561,296 563,297 565,298 568,301 569,302 570,302 572,300 575,299 577,298 580,297 585,297 586,296 590,296 592,296 596,295 599,295 603,295 608,295 614,295 615,295 618,297 620,299 620,299 621,301 624,302 627,306 628,306 629,305 630,305 631,304 631,302 630,301 629,300 629,300 628,299 628,295 627,294 627,293 628,292 628,292 628,291 630,292 631,292 633,293 634,293 638,294 639,293 639,292 639,291 638,289 638,289 639,288 640,288 642,289 643,289 644,288 643,287 642,285 641,283 641,281 641,279 642,278 642,277 641,277 640,278 639,278 638,278 632,280 630,281 630,280 631,279 631,278 630,278 629,277 629,277 628,275 628,275 630,274 633,272 634,270 634,269 632,266 630,264 629,262 628,261 628,261 626,260 627,258 626,257 624,254 623,253 623,251 623,248 623,248 622,242 621,241 619,240 618,240 617,239 617,237 616,236 614,235 613,235 611,235 610,236 610,237 609,237 609,236 608,236 607,236 606,235 606,233 606,233 604,232 604,232 604,231 604,231 604,230 604,230 602,230 602,229 602,229 602,228 601,228 600,226 598,225 598,225 597,225 596,225 596,225 594,226 594,226 593,225 593,224 594,223 594,223 593,222 592,221 590,221 590,220 589,219 587,218 586,217 586,214 585,212 584,213 583,212 581,212 579,212 579,212 578,213 577,212 575,212 574,212 573,212 571,212 569,212 568,212 567,212 566,213 564,213 563,213 563,213 561,213 560,213 560,213 559,213 558,214 556,214 554,215 552,215 551,215 550,215 548,215 547,215 546,215 545,215 544,215 543,215 542,215 541,215 541,216 540,217 539,217 536,217 535,218 533,218 532,218 531,218 530,218 529,218 528,218 527,218 526,219 525,219 524,220 523,221 522,221 521,222 521,223 520,223 516,224 514,224 513,225 512,225 510,225 508,226 506,226 506,226 504,226 504,228 501,231 500,233 499,235 498,236 497,238 495,240 493,242 493,243 491,243 490,244 489,244 487,245 486,245 482,246 482,246 482,248 482,248 481,249 481,251 482,253 482,253 484,256 485,257 485,259 484,261 483,262 482,263 481,264 481,264 481,265 482,265 482,266 484,267 485,267 487,267 488,268 488,269 488,272 489,275 490,278 490,280 489,282 489,283 488,283 486,284 485,283 484,283 483,283 482,283 482,283 481,284 481,286 482,287 482,287 482,287 483,288 484,289 484,289 485,290 485,294 484,296 482,298 482,298 481,300 481,302 482,304 482,305 483,307 484,308 484,311 484,320 484,321 484,322 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_f = rsr.path("M 695,378 695,377 694,376 694,376 693,376 690,374 689,374 686,372 686,372 685,372 685,372 684,373 683,373 681,373 680,373 679,373 677,370 675,369 674,369 671,369 669,370 669,370 668,371 667,372 666,372 663,372 662,371 661,371 661,370 660,370 660,369 660,369 660,369 660,365 660,364 659,364 659,363 658,363 656,365 653,370 652,371 652,371 651,371 650,372 647,372 645,371 642,370 638,370 638,370 637,370 636,371 635,371 634,373 632,374 630,375 628,379 627,380 626,380 623,380 617,380 614,381 614,381 612,382 611,382 611,382 609,383 607,384 606,384 604,384 602,384 601,384 600,381 599,381 598,380 596,381 595,382 594,384 592,386 591,386 587,387 586,387 585,387 582,385 580,385 579,385 578,385 577,386 577,386 575,387 574,387 574,388 574,388 576,389 577,390 578,392 578,395 579,399 580,402 582,404 584,405 585,407 585,408 585,410 584,411 583,412 583,412 581,412 580,412 580,412 578,416 578,418 577,419 577,420 578,421 580,422 586,423 587,423 589,425 590,425 589,427 589,428 587,428 586,429 586,430 587,430 589,431 593,430 595,430 596,430 598,430 599,431 599,432 599,434 598,437 597,439 597,440 598,441 599,443 599,443 600,443 602,443 602,442 603,442 606,443 607,444 608,451 609,456 610,457 610,457 613,458 614,459 614,461 615,462 615,462 616,463 616,463 617,465 617,465 618,465 618,464 620,463 621,463 624,463 626,464 626,464 627,465 629,466 631,466 631,465 631,465 634,463 638,461 640,460 644,459 645,459 645,458 647,458 649,461 652,461 655,460 659,460 660,461 660,461 661,461 664,461 665,461 666,461 668,459 669,458 671,458 672,458 672,458 673,457 676,455 676,455 676,455 678,454 678,454 678,454 679,454 682,453 683,452 686,451 686,451 686,450 687,450 688,450 690,449 691,449 694,448 699,448 700,449 703,451 705,451 705,450 706,448 707,447 709,448 710,448 711,448 711,449 712,449 714,450 715,451 716,451 716,451 717,446 717,445 717,438 716,432 716,431 715,430 712,426 710,422 710,419 710,416 708,412 706,409 705,408 702,404 701,403 699,399 696,393 694,389 693,387 694,384 694,382 695,380 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_g = rsr.path("M 589,685 592,685 590,680 592,677 593,678 594,678 595,677 598,673 596,673 594,672 593,672 591,671 593,668 587,667 586,665 586,661 584,661 578,664 577,666 575,666 575,670 578,671 578,673 574,673 574,676 578,677 581,680 587,681 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_h = rsr.path("M 604,634 602,636 600,638 600,638 600,638 600,640 601,641 602,643 605,649 606,652 606,654 606,654 604,656 604,657 605,659 606,659 609,659 609,659 612,659 612,660 612,662 612,662 615,662 617,662 621,660 623,660 624,660 627,663 630,662 629,666 632,671 633,672 634,673 636,674 637,675 638,674 638,673 639,672 641,672 644,672 645,671 645,671 649,669 650,667 653,663 654,661 656,660 657,660 657,662 657,663 657,664 658,664 659,663 661,663 665,663 667,663 669,662 671,662 673,663 673,663 676,664 677,664 677,668 678,668 679,669 681,668 681,668 682,668 684,668 685,669 687,669 689,670 689,669 691,669 693,669 695,670 696,670 696,670 696,670 698,671 699,671 701,670 702,669 703,668 704,668 706,669 706,671 709,671 709,674 709,675 711,675 712,674 712,672 713,671 713,671 715,671 715,671 718,668 718,667 719,666 719,666 719,668 720,670 720,675 721,676 722,676 722,676 723,675 723,674 724,673 724,672 728,673 729,674 730,675 730,676 731,678 735,679 737,681 737,681 738,682 739,684 742,686 745,687 747,689 748,688 748,688 748,687 749,686 750,686 751,686 754,687 758,689 759,690 760,690 763,691 763,691 764,691 764,691 765,688 765,688 767,687 768,686 768,685 769,685 769,684 769,683 769,682 770,682 772,680 772,680 772,680 773,678 773,678 774,677 773,676 772,672 772,671 772,670 770,669 769,669 769,668 768,667 767,666 767,665 767,665 767,663 767,663 765,661 765,661 765,658 766,656 766,654 766,654 766,653 765,652 765,651 764,649 762,647 761,646 760,646 758,646 757,645 756,645 756,644 755,643 755,643 753,642 753,642 752,642 752,639 751,638 751,638 752,637 752,637 752,636 752,636 751,635 751,635 748,634 747,634 746,633 746,632 746,631 746,629 746,628 746,628 744,628 743,628 741,630 740,632 740,633 738,634 738,634 735,634 734,633 733,632 732,632 732,632 730,631 725,631 724,631 718,630 717,629 715,627 715,627 714,626 713,626 713,627 713,628 713,629 714,630 713,632 713,632 713,633 711,632 709,631 707,628 706,627 703,624 702,624 701,625 698,627 696,632 695,632 694,632 693,630 691,627 690,627 688,626 688,626 688,628 687,629 687,630 687,631 690,632 690,632 691,633 690,634 687,634 686,635 685,636 684,636 684,636 681,636 681,635 681,634 682,631 682,630 682,629 680,629 679,629 677,628 676,627 675,627 672,631 671,632 670,633 669,633 667,632 667,631 666,630 664,630 662,628 661,628 660,628 657,628 655,627 653,627 650,629 649,629 645,630 645,630 644,630 642,630 639,629 638,629 636,628 636,626 634,622 634,621 631,621 630,622 628,622 627,622 626,623 625,626 625,627 624,627 622,628 616,628 615,629 614,629 613,629 613,630 611,630 609,630 609,630 607,629 606,630 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_i = rsr.path("M 613,492 614,495 613,495 615,497 616,497 617,498 619,500 620,501 621,502 621,506 622,511 624,515 625,516 628,519 630,522 632,526 633,526 634,526 635,526 637,525 639,524 640,524 641,524 644,523 646,524 647,525 648,527 651,532 654,536 655,536 656,536 657,536 657,536 658,535 659,533 660,533 661,533 663,533 663,534 666,536 667,536 668,536 670,537 671,539 672,542 673,543 675,543 677,543 678,541 679,541 680,541 681,542 681,543 682,544 681,547 681,547 682,548 684,548 685,548 686,546 688,545 688,544 690,544 691,545 691,545 691,545 693,545 694,544 696,544 696,545 696,546 695,548 695,549 695,551 695,552 697,552 697,552 699,550 700,550 700,550 702,550 704,551 705,551 705,551 705,549 707,545 708,543 710,542 712,541 713,540 714,540 716,539 716,539 717,538 718,538 721,537 720,536 720,536 719,537 718,536 718,536 718,535 718,535 718,534 719,533 718,532 717,532 717,531 717,531 717,530 719,529 719,529 719,529 718,527 718,526 718,526 717,525 717,525 717,524 717,524 718,524 718,523 718,523 717,523 716,523 716,523 715,522 715,522 714,521 713,521 713,521 713,521 713,519 712,519 712,518 712,518 712,517 711,517 710,517 709,517 709,517 708,517 708,516 707,515 707,514 706,514 706,513 705,513 705,512 704,511 704,510 703,510 703,509 703,508 702,507 703,506 703,505 703,505 703,504 702,503 701,501 701,501 700,500 700,499 700,498 699,496 700,496 699,495 699,494 699,493 696,493 695,492 696,489 695,488 694,488 694,487 694,486 694,485 694,483 693,482 693,482 693,482 692,481 693,480 693,480 692,479 691,477 691,477 691,474 691,473 690,473 690,471 690,470 690,469 690,469 690,468 692,467 692,467 692,467 692,466 692,466 692,466 691,466 691,465 692,465 692,465 693,465 693,465 694,466 695,466 696,465 696,465 698,464 700,463 702,462 704,461 705,461 705,460 706,458 707,456 708,456 711,456 713,457 714,457 715,456 716,455 715,453 716,451 715,451 714,450 712,449 711,449 711,448 710,448 709,448 707,447 706,448 705,450 705,451 703,451 700,449 699,448 694,448 691,449 690,449 688,450 687,450 686,450 686,451 686,451 683,452 682,453 679,454 678,454 678,454 678,454 676,455 676,455 676,455 673,457 672,458 672,458 671,458 669,458 668,459 666,461 665,461 664,461 661,461 660,461 660,461 659,460 655,460 652,461 649,461 647,458 645,458 645,459 644,459 640,460 638,461 634,463 631,465 631,465 631,466 629,466 627,465 626,464 626,464 624,463 621,463 620,463 618,464 618,465 617,465 617,466 614,471 613,474 613,479 613,484 613,486 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_j = rsr.path("M 615,497 613,495 613,495 613,503 611,507 610,509 609,511 609,512 608,518 608,520 606,522 604,524 603,524 602,524 601,524 601,522 602,520 602,518 602,517 602,516 600,516 599,516 598,518 598,520 597,522 595,523 593,523 591,521 590,521 589,522 588,522 587,525 586,526 585,536 584,538 584,539 586,541 586,541 587,542 589,543 590,546 590,553 591,555 593,558 595,561 599,564 599,565 598,567 597,569 597,571 597,573 598,576 599,577 602,577 602,577 604,577 604,577 605,577 605,580 606,582 606,583 608,583 610,582 612,581 612,581 613,580 614,580 615,579 616,579 616,580 616,584 616,585 618,591 619,595 621,596 622,596 624,597 627,599 629,601 629,601 631,604 631,604 631,604 631,605 630,606 630,606 628,607 627,607 626,608 626,609 627,611 630,615 632,616 632,617 634,620 634,621 634,622 636,626 636,628 638,629 639,629 642,630 644,630 645,630 645,630 649,629 650,629 653,627 655,627 657,628 660,628 661,628 662,628 664,630 666,630 667,631 667,632 669,633 670,633 671,632 672,631 675,627 676,627 677,628 679,629 680,629 682,629 682,630 682,631 681,634 681,635 681,636 684,636 684,636 685,636 686,635 687,634 690,634 691,633 690,632 690,632 687,631 687,630 687,629 688,628 688,626 688,626 688,626 688,625 687,623 687,621 687,621 688,620 688,619 688,618 688,617 689,617 689,616 690,614 692,609 691,606 691,604 691,604 690,604 689,603 687,602 684,599 684,597 683,595 683,590 681,587 681,587 679,586 678,586 677,586 677,586 676,588 675,589 674,590 673,590 672,589 670,587 670,585 673,581 679,576 681,574 682,573 684,572 686,572 687,573 691,575 692,576 694,576 694,576 695,576 697,578 698,578 699,577 700,574 701,573 700,572 699,571 699,570 700,569 700,569 699,568 699,567 700,566 701,564 702,564 703,564 704,563 705,562 704,560 703,558 703,557 705,555 705,553 705,552 705,551 705,551 704,551 702,550 700,550 700,550 699,550 697,552 697,552 695,552 695,551 695,549 695,548 696,546 696,545 696,544 694,544 693,545 691,545 691,545 691,545 690,544 688,544 688,545 686,546 685,548 684,548 682,548 681,547 681,547 682,544 681,543 681,542 680,541 679,541 678,541 677,543 675,543 673,543 672,542 671,539 670,537 668,536 667,536 666,536 663,534 663,533 661,533 660,533 659,533 658,535 657,536 657,536 656,536 655,536 654,536 651,532 648,527 647,525 646,524 644,523 641,524 640,524 639,524 637,525 635,526 634,526 633,526 632,526 630,522 628,519 625,516 624,515 622,511 621,506 621,502 620,501 619,500 617,498 616,497 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_k = rsr.path("M 598,437 599,434 599,432 599,431 598,430 596,430 595,430 593,430 589,431 587,430 586,430 586,429 587,428 589,428 589,427 590,425 589,425 587,423 586,423 580,422 578,421 577,420 577,419 578,418 578,416 580,412 580,412 581,412 583,412 583,412 584,411 585,410 585,408 585,407 584,405 582,404 580,402 579,399 578,395 578,392 577,390 576,389 574,388 574,388 572,388 571,388 570,389 569,390 568,393 567,393 566,393 565,392 564,388 561,382 561,378 561,372 561,368 560,366 559,365 559,363 561,362 561,361 561,360 560,360 559,360 557,360 557,360 556,359 556,355 556,351 557,349 558,348 560,348 562,351 563,351 563,350 563,349 563,348 562,345 561,344 561,344 560,344 557,343 556,343 555,342 554,339 554,336 553,332 552,329 550,327 547,326 547,325 546,325 546,325 544,326 542,327 541,327 541,327 538,328 536,328 534,328 532,328 531,327 529,326 529,324 529,323 529,322 530,321 531,319 531,318 530,317 529,317 528,317 527,317 526,317 525,317 523,317 521,316 521,316 520,315 517,315 515,319 513,321 512,321 510,323 510,323 509,325 508,326 508,328 512,336 512,337 513,342 512,346 512,348 510,352 509,354 508,357 508,360 509,364 511,368 512,369 514,374 514,375 512,377 511,377 509,378 507,381 503,387 502,389 501,391 498,392 496,394 494,397 494,400 492,401 491,401 489,401 486,403 483,408 482,409 481,410 479,412 478,413 477,416 477,417 478,419 479,420 479,421 478,422 478,422 476,422 474,423 473,424 472,425 472,427 473,427 475,429 477,430 478,433 479,435 480,437 482,439 482,440 483,440 487,440 489,440 489,441 489,441 490,441 491,441 493,442 493,442 494,443 496,444 497,445 498,445 498,446 499,446 502,446 502,446 503,447 503,447 505,448 507,450 509,450 510,449 510,449 512,449 512,449 515,450 516,450 517,452 518,454 521,455 522,455 523,454 527,448 528,444 530,442 534,439 537,437 539,435 542,434 544,434 544,435 546,439 547,440 548,443 548,444 549,447 550,450 552,453 554,454 555,455 557,456 560,457 566,457 567,457 570,457 572,457 572,457 573,457 573,457 576,456 580,456 583,455 584,454 588,454 590,454 592,454 594,454 595,453 596,451 598,445 599,443 599,443 598,441 597,440 597,439 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_l = rsr.path("M 527,448 523,454 522,455 522,455 521,455 521,456 521,456 520,457 520,458 520,459 521,460 522,461 524,462 527,463 529,463 530,464 532,465 532,465 532,465 534,466 538,466 540,467 540,468 541,468 541,470 539,472 539,476 539,478 540,483 541,485 542,486 542,486 543,487 543,488 543,489 542,489 540,488 539,488 539,488 539,490 540,493 539,496 539,498 540,498 540,498 541,498 542,499 543,500 544,502 548,504 548,505 549,506 551,506 552,506 552,505 553,505 554,505 554,504 554,504 556,504 557,503 560,504 563,505 563,505 566,506 566,506 567,506 568,507 569,507 569,508 570,508 572,509 578,514 583,521 585,524 586,526 587,525 588,522 589,522 590,521 591,521 593,523 595,523 597,522 598,520 598,518 599,516 600,516 602,516 602,517 602,518 602,520 601,522 601,524 602,524 603,524 604,524 606,522 608,520 608,518 609,512 609,511 610,509 611,507 613,503 613,495 613,495 614,495 613,492 613,486 613,484 613,479 613,474 614,471 617,466 617,465 617,465 616,463 616,463 615,462 615,462 614,461 614,459 613,458 610,457 610,457 609,456 608,451 607,444 606,443 603,442 602,442 602,443 600,443 599,443 599,443 598,445 596,451 595,453 594,454 592,454 590,454 588,454 584,454 583,455 580,456 576,456 573,457 573,457 572,457 572,457 570,457 567,457 566,457 560,457 557,456 555,455 554,454 552,453 550,450 549,447 548,444 548,443 547,440 546,439 544,435 544,434 542,434 539,435 537,437 534,439 530,442 528,444 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_m = rsr.path("M453 501l2 8 0 5 1 6 0 0 1 1 0 0 2 -1 0 0 1 0 5 -1 4 0 5 1 6 0 2 1 2 1 2 0 3 2 0 0 0 0 1 1 1 0 0 0 1 1 2 1 1 1 1 1 1 1 1 0 1 1 0 0 3 3 1 2 0 3 0 2 1 1 2 1 1 0 0 1 1 0 1 1 1 1 1 2 2 0 2 0 1 0 2 -2 2 -3 3 -3 2 -1 2 0 0 0 4 -1 2 0 1 1 1 1 1 1 2 0 1 0 2 -4 2 0 1 0 4 0 1 1 0 1 1 1 1 0 2 0 1 -1 1 0 1 1 1 3 2 1 1 0 0 1 3 0 1 -1 1 -2 2 -6 1 -1 1 -2 1 0 1 -1 2 1 2 1 1 1 3 3 1 0 3 0 0 0 1 0 1 -2 1 -10 -1 -1 0 -1 -2 -3 -5 -7 -6 -5 -2 -1 -1 0 0 -1 -1 0 -1 -1 -1 0 0 0 -3 -1 0 0 -3 -1 -3 -1 -1 1 -2 0 0 0 0 1 -1 0 -1 0 0 1 -1 0 -2 0 -1 -1 0 -1 -4 -2 -1 -2 -1 -1 -1 -1 -1 0 0 0 -1 0 0 -2 1 -3 -1 -3 0 -2 0 0 1 0 2 1 1 0 0 -1 0 -1 -1 -1 0 0 -1 -1 -1 -2 -1 -5 0 -2 0 -4 2 -2 0 -2 -1 0 0 -1 -2 -1 -4 0 -2 -1 0 0 0 0 -2 -1 -1 -1 -2 0 -3 -1 -2 -1 -1 -1 -1 -1 0 -1 0 -1 1 -1 0 0 0 -1 0 0 -3 -1 -1 -2 -1 -2 -1 0 -3 -1 0 0 -2 0 0 0 -1 1 -2 0 -2 -2 -2 -1 0 0 -1 -1 0 0 -3 0 -1 0 0 0 0 0 0 0 -2 2 0 2 -1 0 -1 1 0 0 -3 0 -1 0 -1 2 -1 0 -6 0 -1 0 0 1 -1 0 -2 2 1 1 0 1 1 2 0 1 -2 1 -2 2 -2 1 -1 1 -3 4 -2 0 -2 1 -4 -1 -1 1 0 1 1 2 1 2 0 1 -1 0 -4 0 -1 1 -1 0 0 2 1 1 3 2 1 1 1 0 2 1 1 1 1 1 0 2 -1 1 -1 0 -3 1 -1 0 -1 1 0 0 0 0 -1 0 -2 1 -2 1 -1 1 0 2 0 4zm46 -55l0 0z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_n = rsr.path("M571 640l0 1 1 2 0 2 0 1 0 0 -1 0 -1 1 -1 0 0 2 1 2 1 3 0 1 -1 1 -2 0 -1 2 0 1 0 2 0 0 3 3 -2 3 1 2 -1 2 -3 -1 -2 3 2 2 -3 2 -1 1 2 1 3 3 3 3 2 0 2 2 2 -1 2 2 3 3 2 1 2 0 1 2 4 2 3 -1 3 -3 1 0 3 -3 0 0 2 -2 -2 -2 6 -4 0 -1 0 0 0 -2 1 -1 2 0 0 -1 9 -5 -1 -1 -4 0 -3 -3 2 -1 1 -2 0 -2 0 0 0 -2 0 -1 -3 0 0 0 -3 0 -1 0 -1 -2 0 -1 2 -2 0 0 0 -2 -1 -3 -3 -6 -1 -2 -1 -1 -1 -2 -1 0 -1 -1 -1 0 -3 -1 -1 0 0 0 -1 0 -2 0 0 0 -1 0 0 0 0 1 -1 0 -2 1 -1 0 -1 -1 -1 0 0 0 0 0 0 1 -1 0 -1 0 -1 -1 0 0 -1 0 -1 0 0 1 -1 0 -1 -1 -1 1 -1 0 0 -1 0 0 -1 0 -1 1 0 0 0 -1 0 1 0 2zm13 21l2 0 0 4 1 2 6 1 -2 3 2 1 1 0 2 1 2 0 -3 4 -1 1 -1 0 -1 -1 -2 3 2 5 -3 0 -2 -4 -6 -1 -3 -3 -4 -1 0 -3 4 0 0 -2 -3 -1 0 -4 2 0 1 -2 6 -3z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_o = rsr.path("M 494,581 494,585 494,591 495,593 496,594 497,596 497,599 497,600 501,604 501,604 502,607 504,610 504,612 503,616 502,620 502,623 502,625 503,627 504,629 505,629 506,630 506,631 506,632 506,632 504,634 503,636 503,638 503,639 505,641 506,645 506,645 507,647 509,647 511,649 512,650 513,650 513,650 514,652 514,654 513,654 512,655 512,655 511,655 511,656 511,658 512,661 512,662 512,663 511,665 510,666 509,666 508,666 508,666 507,667 506,667 505,668 505,669 506,669 507,669 508,670 511,670 512,670 514,668 514,668 518,664 522,662 523,662 525,662 526,663 527,665 529,666 530,666 531,666 530,664 530,663 532,662 533,662 535,662 537,662 540,663 541,662 542,661 544,658 546,656 547,656 548,659 548,659 549,659 550,658 552,658 553,659 555,660 556,660 559,662 560,662 561,662 561,661 562,661 562,661 563,661 563,662 563,662 564,662 566,662 567,662 567,662 567,661 567,661 567,659 567,658 568,656 570,656 571,655 571,654 570,651 569,649 569,647 570,647 571,646 572,646 572,646 572,645 572,643 571,641 571,640 569,640 568,638 571,634 570,633 569,631 568,631 566,628 565,627 564,626 563,626 562,626 560,626 559,625 558,625 558,623 557,619 558,618 559,615 559,613 558,610 557,607 555,605 554,604 553,604 553,604 550,603 549,603 548,601 548,599 547,591 546,589 544,587 540,582 535,577 535,576 534,574 534,573 535,572 536,571 537,569 537,567 536,565 534,563 534,562 533,561 530,559 528,556 528,554 528,552 528,549 529,547 528,543 527,539 527,539 525,539 523,540 520,543 518,546 516,548 515,548 513,548 511,548 511,558 510,561 507,567 507,571 506,577 505,578 505,579 504,579 503,580 502,581 501,583 500,584 499,584 498,582 496,579 495,578 494,579 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_p = rsr.path("M 540,582 544,587 546,589 547,591 548,599 548,601 549,603 550,603 553,604 553,604 554,604 555,605 557,607 558,610 559,613 559,615 558,618 557,619 558,623 558,625 559,625 560,626 562,626 563,626 564,626 565,627 566,628 568,631 569,631 570,633 571,634 568,638 569,640 571,640 571,638 571,637 571,638 571,638 572,637 573,637 573,637 573,638 574,638 575,637 576,638 577,638 577,637 578,637 579,637 579,637 580,638 581,638 582,638 582,637 582,637 582,637 583,637 584,638 585,638 587,637 588,637 588,636 588,636 589,636 589,636 591,636 592,636 592,636 593,636 596,637 597,637 598,638 599,638 600,640 600,638 600,638 600,638 602,636 604,634 606,630 607,629 609,630 609,630 611,630 613,630 613,629 614,629 615,629 616,628 622,628 624,627 625,627 625,626 626,623 627,622 628,622 630,622 631,621 634,621 634,620 632,617 632,616 630,615 627,611 626,609 626,608 627,607 628,607 630,606 630,606 631,605 631,604 631,604 631,604 629,601 629,601 627,599 624,597 622,596 621,596 619,595 618,591 616,585 616,584 616,580 616,579 615,579 614,580 613,580 612,581 612,581 610,582 608,583 606,583 606,582 605,580 605,577 604,577 604,577 602,577 602,577 599,577 598,576 597,573 597,571 597,569 598,567 599,565 599,564 595,561 593,558 591,555 590,553 590,546 589,543 587,542 586,541 586,541 584,539 584,538 583,538 583,538 583,538 580,538 579,538 576,535 575,534 573,533 571,532 570,533 569,533 568,535 567,536 565,542 564,544 563,545 560,545 560,544 559,544 557,543 556,540 555,539 554,539 553,540 551,540 550,540 549,539 549,538 548,537 544,537 543,537 541,537 539,541 538,541 536,541 535,540 534,539 533,538 531,538 527,539 527,539 527,539 528,543 529,547 528,549 528,552 528,554 528,556 530,559 533,561 534,562 534,563 536,565 537,567 537,569 536,571 535,572 534,573 534,574 535,576 535,577 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_q = rsr.path("M726 467l-2 3 -1 1 -1 1 -1 -1 -1 0 -1 -4 0 -2 1 -2 0 -1 0 -3 -3 -3 -1 -1 -1 1 -1 1 -1 0 -2 -1 -3 0 -1 0 -1 2 -1 2 0 1 -1 0 -2 1 -2 1 -2 1 -2 1 0 0 -1 1 -1 0 -1 -1 0 0 -1 0 0 0 -1 0 0 1 1 0 0 0 0 0 0 1 0 0 0 0 -2 1 0 1 0 0 0 1 0 1 0 2 1 0 0 1 0 3 0 0 1 2 1 1 0 0 -1 1 1 1 0 0 0 0 1 1 0 2 0 1 0 1 0 1 1 0 1 1 -1 3 1 1 3 0 0 1 0 1 1 1 -1 0 1 2 0 1 0 1 1 1 0 0 1 2 1 1 0 1 0 0 0 1 -1 1 1 1 0 1 0 1 1 0 0 1 1 1 0 1 1 0 0 1 1 0 0 1 1 1 0 1 1 0 0 0 1 0 1 0 1 0 0 1 0 0 0 1 1 0 0 2 0 0 0 0 1 0 1 1 0 0 1 1 0 0 1 0 1 0 0 0 0 1 -1 0 0 0 0 1 0 0 1 1 0 0 0 1 1 2 0 0 0 0 -2 1 0 1 0 0 0 1 1 0 1 1 -1 1 0 1 0 0 0 1 0 0 1 1 1 -1 0 0 1 1 1 1 3 3 1 1 3 2 1 0 3 1 2 1 0 1 2 4 1 -1 1 -1 0 0 0 1 0 0 2 -1 1 0 0 1 0 0 1 1 0 1 0 0 1 0 1 1 1 0 1 0 0 0 1 0 1 0 1 0 0 0 1 -1 0 -1 0 -1 0 0 1 0 1 1 2 1 1 0 1 0 1 1 2 0 0 0 2 -1 3 0 1 0 0 0 0 0 0 -1 1 -1 0 0 1 0 1 0 0 0 2 -2 2 0 1 0 0 0 2 0 2 1 2 1 0 0 0 0 1 0 0 -1 0 -1 0 -1 1 -1 3 -3 -2 0c-3,0 -3,-2 -4,-4 0,-1 0,0 -1,-1 0,0 0,0 0,-1 0,0 0,0 -1,0 0,0 1,0 1,0 0,0 1,-1 1,-1 0,0 -1,0 -1,-1 0,0 1,1 1,0 -1,-1 0,-1 0,-2 0,0 -1,-1 -1,-2 0,-1 -1,0 -1,-1 1,0 1,-1 1,-1 0,-1 -1,1 -1,1 -1,0 -1,-1 -1,-1 -1,-1 0,0 0,0 -1,0 -1,0 -2,0 0,-1 0,-1 0,-1 0,0 0,-1 0,-1 -1,0 -4,-2 -3,-3 2,-1 2,-2 4,-2 0,1 2,0 3,-1 0,-1 1,-1 1,-1 1,-1 -1,-1 -1,-1 0,0 1,0 1,-1 0,-1 -1,0 0,-2 0,-1 -1,-4 -1,-4 0,-1 1,0 1,-1 0,0 -1,-1 -1,-1 0,0 1,-1 1,-1 0,0 -1,0 -1,0 1,-3 0,-1 -1,-3 0,0 0,0 0,-1 0,0 -1,0 -1,-1 0,0 2,-2 1,-3 0,0 -1,1 -1,1 -1,0 -2,-1 -2,-2 0,0 -1,1 0,0 0,-1 0,0 0,0l0 -3c0,0 -1,0 -1,0 1,-1 0,-3 0,-3 1,-1 1,-1 0,-2 0,0 0,0 0,-1 1,0 1,0 2,0 0,0 0,-1 0,-2 0,0 1,0 0,-1 0,0 -1,1 -1,0 0,-1 -1,-2 0,-2 0,0 0,0 0,0 0,-1 0,-1 0,-1 0,-1 1,-1 1,-2 -1,-1 -1,-1 -1,-2 0,-1 -1,-4 -1,-4 -1,-1 0,-1 0,-1 0,0 -1,0 -1,0 0,0 1,-1 1,-2 0,0 -1,0 -1,0 0,0 0,-1 0,-2 0,0 -1,0 -1,0l1 -1c0,0 -1,0 -1,-1l1 -1c0,-2 1,-2 1,-2 -1,0 0,-1 0,-1 0,0 -1,0 -1,0 0,0 0,0 -1,-1 1,0 1,0 1,0 0,-1 -1,-1 -1,-1 1,-3 2,-1 2,-1 0,-1 0,-2 0,-3 0,0 1,0 1,-1 1,0 -1,0 0,-1 0,0 1,1 1,0 0,-1 0,-1 0,-1l-1 0 -2 -1 -2 0 -5 0 -1 -1 -3 0 -3 -1 -1 -1 -2 -1 -1 -1 -1 1 0 0 -3 2 -1 1 -1 0 0 0 -4 0 -2 -1 -3 0 -5 1 -1 0 -1 0 -1 2 -1 5 -2 4 -2 1z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_r = rsr.path("M858 645l3 -5 1 0 1 -1 3 -3 1 -1 0 0 3 -2 3 -1 6 -2 2 0 2 -1 1 0 2 0 1 -1 1 1 3 -1 2 0 2 0 2 -1 3 0 3 -1 2 0 3 0 2 0 1 -2 2 0 0 0 1 -1 0 -1 0 0 1 -1 0 0 0 -1 -1 -2 0 0 0 -1 0 0 0 0 1 0 0 1 0 -1 2 -10 1 -3 0 -1 0 -1 0 -5 1 -4 1 -7 1 -3 0 -1 -1 1 -1 -1 -1 0 0 -1 -1 -2 -1 -4 0 -1 0 0 3 2 1 0 0 -2 0 0 0 -1 -1 -1 0 -1 0 -1 0 -1 1 0 0 -1 0 -1 0 -1 0 -1 0 -1 0 -1 -1 -2 0 -1 -1 -1 -1 -1 0 0 0 -1 -2 -2 -2 -2 -2 -1 -1 -1 -1 -1 -1 0 -1 0 -1 -1 -2 0 -2 -1 -2 0 -2 -2 -1 0 -3 0 -3 0 -1 0 -1 0 0 0 -1 0 -1 0 0 0 -1 1 0 0 0 0 0 0 0 0 -3 0 -1 0 -1 1 0 0 -1 0 0 0 0 0 -2 1 -1 0 -1 1 0 0 -1 0 0 0 -1 1 0 1 -1 0 -1 1 -1 0 0 0 -1 1 -1 0 -2 -1 -1 0 -1 0 -1 1 -1 0 0 1 -1 0 0 1 -1 0 0 0 -2 0 0 0 -2 1 -1 0 0 1 -1 1 0 0 -1 2 -1 0 0 1 0 0 0 1 0 1 0 1 0 1 -1 0 0 1 -2 0 0 -1 -2 -2 0 0 -1 0 0 -1 -2 -1 -1 0 -1 -1 -3 -1 -1 0 -2 0 0 1 0 1 1 0 1 1 0 1 -1 1 -1 1 -1 0 -1 0 0 1 0 0 0 1 1 1 1 1 0 1 0 1 -1 0 -1 1 -2 0 -1 1 -2 0 -3 -1 -2 -1 -2 -1 -2 0 -3 0 -1 0 -1 -1 -1 0 -1 -1 -2 0 -3 -2 0 0 -1 -1 -2 0 -2 -1 -2 -1 -1 0 -2 -1 -1 -1 -2 0 -1 -1 -1 -2 -1 -3 -1 -1 -2 -2 0 -2 0 -2 0 -1 0 -2 -1 -1 0 0 0 -1 -1 0 -1 0 0 0 -1 0 -1 -1 0 0 -3 3 -1 1 0 1 0 1 0 1 -1 0 0 0 0 0 -2 -1 -2 -1 -2 0 0 0 -1 0 -2 0 -2 2 0 0 -1 0 -1 0 0 0 -1 1 0 1 0 0 -1 1 0 2 0 4 0 0 -1 2 -1 2 0 1 0 0 0 1 -1 1 1 1 0 1 4 3 1 0 2 1 1 -1 2 0 1 0 0 0 1 1 0 1 0 1 -1 1 0 0 -1 2 -1 1 0 2 0 0 1 1 1 0 3 2 0 1 1 0 0 1 2 1 0 1 -1 1 0 0 0 1 0 2 -1 0 0 0 0 0 -2 0 0 0 0 1 0 0 -1 1 1 1 0 2 0 1 0 2 0 0 0 1 0 1 -1 1 0 0 0 1 0 1 0 0 0 0 1 2 0 0 0 1 0 1 0 0 0 1 0 0 -1 1 0 1 0 1 0 1 -1 2 0 1 1 1 0 1 0 1 0 0 0 1 -1 0 -2 2 0 0 -1 1 0 1 -1 2 0 1 0 1 0 3 4 1 0 0 1 0 0 0 1 1 1 1 1 1 0 3 0 0 1 0 1 0 2 -2 2 0 1 0 1 -1 2 1 1 0 1 1 2 1 2 3 1 2 0 3 0 2 1 0 1 0 0 3 0 0 1 1 0 -1 1 -2 2 -5 1 -2 1 1 0 1 3 4 1 0 1 1 1 0 1 0 1 0 1 -2 1 0 2 0 1 0 3 1 4 0 1 -1 2 -1 1 0 0 0 1 2 0 1 1 0 1 -2 2 0 4 0 0 2 0 2 1 0c0,0 0,0 0,0 1,0 5,0 6,-1 1,-1 2,-3 4,-4 0,0 1,-1 1,-1 0,0 0,0 0,-1l2 -1c1,0 2,0 2,0 1,1 1,1 1,1 1,0 2,0 3,1l1 1 1 -1z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_s = rsr.path("M856 645c-1,-1 -2,-1 -3,-1 0,0 0,0 -1,-1 0,0 -1,0 -2,0l-2 1c0,1 0,1 0,1 0,0 -1,1 -1,1 -2,1 -3,3 -4,4 -1,1 -5,1 -6,1 0,0 0,0 0,0l-1 0 0 -2 0 -2 -4 0 -2 0 -1 2 -1 0 0 -1 -1 -2 0 0 -1 0 -2 1 -1 1 -4 0 -3 -1 -1 0 -2 0 -1 0 -1 2 -1 0 -1 0 -1 0 -1 -1 -1 0 -3 -4 0 -1 -1 -1 -1 2 -2 5 -1 2 0 1 -1 -1 0 0 0 -3 -1 0 -1 0 0 -2 0 -3 -1 -2 -2 -3 -2 -1 -1 -1 -1 0 -2 -1 -1 1 -1 0 -2 0 -2 2 -1 0 -1 0 0 0 0 -3 -1 -1 -1 -1 -1 -1 0 0 -1 0 0 0 -4 -1 0 0 -1 1 0 1 -1 1 -1 1 0 0 -1 1 -1 0 -1 0 0 0 -2 0 -2 -2 0 -1 -2 0 -2 1 -1 0 -1 0 -1 1 -1 1 0 0 0 0 0 1 0 0 -1 1 0 0 1 1 0 3 1 0 0 0 2 1 0 0 1 1 0 1 1 0 1 1 2 0 1 0 1 1 2 2 1 2 0 1 1 1 0 1 0 0 0 2 -1 2 0 3 0 0 2 2 0 0 0 2 0 0 0 1 1 1 1 1 0 1 1 0 2 1 0 1 0 1 1 4 1 1 -1 1 0 0 -1 2 0 0 0 0 -2 2 -1 0 0 1 0 1 0 1 -1 0 0 1 -1 1 -2 1 0 0 -1 3 0 0 0 1 0 1 -1 2 -1 2 -1 1 0 0 -1 1 0 0 -1 1 -2 1 0 1 -1 0 -3 0 -3 1 -1 0 0 0 -2 -1 0 1 -2 0 -2 1 0 2 -1 0 -1 1 0 -1 -1 1 -1 1 -2 1 -2 0 -1 0 -2 0 -2 0 -3 -1 -1 0 0 0 -2 1 -2 1 -1 1 -1 1 -1 1 -3 1 0 1 -3 2 -1 1 0 0 -1 0 -2 0 -1 -1 -2 0 -2 0 -1 0 -1 0 -2 0 -2 -1 -1 1 -1 0 -1 1 1 0 0 0 1 1 0 1 0 1 0 1 0 1 2 2 0 0 2 0 2 1 1 0 1 2 1 1 0 1 2 1 1 1 2 0 2 -1 2 0 1 0 1 0 2 0 2 1 2 0 2 0 2 0 1 0 1 -1 1 -2 0 0 1 0 1 1 2 2 0 1 1 1 0 2 0 1 1 1 1 1 1 1 1 0 1 0 2 0 2 0 1 -1 2 0 1 0 1 0 1 -1 1 -1 1 -1 1 -1 1 -1 1 0 1 0 1 1 1 1 0 2 1 2 0 2 1 2 1 2 0 2 1 3 0 1 1 1 1 2 0 0 1 1 3 1 4 2 6 3 1 0 2 1 1 0 2 1 2 1 2 0 6 1 3 1 3 1 2 1 1 0 2 0 3 1 2 0 1 0 2 0 2 0 1 0 2 0 0 -1 -1 -2 1 -1 0 -3 0 -2 1 -1 0 -1 0 -1 0 0 0 -1 0 0 0 -1 0 -1 1 0 0 -1 0 -1 0 -1 0 -1 1 -3 1 -2 1 -1 0 -1 0 -1 0 -1 0 -1 3 -5 0 -1 0 -1 -1 -4 -1 -3 0 -1 0 -1 1 -3 -1 -1 0 -4 -1 0 0 -2 0 -1 0 0 0 0 2 -2 0 0 0 0 1 0 0 0 0 -1 -1 0 0 -1 0 0 0 -1 -1 -2 -1 -1 0 -1 -1 -7 0 -3 0 -1 2 -2 0 0 0 -1 1 -1 1 0 0 0 2 -1 0 0 1 -2 1 -1 0 -1 2 -3 5 -6 4 -4 1 -1 1 -1 0 -1 5 -6 1 -4 1 -1 1 -2 0 0 0 -1 1 -1 0 -1 0 0 1 -2 1 -1 3 -4 0 0 -1 -1z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_t = rsr.path("M 619,729 620,729 621,729 623,728 626,727 628,726 629,726 631,727 633,727 634,727 636,726 638,726 639,725 641,724 642,724 643,724 644,724 645,724 647,724 649,723 652,721 654,720 656,719 656,718 658,718 659,717 660,717 662,717 663,717 663,717 665,717 666,717 667,716 668,716 669,716 670,716 671,716 672,715 674,715 675,716 676,716 677,716 678,716 680,716 681,716 682,715 684,716 685,717 686,717 686,718 688,718 689,719 691,719 692,718 694,718 695,717 695,718 696,717 697,717 698,716 700,717 702,717 703,717 704,717 706,717 708,717 709,718 711,718 712,718 712,718 713,717 716,715 716,714 719,713 720,712 721,711 722,710 724,709 726,708 726,708 727,708 730,709 732,709 734,709 735,709 737,709 739,708 740,707 741,706 741,707 742,706 743,706 743,704 745,703 747,703 747,702 749,703 749,703 750,703 753,702 756,702 757,702 757,701 759,700 760,699 760,699 761,698 761,698 762,697 763,695 764,693 764,692 764,691 763,691 763,691 760,690 759,690 758,689 754,687 751,686 750,686 749,686 748,687 748,688 748,688 747,689 745,687 742,686 739,684 738,682 737,681 737,681 735,679 731,678 730,676 730,675 729,674 728,673 724,672 724,673 723,674 723,675 722,676 722,676 721,676 720,675 720,670 719,668 719,666 719,666 718,667 718,668 715,671 715,671 713,671 713,671 712,672 712,674 711,675 709,675 709,674 709,671 706,671 706,669 704,668 703,668 702,669 701,670 699,671 698,671 696,670 696,670 696,670 695,670 693,669 691,669 689,669 689,670 687,669 685,669 684,668 682,668 681,668 681,668 679,669 678,668 677,668 677,664 676,664 673,663 673,663 671,662 669,662 667,663 665,663 661,663 659,663 658,664 657,664 657,663 657,662 657,660 656,660 654,661 653,663 650,667 649,669 645,671 645,671 644,672 641,672 639,672 638,673 638,674 637,675 636,674 634,673 633,672 632,671 629,666 630,662 627,663 624,660 623,660 621,660 617,662 615,662 612,662 612,664 611,666 609,667 612,670 616,670 617,671 608,676 608,677 606,677 605,678 605,680 605,680 605,681 599,685 601,687 599,689 600,690 604,693 607,696 609,696 610,696 610,697 611,698 613,698 614,700 616,701 617,703 617,704 617,707 618,708 619,709 619,710 621,712 621,713 621,714 621,715 619,716 618,717 617,717 616,718 616,719 616,720 617,723 616,725 616,727 616,727 617,729 617,729 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_u = rsr.path("M 617,729 616,727 616,727 616,725 617,723 616,720 616,719 616,718 617,717 618,717 619,716 621,715 621,714 621,713 621,712 619,710 619,709 618,708 617,707 617,704 617,703 616,701 614,700 613,698 611,698 610,697 610,696 609,696 607,696 604,693 600,690 599,689 596,692 595,692 592,695 589,696 585,694 584,692 582,692 580,691 577,688 575,686 573,687 571,685 569,685 566,682 563,679 561,678 562,677 565,675 563,673 565,670 568,671 569,669 568,667 570,664 567,661 567,662 567,662 566,662 564,662 563,662 563,662 563,661 562,661 562,661 561,661 561,662 560,662 559,662 556,660 555,660 553,659 552,658 550,658 549,659 548,659 548,659 547,656 546,656 544,658 542,661 541,662 540,663 537,662 535,662 533,662 532,662 530,663 530,664 531,666 530,666 531,666 531,669 530,671 528,673 527,674 525,675 525,677 524,678 525,680 525,681 527,682 528,682 529,683 529,683 529,685 529,685 529,686 529,687 531,688 533,688 535,688 536,687 537,687 541,687 543,689 544,690 545,691 546,696 546,698 547,699 548,701 549,706 549,709 548,711 548,711 545,712 544,712 544,714 543,716 542,717 541,717 539,717 538,718 538,718 538,719 537,720 537,722 537,725 538,727 538,729 541,735 543,740 543,743 542,748 542,750 542,751 543,753 546,756 546,759 546,767 545,773 546,774 547,774 548,774 549,775 551,774 552,774 553,773 554,773 555,772 556,772 557,770 558,768 559,767 560,767 561,766 563,766 564,765 564,764 565,763 566,762 566,761 567,760 568,758 569,757 569,756 571,754 571,753 574,751 575,751 576,749 577,749 579,748 582,746 582,746 582,745 583,743 583,742 584,741 586,739 587,738 588,737 590,736 591,736 593,736 594,736 596,736 597,735 599,734 599,734 601,733 602,732 603,731 604,731 606,730 607,730 609,729 610,729 611,729 612,728 613,728 614,729 616,729 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_v = rsr.path("M 692,609 690,614 689,616 689,617 688,617 688,618 688,619 688,620 687,621 687,621 687,623 688,625 688,626 688,626 690,627 691,627 693,630 694,632 695,632 696,632 698,627 701,625 702,624 703,624 706,627 707,628 709,631 711,632 713,633 713,632 713,632 714,630 713,629 713,628 713,627 713,626 714,626 715,627 715,627 717,629 718,630 724,631 725,631 730,631 732,632 732,632 733,632 734,633 735,634 738,634 738,634 740,633 740,632 741,630 743,628 744,628 746,628 746,628 746,629 746,631 746,632 746,633 747,634 748,634 751,635 751,635 752,636 752,636 753,635 754,634 755,634 756,634 758,633 760,633 760,634 762,636 764,636 764,636 765,636 766,636 767,635 767,635 768,634 769,633 769,632 770,631 770,631 770,628 770,627 770,626 771,624 771,623 772,622 772,622 774,620 775,620 775,619 775,619 775,618 775,617 774,616 774,615 775,613 775,612 775,611 775,610 776,609 776,609 776,608 776,608 776,607 776,606 776,606 775,604 775,604 775,604 775,603 775,602 775,602 776,601 776,600 776,599 776,599 776,597 776,596 776,594 775,593 776,592 776,592 776,591 776,591 778,591 778,591 778,591 779,591 779,589 779,588 779,588 780,587 780,586 778,585 778,584 777,584 777,583 774,581 773,581 772,580 772,580 772,578 773,577 774,575 774,575 775,574 775,573 775,572 774,571 774,571 773,571 771,571 770,572 768,571 767,571 763,568 763,567 762,566 763,565 763,564 763,564 763,563 764,561 765,559 765,559 765,555 765,553 766,552 766,552 765,552 762,552 760,553 760,553 758,553 757,552 756,552 755,552 753,551 752,550 751,550 751,550 751,551 751,552 750,553 750,553 749,553 748,553 747,553 747,553 746,553 745,553 744,552 743,552 743,552 743,551 742,550 742,550 742,549 741,549 739,550 739,550 739,549 739,549 738,550 737,551 735,547 735,546 733,545 730,544 729,544 726,542 725,541 722,538 721,537 718,538 717,538 716,539 716,539 714,540 713,540 712,541 710,542 708,543 707,545 705,549 705,551 705,552 705,553 705,555 703,557 703,558 704,560 705,562 704,563 703,564 702,564 701,564 700,566 699,567 699,568 700,569 700,569 699,570 699,571 700,572 701,573 700,574 699,577 698,578 697,578 695,576 694,576 694,576 692,576 691,575 687,573 686,572 684,572 682,573 681,574 679,576 673,581 670,585 670,587 672,589 673,590 674,590 675,589 676,588 677,586 677,586 678,586 679,586 681,587 681,587 683,590 683,595 684,597 684,599 687,602 689,603 690,604 691,604 691,604 691,606 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_w = rsr.path("M 450,638 448,637 447,637 446,635 445,633 445,629 445,625 446,618 445,616 444,615 442,615 442,615 440,616 438,618 435,622 434,623 432,623 432,622 432,621 433,619 432,618 431,617 431,616 432,613 432,612 432,611 431,610 430,610 429,612 428,614 424,617 421,620 419,622 417,625 416,628 416,631 416,632 416,634 416,635 416,636 415,637 415,639 415,641 415,643 416,644 417,646 417,648 417,649 416,649 417,650 417,651 418,652 417,653 418,653 419,654 419,655 419,656 420,657 419,657 418,658 417,658 416,658 414,656 414,656 413,655 412,655 411,656 410,659 410,659 409,661 407,662 405,662 403,662 402,661 401,661 400,662 399,664 398,664 396,664 395,663 394,662 393,662 390,662 388,663 387,663 387,663 386,664 385,665 382,667 379,670 378,671 378,672 379,673 380,674 381,675 381,675 382,676 384,677 385,677 386,677 387,677 387,677 388,678 389,679 390,680 391,685 392,687 393,687 394,689 396,690 398,690 399,690 400,691 402,691 405,693 407,695 408,697 410,699 411,700 412,703 411,710 410,712 409,714 410,715 410,716 411,716 411,716 412,717 413,717 414,718 415,718 416,720 415,721 413,721 411,721 410,721 409,722 408,723 407,728 407,730 407,731 407,731 408,731 408,731 408,732 410,732 411,734 412,735 412,737 412,738 411,739 410,739 409,739 409,741 411,742 411,744 410,748 409,749 408,750 405,750 405,751 406,752 407,752 408,753 408,755 408,755 407,756 406,756 405,757 404,758 403,759 402,761 401,766 400,769 400,769 400,769 399,774 401,774 402,774 403,775 404,776 405,776 406,776 408,776 409,775 410,775 411,775 412,775 414,775 414,774 415,774 416,774 417,774 418,774 419,774 421,774 422,774 425,772 426,772 427,771 429,769 430,769 431,768 433,767 434,766 435,766 436,766 438,765 439,765 440,766 440,766 441,766 443,766 445,767 446,767 448,768 449,769 451,771 453,771 453,771 453,770 453,770 453,769 453,768 455,764 457,763 459,762 459,762 460,762 461,762 462,762 462,761 463,760 462,759 458,756 457,755 455,753 454,752 454,751 454,747 453,744 453,740 452,739 451,738 446,738 445,737 444,736 445,735 446,734 447,733 449,731 450,731 450,730 452,730 454,730 455,730 455,729 455,727 456,726 457,725 458,724 458,724 459,724 462,722 462,722 464,722 466,722 468,723 469,722 470,721 470,720 469,719 466,715 465,713 465,710 466,705 468,702 469,698 469,696 468,690 468,687 469,685 470,684 472,683 474,682 475,681 476,680 476,679 475,679 474,679 473,679 469,679 466,679 462,679 462,679 461,679 461,679 459,677 459,676 459,672 458,671 457,670 457,669 458,668 458,669 459,669 460,669 461,669 461,666 461,663 461,661 460,660 459,658 459,657 458,655 458,649 457,647 457,645 456,642 457,641 458,641 458,640 458,637 457,637 456,636 455,636 454,637 453,637 453,637 452,637 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_x = rsr.path("M 477,679 476,679 476,680 475,681 474,682 472,683 470,684 469,685 468,687 468,690 469,696 469,698 468,702 466,705 465,710 465,713 466,715 469,719 470,720 470,721 469,722 468,723 466,722 464,722 462,722 462,722 459,724 458,724 458,724 457,725 456,726 455,727 455,729 455,730 454,730 452,730 450,730 450,731 449,731 447,733 446,734 445,735 444,736 445,737 446,738 451,738 452,739 453,740 453,744 454,747 454,751 454,752 455,753 457,755 458,756 462,759 463,760 462,761 462,762 461,762 460,762 459,762 459,762 457,763 455,764 453,768 453,769 453,770 453,771 454,772 455,772 457,772 458,772 459,772 461,772 462,772 462,772 464,772 465,772 466,771 468,772 469,772 470,773 472,772 473,772 475,771 477,771 478,770 480,770 481,770 482,770 483,770 485,772 486,773 488,774 490,775 492,775 493,775 494,775 495,775 496,774 498,774 499,774 500,774 502,775 505,775 507,776 509,778 510,779 512,780 513,781 514,782 515,783 517,784 518,784 518,784 521,784 524,783 525,782 527,782 528,781 529,781 530,781 532,781 535,781 537,781 541,777 543,776 544,775 545,775 546,774 546,774 545,773 546,767 546,759 546,756 543,753 542,751 542,750 542,748 543,743 543,740 541,735 538,729 538,727 537,725 537,722 537,720 538,719 538,718 538,718 539,717 541,717 542,717 543,716 544,714 544,712 545,712 548,711 548,711 549,709 549,706 548,701 547,699 546,698 546,696 545,691 544,690 543,689 541,687 537,687 536,687 535,688 533,688 531,688 529,687 529,686 529,685 529,685 529,683 529,683 528,682 527,682 525,681 525,680 524,678 525,677 525,675 527,674 528,673 530,671 531,669 531,666 530,666 529,666 527,665 526,663 525,662 523,662 522,662 518,664 514,668 514,668 512,670 511,670 508,670 507,669 506,669 505,669 504,669 503,669 501,671 499,672 498,674 497,675 496,676 495,676 495,676 494,676 493,676 491,676 490,676 488,676 485,677 484,677 482,678 481,678 480,678 478,678 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_y = rsr.path("M 327,664 325,665 322,666 321,666 320,667 319,670 317,671 317,671 316,672 315,672 315,673 313,673 312,674 312,676 311,681 312,682 313,682 314,682 316,682 316,682 317,682 317,684 315,685 312,688 311,689 310,692 309,693 308,694 307,695 305,697 305,698 305,699 305,700 307,703 308,705 308,708 308,713 307,715 306,716 304,716 303,715 302,714 301,714 300,714 299,715 297,719 295,721 295,721 295,722 296,721 297,722 299,724 299,725 299,726 299,727 298,729 297,731 296,732 295,732 294,733 293,734 291,734 290,734 289,735 288,735 287,735 286,735 285,736 285,737 284,738 284,739 283,741 282,743 282,745 281,748 281,749 281,750 281,752 282,753 283,754 283,755 284,756 286,756 287,757 289,757 290,758 293,759 294,759 296,760 298,760 300,760 302,760 304,760 306,760 306,760 307,759 308,759 309,759 311,758 313,757 315,756 316,756 318,755 319,755 321,754 322,754 323,754 324,754 326,754 328,754 329,754 331,754 332,754 334,754 335,753 336,753 337,754 338,754 339,754 340,754 340,755 341,755 343,756 344,756 346,758 348,759 350,760 352,761 353,761 354,761 356,761 359,760 359,760 361,760 362,759 365,760 366,760 366,760 368,762 370,763 371,763 372,763 373,764 375,765 378,766 379,767 379,767 380,767 381,767 383,767 386,767 387,768 387,768 388,768 390,769 391,770 392,770 393,771 394,771 395,772 396,772 397,772 397,773 399,774 399,774 400,769 401,766 402,761 403,759 404,758 405,757 406,756 407,756 408,755 408,755 408,753 407,752 406,752 405,751 405,750 408,750 409,749 410,748 411,744 411,742 409,741 409,739 410,739 411,739 412,738 412,737 412,735 411,734 410,732 408,732 408,731 408,731 407,731 407,731 407,730 407,728 408,723 409,722 410,721 411,721 413,721 415,721 416,720 415,718 414,718 413,717 412,717 411,716 411,716 410,716 410,715 409,714 410,712 411,710 412,703 411,700 410,699 408,697 407,695 405,693 402,691 400,691 399,690 398,690 396,690 394,689 393,687 392,687 391,685 390,680 389,679 388,678 387,677 387,677 386,677 385,677 384,677 382,676 381,675 381,675 380,674 379,673 378,672 378,671 379,670 382,667 385,665 386,664 387,663 386,663 385,661 383,656 382,650 381,649 380,648 378,647 377,647 376,646 375,645 375,643 374,637 374,637 374,637 371,637 370,637 367,641 365,647 364,650 363,653 362,654 360,655 357,656 353,656 350,655 346,655 344,656 340,657 340,657 340,657 339,659 339,661 339,662 337,664 336,664 336,664 332,664 331,665 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_z = rsr.path("M 393,528 394,528 395,528 396,528 397,527 400,527 403,527 403,526 405,526 405,526 407,526 409,525 409,525 410,525 412,525 413,525 414,524 415,524 416,524 416,524 418,524 419,523 421,523 430,523 435,523 441,525 441,524 443,524 444,524 449,524 449,523 453,523 456,521 456,521 456,520 456,520 455,514 455,509 453,501 453,497 453,495 454,494 456,493 458,492 459,492 459,492 459,492 460,491 461,491 464,490 465,490 466,489 466,487 465,486 464,485 462,484 461,484 460,483 457,481 456,480 456,478 457,478 458,477 462,477 463,477 463,476 462,474 461,472 461,471 462,470 466,471 468,470 470,470 473,466 474,465 476,464 478,462 480,461 480,460 479,458 479,457 478,456 478,456 475,455 474,454 472,451 472,451 470,451 470,451 469,452 467,452 465,452 464,452 464,452 463,452 462,453 460,455 458,455 456,455 454,455 453,454 452,451 452,449 453,446 454,442 455,441 454,440 452,438 452,437 452,436 452,435 453,434 453,432 453,431 452,431 450,430 448,431 445,432 444,433 443,433 441,433 440,434 439,435 438,435 438,436 435,436 433,435 431,435 430,435 428,436 428,436 426,436 425,436 423,435 422,435 419,437 418,437 413,437 413,437 412,438 411,439 411,443 411,446 410,448 409,449 407,451 406,451 406,451 404,452 403,452 402,452 401,454 400,457 398,460 397,462 396,463 389,462 388,463 388,463 385,467 384,468 383,470 384,472 384,473 382,475 382,475 381,475 381,475 379,476 378,476 378,477 377,477 375,478 375,479 375,481 375,484 375,486 374,488 373,489 372,489 372,490 370,491 366,491 365,491 364,492 363,494 363,500 363,501 361,503 361,505 363,509 363,512 363,513 364,516 365,519 365,520 364,521 363,522 362,524 363,527 363,529 363,533 362,534 360,536 359,538 359,538 359,538 360,538 365,538 366,538 367,538 370,537 375,533 378,533 379,533 380,532 382,532 383,531 383,531 385,531 386,530 387,530 387,530 387,529 388,530 388,529 389,529 389,529 391,529 392,528 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_aa = rsr.path("M 494,585 494,581 494,579 495,578 496,579 498,582 499,584 500,584 501,583 502,581 503,580 504,579 505,579 505,578 506,577 507,571 507,567 510,561 511,558 511,548 510,546 509,545 508,544 507,544 507,543 506,543 504,542 503,541 503,539 503,536 502,534 499,531 499,531 498,530 497,530 496,529 495,528 494,527 492,526 491,525 491,525 490,525 489,524 489,524 489,524 486,522 484,522 482,521 480,520 474,520 469,519 465,519 460,520 459,520 459,520 457,521 457,521 456,521 456,521 453,523 449,523 449,524 444,524 443,524 441,524 441,525 440,524 441,527 441,533 441,537 440,541 439,544 439,548 439,550 439,556 438,560 438,561 436,565 436,566 439,576 440,580 440,583 440,585 438,588 436,596 435,602 435,604 435,606 436,608 436,613 435,615 433,618 433,619 432,621 432,622 432,623 434,623 435,622 438,618 440,616 442,615 442,615 444,615 445,616 446,618 445,625 445,629 445,633 446,635 447,637 448,637 450,638 452,637 453,637 453,637 454,637 455,636 456,636 457,637 458,637 458,640 458,641 457,641 456,642 457,645 457,647 458,649 458,655 459,657 459,658 460,660 461,661 461,663 461,666 461,669 460,669 459,669 458,669 458,668 457,669 457,670 458,671 459,672 459,676 459,677 461,679 461,679 462,679 462,679 466,679 469,679 473,679 474,679 475,679 476,679 477,679 478,678 480,678 481,678 482,678 484,677 485,677 488,676 490,676 491,676 493,676 494,676 495,676 495,676 496,676 497,675 498,674 499,672 501,671 503,669 504,669 505,669 505,669 505,668 506,667 507,667 508,666 508,666 509,666 510,666 511,665 512,663 512,662 512,661 511,658 511,656 511,655 512,655 512,655 513,654 514,654 514,652 513,650 513,650 512,650 511,649 509,647 507,647 506,645 506,645 505,641 503,639 503,638 503,636 504,634 506,632 506,632 506,631 506,630 505,629 504,629 503,627 502,625 502,623 502,620 503,616 504,612 504,610 502,607 501,604 501,604 497,600 497,599 497,596 496,594 495,593 494,591 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_ab = rsr.path("M 436,566 436,565 438,561 438,560 439,556 439,550 439,548 439,544 440,541 441,537 441,533 441,527 440,524 435,523 430,523 421,523 419,523 418,524 416,524 416,524 415,524 414,524 413,525 412,525 410,525 409,525 409,525 407,526 405,526 405,526 403,526 403,527 400,527 397,527 396,528 395,528 394,528 393,528 392,528 391,529 389,529 389,529 388,529 388,530 387,529 387,530 387,530 386,530 385,531 383,531 383,531 382,532 380,532 379,533 378,533 375,533 370,537 367,538 366,538 365,538 360,538 359,538 359,540 360,546 360,551 360,551 362,552 363,553 366,553 373,554 376,554 377,555 380,556 381,557 382,558 382,560 380,566 380,570 381,576 381,577 380,579 379,581 376,583 375,584 375,586 374,590 374,590 373,592 372,593 372,596 372,598 372,601 371,602 370,604 370,604 369,607 369,608 369,610 372,613 371,614 370,617 370,619 371,621 372,623 374,628 374,630 374,637 374,637 374,637 375,643 375,645 376,646 377,647 378,647 380,648 381,649 382,650 383,656 385,661 386,663 387,663 387,663 387,663 388,663 390,662 393,662 394,662 395,663 396,664 398,664 399,664 400,662 401,661 402,661 403,662 405,662 407,662 409,661 410,659 410,659 411,656 412,655 413,655 414,656 414,656 416,658 417,658 418,658 419,657 420,657 419,656 419,655 419,654 418,653 417,653 418,652 417,651 417,650 416,649 417,649 417,648 417,646 416,644 415,643 415,641 415,639 415,637 416,636 416,635 416,634 416,632 416,631 416,628 417,625 419,622 421,620 424,617 428,614 429,612 430,610 431,610 432,611 432,612 432,613 431,616 431,617 432,618 433,619 433,619 433,618 435,615 436,613 436,608 435,606 435,604 435,602 436,596 438,588 440,585 440,583 440,580 439,576 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_ac = rsr.path("M155 577l0 0zm96 -62l-2 -2 0 0 -2 0 -1 2 -1 0 -5 0 -1 0 -1 1 0 0 -3 3 -1 0 -1 1 -2 1 -1 -1 -1 0 -2 -1 0 -3 -1 -3 -1 -1 -1 -1 -1 0 -1 0 -1 0 -1 2 -1 5 -3 6 -1 0 -1 1 -2 0 0 1 -2 0 -1 1 -1 1 2 2 0 0 1 2 0 1 -1 1 0 1 -2 0 -1 0 -3 0 -3 0 -2 -1 0 0 0 0 -1 0 -2 -1 -1 0 -1 -1 -1 0 -2 -1 -1 0 0 0 0 0 -1 -1 -1 0 -1 -1 -2 -1 -2 -1 -2 0 0 0 -2 -1 -1 0 -4 0 -3 1 -1 1 0 0 -2 1 -1 2 -2 7 -1 1 -1 1 -2 0 0 1 -2 0 0 0 -3 2 -1 1 0 1 1 1 2 1 2 1 0 1 -1 1 0 0 -1 1 -3 1 -1 0 -1 0 0 1 0 1 1 0 1 1 3 3 1 2 1 4 0 5 -2 4 -3 4 0 0 -2 2c0,1 0,2 1,3l0 0c1,0 1,0 2,0 0,1 1,3 1,4 -1,0 -2,1 -2,1 0,0 -1,1 -1,1 0,0 -1,0 -1,0 0,0 0,0 0,0l-1 0c0,0 0,1 0,2 -1,1 0,1 1,2 -1,0 -1,0 -1,1 0,0 0,0 0,0 -1,1 -1,0 -1,1 0,0 0,0 0,0 0,0 0,0 0,1 -1,0 -1,1 -1,1l0 0c0,0 0,0 -1,0 0,1 0,1 1,1 0,1 0,1 0,2 -1,0 -2,0 -3,0l0 1c0,0 0,-1 0,-1 -1,0 -1,0 -2,0 0,0 0,1 0,1 0,0 0,0 0,0l0 0c0,0 -1,0 -1,0 0,0 0,0 0,0 0,0 0,0 0,1l0 -1c0,0 -1,0 -1,0 0,0 0,0 0,0l0 0c-1,0 -1,0 -1,1 0,0 -1,0 -1,0l0 0c1,1 1,2 2,2l0 0 0 1 0 0 1 0 1 1 0 0 1 1 0 1c0,1 1,2 3,2l0 0c1,0 2,0 2,0 1,1 5,3 5,3 1,0 2,1 3,1l0 0c0,1 0,1 0,1 0,0 0,1 0,1 0,0 1,1 1,1 0,1 0,1 0,1 0,0 0,1 0,2 -1,0 -2,0 -3,1 0,0 -1,0 -2,0 0,0 0,0 -1,1 0,0 0,0 0,0 0,0 -1,0 -1,0 0,0 0,0 0,0 0,0 -1,0 -1,0 0,0 0,0 -1,0 0,0 0,0 0,0 0,0 0,0 -1,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 -1,0 -1,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 -1,0 0,0 0,0 0,0 0,0 -1,0 -1,0 0,0 -1,0 -1,0 -1,0 0,0 0,0l-1 0c0,0 0,0 0,0 0,0 0,1 0,0 -1,0 -1,0 -1,0 0,0 0,0 0,1 0,0 -1,0 -1,0 0,0 0,-1 0,-1 -1,1 -1,1 -1,1 0,0 0,-1 0,-1 0,1 0,1 0,1 0,0 0,1 -1,1 0,0 0,0 0,0l0 1c0,0 0,0 0,0 0,0 0,0 0,1 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 -1,0 0,0 1,0 0,0l1 1c0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,1 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,1 1,0 2,0 2,1 1,1 1,4 2,4 1,1 3,1 5,0 1,0 3,1 5,1 0,0 1,0 2,0 1,0 3,0 4,1 1,0 1,0 2,1 0,0 2,3 2,4 0,1 -1,3 0,6 0,1 1,2 2,3 1,1 3,-1 5,-1 1,0 2,1 3,2 2,0 3,-1 4,-1 2,-1 3,0 5,1 0,0 1,-1 2,-1 2,0 4,2 5,2 2,0 2,-1 4,0 2,1 3,1 5,1 2,1 1,2 2,3 0,1 1,2 2,3l0 0 0 0 1 -1 0 0 1 0 1 0 1 0 1 0 3 3 1 0 1 0 1 -1 1 -1 0 -1 -1 -9 0 -2 1 -3 0 -1 4 -4 0 -2 1 -2 -1 -2 0 -2 1 -2 0 -2 1 0 2 0 2 1 0 1 1 0 1 0 1 1 2 2 0 2 1 1 1 1 3 0 2 -1 0 0 0 0 2 -1 1 0 2 -1 0 -2 2 -6 1 -4 2 -6 3 -4 1 -1 1 -2 1 -2 0 -1 1 -1 1 -1 1 -2 1 -2 3 -4 6 -5 2 -1 0 -1 2 -1 2 -1 0 0 1 -1 1 0 -1 -1 -3 -3 -2 -1 -2 0 -2 -1 0 0 -1 0 -1 -1 -1 -1 0 -1 0 -2 1 -2 1 0 2 -1 0 0 1 -1 0 0 1 -2 1 0 1 -1 0 0 1 -2 0 0 -1 -1 -1 -2 0 -2 1 -2 -1 -4 0 -1 -1 -2 0 -1 0 -1 2 -1 0 0 2 -2 2 -2 1 -1 0 -1 -1 -4 -1 -1 -4 -6 -2 -1 0 0 -1 -1 -2 -1 -2 -1 -1 -4 -2 -2 0 0 -1 -2 -1 0 -1 -1 0 0 0 0 -2 -1 -1 0 -1 0 -1 -1z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_ad = rsr.path("M 387,401 389,403 389,404 390,406 390,409 390,408 391,408 394,406 394,406 395,406 396,406 396,405 397,405 399,405 400,406 400,407 399,408 398,410 397,410 396,411 396,411 395,412 395,412 394,415 394,416 393,416 393,416 393,418 393,419 395,422 396,424 396,425 398,426 398,426 400,428 401,428 404,430 405,431 406,431 406,431 408,431 408,432 409,432 411,433 412,434 413,435 413,437 413,437 418,437 419,437 422,435 423,435 425,436 426,436 428,436 428,436 430,435 431,435 433,435 435,436 438,436 438,435 439,435 440,434 441,433 443,433 444,433 445,432 448,431 450,430 452,431 453,431 453,432 453,434 452,435 452,436 452,437 452,438 454,440 455,441 454,442 453,446 452,449 452,451 453,454 454,455 456,455 458,455 460,455 462,453 463,452 464,452 464,452 465,452 467,452 469,452 470,451 470,451 472,451 472,451 474,454 475,455 478,456 478,456 478,456 480,454 481,454 481,453 482,453 488,453 489,453 490,451 491,451 494,451 494,451 495,450 496,450 496,448 498,446 498,446 498,446 498,446 498,445 497,445 496,444 494,443 493,442 493,442 491,441 490,441 489,441 489,441 489,440 487,440 483,440 482,440 482,439 480,437 479,435 478,433 477,430 475,429 473,427 472,427 472,425 473,424 474,423 476,422 478,422 478,422 479,421 479,420 478,419 477,417 477,416 478,413 479,412 481,410 482,409 483,408 486,403 489,401 491,401 492,401 494,400 494,397 496,394 498,392 501,391 502,389 503,387 507,381 509,378 511,377 512,377 514,375 514,374 512,369 511,368 509,364 508,360 508,357 509,354 510,352 512,348 512,346 513,342 512,337 512,336 508,328 508,326 509,325 510,323 509,323 505,322 504,322 501,321 498,321 496,321 493,323 491,323 487,322 484,322 484,322 484,323 483,323 483,323 482,323 480,324 479,325 476,324 473,326 472,326 470,327 468,329 466,331 460,339 460,340 460,342 461,343 461,345 461,346 459,347 458,347 456,347 456,347 454,346 452,345 450,345 449,346 445,348 443,351 442,353 439,356 439,357 438,362 438,365 437,365 436,366 434,367 434,369 433,370 431,372 430,372 429,373 422,373 417,372 416,372 412,371 409,370 407,369 406,371 405,372 400,372 400,372 399,373 400,374 401,375 401,376 401,377 400,377 399,377 397,377 396,378 396,379 398,379 399,380 401,382 401,382 401,384 401,386 399,387 398,387 396,388 395,389 394,390 394,392 393,393 392,394 392,394 391,394 387,394 386,395 386,397 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_ae = rsr.path("M 372,623 371,621 370,619 370,617 371,614 372,613 369,610 369,608 369,607 370,604 370,604 371,602 372,601 372,598 372,596 372,593 373,592 374,590 374,590 375,586 375,584 376,583 379,581 380,579 381,577 381,576 380,570 380,566 382,560 382,558 381,557 380,556 377,555 376,554 373,554 366,553 363,553 362,552 360,551 360,551 358,551 357,552 354,554 350,557 348,558 345,559 341,559 337,559 335,559 331,559 329,560 326,561 323,562 323,562 322,562 319,563 318,564 317,565 314,565 310,565 307,566 306,567 303,567 301,567 300,566 299,566 298,566 297,565 296,565 296,565 296,565 294,564 294,564 291,564 290,564 290,564 288,564 285,563 283,563 283,562 280,562 278,562 277,562 276,563 275,563 273,564 271,564 270,566 270,566 269,567 268,567 267,569 267,569 266,570 266,570 264,571 263,571 262,573 262,575 262,576 263,577 264,578 265,578 265,578 267,579 269,579 271,580 274,583 275,584 276,584 279,586 282,589 284,591 286,592 287,593 288,595 289,599 291,601 292,603 292,604 292,604 291,605 290,606 289,607 288,609 288,610 289,612 292,617 292,619 292,622 291,626 291,628 293,631 294,632 297,633 298,633 299,634 300,634 301,635 305,640 307,642 310,643 311,644 314,644 316,644 317,644 320,646 325,648 330,652 332,653 334,654 335,655 335,655 335,655 339,657 340,657 340,657 340,657 340,657 344,656 346,655 350,655 353,656 357,656 360,655 362,654 363,653 364,650 365,647 367,641 370,637 371,637 374,637 374,630 374,628 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_af = rsr.path("M307 642l-2 -2 -4 -5 -1 -1 -1 0 -1 -1 -1 0 -3 -1 -1 -1 -2 -3 0 -2 1 -4 0 -3 0 -2 -3 -5 -1 -2 0 -1 1 -2 1 -1 1 -1 1 -1 0 0 0 -1 -1 -2 -2 -2 -1 -4 -1 -2 -1 -1 -2 -1 -2 -2 -3 -3 -3 -2 -1 0 -1 0 -1 1 0 0 -2 1 -2 1 0 1 -2 1 -6 5 -3 4 -1 2 -1 2 -1 1 -1 1 0 1 -1 2 -1 2 -1 1 -3 4 -2 6 -1 4 -2 6 0 2 -2 1 -1 0 -2 1 0 0 0 0 -2 1 -3 0 -1 -1 -1 -1 0 -2 -2 -2 -1 -1 -1 0 -1 0 0 -1 -2 -1 -2 0 -1 0 0 2 -1 2 0 2 1 2 -1 2 0 2 -4 4 0 1 -1 3 0 2 1 9 0 1 -1 1 -1 1 -1 0 -1 0 -3 -3 -1 0 -1 0 -1 0 -1 0 0 0 -1 1 0 0c0,0 0,0 0,1 -1,0 0,3 0,4 0,2 2,2 3,3 2,1 1,2 2,3 0,1 1,1 2,2 0,0 0,0 0,0 2,2 3,2 5,2 1,0 2,0 2,-1 1,0 1,-3 1,-4 1,0 1,0 1,-1 1,-1 1,-1 1,-2 1,-1 1,-2 2,-3 0,-1 1,-3 2,-4 0,0 1,0 1,-1 0,0 0,-1 1,-2 0,0 0,-1 0,-2 0,0 1,0 1,0l1 -2 0 0c1,0 0,-1 1,-2 0,0 2,-2 3,-2 1,-1 2,1 5,-1 3,-3 1,-3 5,-4 1,0 2,-1 2,-1 0,1 1,1 1,1 1,2 2,3 4,4 0,1 1,2 2,2 1,2 2,3 4,4 0,1 1,1 1,1 1,1 2,1 3,2 2,0 3,-2 5,1 1,0 2,0 3,0 0,1 1,2 1,3 2,1 2,2 3,3 1,3 0,3 -2,4 -1,1 -2,1 -4,1 -2,1 -5,-5 -9,-4 -4,1 -3,4 -4,6 0,1 -1,2 -1,3 -1,1 -2,1 -3,1 -1,0 -1,0 -1,-1 -2,0 -4,0 -4,1 0,0 0,1 0,1 0,1 0,1 0,2 1,1 1,1 1,2 1,1 2,1 3,2 0,0 0,4 0,5 0,1 1,1 1,2 0,1 1,3 1,4 1,1 2,1 2,2 1,0 1,1 1,2 1,1 2,1 3,1 1,0 3,1 4,1 1,0 1,0 2,0 3,1 3,3 3,5 0,1 -1,3 -1,4 0,0 0,1 0,1l1 0 1 0 1 1 1 0 1 0 0 0 1 0 1 1 1 0 1 0 2 3 0 0 1 1 1 1 1 0 1 1 3 1 1 0 1 1 3 2 1 1 1 1 1 0 2 1 1 0 1 0 1 0 0 -1 0 -1 2 -1 2 -4 1 -1 1 0 1 0 1 1 1 1 2 0 1 -1 1 -2 0 -5 0 -3 -1 -2 -2 -3 0 -1 0 -1 0 -1 2 -2 1 -1 1 -1 1 -1 1 -3 1 -1 3 -3 2 -1 0 -2 -1 0 0 0 -2 0 -1 0 -1 0 -1 -1 1 -5 0 -2 1 -1 2 0 0 -1 1 0 1 -1 0 0 2 -1 1 -3 1 -1 1 0 3 -1 2 -1 4 1 1 -1 4 0 0 0 1 0 2 -2 0 -1 0 -2 1 -2 0 0 -1 0 -4 -2 0 0 0 0 -1 -1 -2 -1 -2 -1 -5 -4 -5 -2 -3 -2 -1 0 -2 0 -3 0 -1 -1 -3 -1z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_ag = rsr.path("M250 510l1 -3 1 -3 2 -2 2 -1 0 0 2 -1 0 -1 0 0 -1 -1 -1 0 0 0 0 0 -1 0 0 0 -2 -2 0 0 0 -3 -1 -1 -1 -1 -1 0 -2 0 -3 -1 -1 -1 -1 -1 0 -1 0 -3 0 -2 0 -1 -4 -2 -1 0 -1 0 -2 0 0 1 -1 0 -2 2 -3 1 0 0 0 0 -2 0 -4 0 -1 0 0 0 -1 0 -1 -1 -2 -1 0 0 0 -1 -2 0 0 0 -2 -1 -3 -1 -1 -1 -1 0 -2 -1 -2 0 -3 1 -2 0 -2 0 -3 -1 -1 0 -1 -3 -2 0 -1 1 -1 1 -1 3 -1 3 -1 1 -3 1 -3 0 -2 -1 0 0 0 -2 -2 -2 -1 -1 -1 -1 -2 1 0 0 -2 1 -1 0 0 0 0 1 -2 -1 -1 0 -1 -2 -1 -3 -1 -1 -1 0 -2 0 0 -1 0 -3 -1 -1 -1 -1 -2 0 -2 1 -2 0 -1 1 0 4 -1 2 -2 0 -2 1 -1 1 0 0 -1 0 -1 1 0 0 -1 0 -2 1 -2 1 -1 -1 -3 -3 -2 0 -1 -1 -1 0 -2 1 -1 0 -3 -4 -2 -3 0 -1 -1 0 -2 0 -5 2 -3 0 -1 -1 -1 -1 -2 -2 -4 -4 -3 -2 -4 -5 -3 -2 0 0 0 -1 -5 0 -2 0 0 -1 -1 0 -2 0 0 0 0 0 -2 0 0 0 0 1 -1 0 -1 1 -1 1 -1 0 0 0 -1 0 -1 1 0 1 -2 0 -1 -1 -1 -1 -1 0 -1 -1 -1 0 -2 -2 -2 -1 -2 -1 -1 0 -1 0 0 1 0 1 0 1 0 1 -1 1 -2 0 -2 1 -1 -1 -1 0 -1 -1 -2 0 -1 0 0 -1 -2 0 0 0 -1 1 -1 0 -2 1 -1 0 -1 0 -1 1 -1 1 0 1 0 2c0,0 1,-1 1,0 0,0 0,0 0,0 0,0 -1,0 -1,0 -1,0 0,1 0,1 0,1 3,3 3,3 0,0 1,1 1,1l0 0c0,0 0,0 0,1 1,0 2,1 2,2 0,0 1,1 1,1l0 0c0,0 -1,1 -1,1 1,1 2,3 2,4 0,0 0,0 0,1 0,0 0,0 0,0 0,0 0,0 -1,0 1,1 4,4 6,5 1,-1 2,-1 4,-1l3 2c1,4 1,5 3,8 1,0 2,-1 3,-1l0 -1 2 0c0,1 1,2 1,3l0 0 0 1 0 0 0 1c1,0 1,0 1,0 1,0 1,1 1,1l1 0c2,1 3,3 5,4 -1,1 -1,2 -1,3l0 0 0 0c1,1 1,1 1,2 0,0 1,0 2,0 0,1 1,2 1,4l-1 0c0,0 1,0 1,0l0 0c0,1 0,1 0,2 1,-1 1,0 2,0 0,0 0,0 0,0 0,-1 1,-1 2,-1 1,0 2,0 3,0 0,0 1,-4 1,-4l4 1c0,1 -1,3 -1,4l0 0c-1,2 -1,4 -1,6l0 0c0,0 0,0 0,0 0,1 0,1 -1,2l1 1c0,1 0,1 0,3 0,0 -1,1 -1,2 0,0 -1,2 -1,3 0,0 -1,1 -1,1 0,1 0,2 0,4 1,-1 1,-1 2,-1l1 1c0,0 1,1 1,2l0 0c0,0 1,1 1,2l0 0c0,1 0,1 1,2l-1 0c0,0 0,1 0,1 -2,2 -3,2 -5,4 0,0 0,0 1,1l-1 0 0 1c2,0 4,0 6,0 0,0 0,1 1,1 0,0 1,1 2,1 1,1 0,1 1,2 0,0 0,0 0,1 0,0 0,0 0,0l0 0c0,1 -1,1 -1,1 0,0 0,0 0,0l0 0c0,1 2,2 3,2l0 0c1,0 1,0 2,0 0,1 0,1 0,2 0,0 1,0 1,0l0 0 0 0c0,0 0,1 0,2l0 0c0,0 0,0 0,0 1,0 1,0 2,0l0 1c0,0 0,1 0,1 0,0 0,1 1,1 0,0 2,1 2,1 0,0 0,1 0,1 1,1 1,1 2,1l1 3c2,-1 3,-1 4,-1l0 2c1,0 2,0 2,-1 0,1 0,1 0,1 1,1 1,1 1,2 1,0 2,0 2,0 0,0 1,-1 1,-1l2 0c0,0 1,-1 1,-1l-1 0 1 -1 1 0 0 0 0 0c0,0 1,0 1,-1l0 1 1 0 -1 0 1 1c0,0 -1,0 -1,0 0,0 1,2 1,3 1,1 2,1 2,2 0,0 0,1 -1,1 1,1 1,2 2,2l0 0c3,0 4,3 5,3l1 -1 0 0 1 -1c0,0 1,0 1,1 0,0 0,0 0,0l1 0 0 0 1 0 0 0c0,0 1,0 1,0 0,0 0,0 0,1 1,0 2,1 2,1 0,0 1,0 1,-1 1,1 2,1 2,1 1,0 1,0 1,-1 0,0 1,0 1,1 0,0 0,0 0,0 0,0 0,0 0,0l1 1c0,0 0,0 0,0 0,0 0,0 0,0 1,0 1,2 2,2 1,0 3,0 4,1l0 0 2 -2 0 0 3 -4 2 -4 0 -5 -1 -4 -1 -2 -3 -3 -1 -1 -1 0 0 -1 0 -1 1 0 1 0 3 -1 1 -1 0 0 1 -1 0 -1 -2 -1 -2 -1 -1 -1 0 -1 1 -1 3 -2 0 0 2 0 0 -1 2 0 1 -1 1 -1 2 -7 1 -2 2 -1 0 0 1 -1 3 -1 4 0 1 0 2 1 0 0 2 0 2 1 2 1 1 1 1 0 1 1 0 0 0 0 1 0 2 1 1 0 1 1 1 0 2 1 1 0 0 0 0 0 2 1 3 0 3 0 1 0 2 0 0 -1 1 -1 0 -1 -1 -2 0 0 -2 -2 1 -1 1 -1 2 0 0 -1 2 0 1 -1 1 0 3 -6 1 -5 1 -2 1 0 1 0 1 0 1 1 1 1 1 3 0 3 2 1 1 0 1 1 2 -1 1 -1 1 0 3 -3 0 0 1 -1 1 0 5 0 1 0 1 -2 2 0 1 -3z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_ah = rsr.path("M 249,513 251,515 252,516 253,516 254,516 256,517 256,517 256,517 257,518 258,518 259,520 259,520 261,522 262,526 264,527 266,528 267,529 267,529 269,530 273,536 274,537 275,541 275,542 274,543 272,545 270,547 270,547 268,548 268,549 268,550 269,552 269,553 270,557 269,559 269,561 270,563 271,564 271,564 273,564 275,563 276,563 277,562 278,562 280,562 283,562 283,563 285,563 288,564 290,564 290,564 291,564 294,564 294,564 296,565 296,565 296,565 297,565 298,566 299,566 300,566 301,567 303,567 306,567 307,566 310,565 314,565 317,565 318,564 319,563 322,562 323,562 323,562 326,561 329,560 331,559 335,559 337,559 341,559 345,559 348,558 350,557 354,554 357,552 358,551 360,551 360,546 359,540 359,538 359,538 359,538 359,538 358,537 357,533 356,531 355,530 353,527 349,523 348,523 347,522 345,521 344,520 343,520 343,519 341,518 340,517 338,515 337,510 335,502 334,494 333,485 332,483 331,482 331,481 330,479 329,476 329,475 328,474 327,474 325,472 324,470 324,466 323,463 323,463 323,463 320,463 319,463 316,465 314,465 311,465 310,465 309,463 308,462 307,461 306,461 304,459 302,457 301,456 302,455 302,454 303,453 305,454 305,454 306,454 307,453 307,451 306,450 305,449 304,448 304,448 304,448 303,447 301,445 300,445 300,445 297,442 296,439 296,435 295,432 295,431 295,430 293,429 291,429 290,428 287,428 284,429 284,429 284,429 283,430 281,429 280,429 276,426 274,428 273,430 271,433 268,436 265,440 263,442 263,442 262,443 260,443 258,444 257,444 255,445 253,445 252,446 252,447 253,449 253,453 252,455 250,458 249,458 246,461 245,462 244,463 245,465 245,468 245,469 244,470 242,471 240,471 239,473 238,475 237,476 237,479 238,479 239,479 243,481 243,482 243,484 243,487 243,488 244,489 245,490 248,491 250,491 251,491 252,492 253,493 253,496 253,496 255,498 255,498 256,498 256,498 256,498 257,498 258,499 258,499 258,500 256,501 256,501 254,502 252,504 251,507 250,510 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_ai = rsr.path("M102 436l0 0zm127 47l3 -1 2 -2 1 0 0 -1 2 0 0 0 0 -3 1 -1 1 -2 1 -2 2 0 2 -1 1 -1 0 -1 0 -3 -1 -2 1 -1 1 -1 3 -3 1 0 2 -3 1 -2 0 -4 -1 -2 0 -1 1 -1 2 0 2 -1 1 0 2 -1 2 0 1 -1 0 0 2 -2 3 -4 3 -3 2 -3 1 -2 2 -2 0 0 -1 -1 -1 0 -2 -2 0 0 -1 -1 -1 0 0 0 -1 -2 -3 0 -11 -1 -1 -1 -1 0 -2 -1 0 0 -2 -1 -1 0 -2 -1 -2 -1 -1 -1 -2 0 -1 -1 0 0 0 0 -2 -1 -1 -2 -1 -3 -1 -1 -2 0 -2 -1 -1 0 -2 -2 -2 0 -1 -1 0 -1 -1 -3 0 -1 -1 0 -1 -1 -2 -1 -2 0 -3 -1 -1 -1 -3 -1 0 -1 -1 0 -2 -2 -1 0 -1 1 -1 1 -2 0 -3 -3 -3 -1 -2 -1 0 0 -3 0 -4 0 -1 1 -5 0 -1 -1 -3 0 -1 1 -3 1 -1 1 0 0 -1 0 -2 1 -3 0 -4 0 -1 0 0 0 -5 -2 0 0 -1 -1 -2 -2 -1 -2 0 0 0 0 -1 0 -1 0 0 1 -1 -1 0 0 -1 0 -1 1 0 0 0 1 0 0 1 1 0 1 1 0 0 0 1 1 -1 0 -1 1 -1 0 -1 1 0 1 0 1 -1 0 -1 0 0 0 -1 0 -1 -1 0 0 -1 0 -1 0 -1 0 -1 1 0 0 -1 0 0 2 -1 1 0 1 0 1 0 1 1 0 0 1 0 0 -1 1 0 1 0 0 -1 1 0 1 -1 0 0 1 -1 1 0 0 0 1 0 0 -1 1 0 1 0 1 0 1 1 1 1 0 1 0 1 1 0 1 0 1 0 1 0 0 -1 1 0 1 0 0 0 1 0 1 0 0 -1 1 0 0 -1 0 -1 -1 -1 0 0 0 -1 0 0 0 0 0 -1 0 0 0 -1 1 -1 1 0 1 -1 1 -1 2 0 1 0 1 0 1 1 1 -1 1 0 0 -1 1 0 1 0 1 -1 1 0 0 0 1 -1 0 -1 0 -1 0 -1 -1 -1 1 0 0 0 0 -1 1 0 1 0 1 -1 1 0 0 0 0 0 0 -1 1 -1 0 0 0 0 1 -1 0 0 1 -1 0 -1 0 -1 -2 -1 -1 0 0 0 0 -1 0 -2 0 -1 1 -1 0 -1 -1 -1 -1 -1 -1 0 0 -1 0 0 1 0 0 0 0 -1 1 0 0 0 0 -1 0 -1 -1 -1 0 -1 -1 -1 0 -1 0 -1 0 -1 0 -1 0 -2 1 -1 1 -1 0 -1 1 -1 2 0 1 -1 1 1 1 0 1 0 1 -1 0 -1 0 -1 1 0 1 0 1 -1 1 2 0 0 0 0 0 2 0 1 0 0 1 2 0 5 0 0 1 0 0 3 2 4 5 3 2 4 4 2 2 1 1 1 1 3 0 5 -2 2 0 1 0 0 1 2 3 3 4 1 0 2 -1 1 0 1 1 2 0 3 3 1 1 2 -1 2 -1 1 0 0 0 1 -1 1 0 0 0 1 -1 2 -1 2 0 1 -2 0 -4 1 -1 2 0 2 -1 2 0 1 1 1 1 0 3 0 1 2 0 1 0 1 1 1 3 1 2 1 0 2 1 0 -1 0 0 1 0 2 -1 0 0 2 -1 1 1 1 1 2 2 0 2 0 0 2 1 3 0 3 -1 1 -1 1 -3 1 -3 1 -1 1 -1 2 0 1 3 1 0 3 1 2 0 2 0 3 -1 2 0 2 1 1 0 1 1 3 1 2 1 0 0 2 0 0 1 0 0 2 1 1 1 1 0 0 0 1 0 4 0 2 0 0 0 0 0z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_aj = rsr.path("M 233,405 235,405 236,406 237,409 238,411 240,412 240,412 240,412 241,413 243,413 244,414 246,415 248,416 249,416 251,417 251,417 253,418 254,418 255,419 266,420 269,420 270,422 270,422 271,422 271,419 272,417 273,416 274,414 273,411 272,409 270,404 269,401 269,398 270,395 271,394 273,392 274,392 275,392 275,392 276,390 276,390 277,390 278,389 280,389 281,388 281,388 282,387 281,383 279,379 278,377 277,376 276,375 273,373 272,372 271,371 267,369 267,369 266,368 267,367 267,367 268,367 271,366 273,366 274,366 275,366 275,365 276,365 276,365 277,365 278,365 279,364 281,362 283,355 283,354 282,353 280,351 277,349 277,348 277,348 277,347 278,345 279,344 282,340 282,339 281,336 280,334 278,333 276,333 273,333 271,332 270,332 269,331 269,329 268,327 266,326 265,323 264,322 263,321 261,321 260,322 258,322 257,321 256,321 255,320 255,318 256,317 256,317 258,315 258,315 265,309 266,306 267,304 268,303 269,303 270,302 271,300 271,297 271,295 271,294 270,294 269,293 267,289 266,288 266,288 266,288 264,287 262,287 258,286 258,286 257,286 252,286 250,284 249,284 246,283 244,282 243,281 243,281 242,279 241,278 240,279 239,279 237,280 236,279 235,278 234,273 233,270 232,270 231,269 231,269 228,268 226,267 225,267 223,266 222,265 222,265 221,265 221,264 219,262 219,263 219,263 218,264 218,264 217,264 216,264 215,264 215,264 214,264 213,264 212,266 211,267 210,268 208,269 207,270 206,270 205,272 204,273 204,273 204,274 203,275 203,277 203,279 203,280 203,281 204,282 204,283 205,285 205,286 204,289 204,290 203,291 202,291 200,292 200,292 199,292 197,292 196,293 195,294 195,295 195,297 194,298 194,298 194,299 191,301 191,302 191,302 190,303 190,305 190,306 190,307 189,308 189,309 189,309 188,309 188,310 188,311 188,312 189,312 189,313 189,314 189,315 189,315 189,316 188,317 187,318 186,318 185,318 185,319 185,319 184,320 184,321 184,322 184,323 183,324 183,324 183,325 183,325 182,326 182,326 182,327 182,327 180,327 179,328 178,328 177,329 176,329 176,330 176,331 175,332 174,333 174,334 173,335 172,335 172,336 171,336 170,336 170,337 170,338 170,338 170,338 171,339 171,339 172,340 172,340 172,341 173,342 172,342 172,343 171,343 171,344 172,345 172,346 172,347 172,347 170,347 170,348 170,348 169,349 169,350 167,350 166,350 166,350 165,351 165,351 165,352 165,353 166,354 166,355 166,356 166,357 165,358 165,359 164,360 164,360 164,360 161,361 161,361 160,362 159,362 158,363 157,364 157,365 157,367 157,369 156,371 155,372 155,372 154,373 154,373 154,373 154,374 154,374 155,375 155,375 157,376 158,377 158,377 158,378 158,378 157,379 156,380 156,381 155,382 155,382 154,383 154,383 153,382 153,382 154,384 156,386 157,387 157,387 162,389 162,389 163,389 167,389 170,389 172,388 173,388 173,388 174,387 177,386 178,385 181,385 182,386 187,386 188,385 192,385 195,385 195,385 197,386 200,387 203,390 205,390 206,389 207,388 208,388 210,390 211,390 211,391 214,392 215,393 218,394 220,394 222,395 223,396 224,396 224,397 225,400 225,401 226,402 228,402 230,404 231,404 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_ak = rsr.path("M 273,411 274,414 273,416 272,417 271,419 271,422 272,423 272,423 274,425 275,425 276,426 276,426 280,429 281,429 283,430 284,429 284,429 284,429 287,428 290,428 291,429 293,429 295,430 295,431 295,432 296,435 296,439 297,442 300,445 300,445 301,445 303,447 304,448 304,448 304,448 305,449 306,450 307,451 307,453 306,454 305,454 305,454 303,453 302,454 302,455 301,456 302,457 304,459 306,461 307,461 308,462 309,463 310,465 311,465 314,465 316,465 319,463 320,463 323,463 323,463 323,463 324,466 324,470 325,472 327,474 328,474 329,475 329,476 330,479 331,481 331,482 332,483 333,485 334,494 335,502 337,510 338,515 340,517 341,518 343,519 343,520 344,520 345,521 347,522 348,523 349,523 353,527 355,530 356,531 357,533 358,537 359,538 359,538 359,538 360,536 362,534 363,533 363,529 363,527 362,524 363,522 364,521 365,520 365,519 364,516 363,513 363,512 363,509 361,505 361,503 363,501 363,500 363,494 364,492 365,491 366,491 370,491 372,490 372,489 373,489 374,488 375,486 375,484 375,481 375,479 375,478 377,477 378,477 378,476 379,476 381,475 381,475 382,475 382,475 384,473 384,472 383,470 384,468 385,467 388,463 388,463 389,462 396,463 397,462 398,460 400,457 401,454 402,452 403,452 404,452 406,451 406,451 407,451 409,449 410,448 411,446 411,443 411,439 412,438 413,437 413,435 412,434 411,433 409,432 408,432 408,431 406,431 406,431 405,431 404,430 401,428 400,428 398,426 398,426 396,425 396,424 395,422 393,419 393,418 393,416 393,416 394,416 394,415 395,412 395,412 396,411 396,411 397,410 398,410 399,408 400,407 400,406 399,405 397,405 396,405 396,406 395,406 394,406 394,406 391,408 390,408 390,409 388,409 387,409 387,410 386,410 386,410 382,411 380,412 377,412 374,411 370,410 369,410 368,411 366,412 365,415 363,416 362,416 361,416 358,415 357,415 357,414 357,412 359,410 360,410 360,409 359,408 358,407 357,407 356,406 353,406 351,406 349,407 348,407 347,407 346,406 345,405 344,404 343,403 340,403 336,402 332,402 330,402 327,402 326,402 325,401 325,401 322,400 322,400 319,400 316,401 315,401 314,403 313,403 310,403 309,403 309,404 307,405 305,405 302,402 301,401 300,396 299,394 297,392 295,391 291,391 291,391 290,391 290,391 287,392 285,391 285,391 284,391 282,387 281,388 281,388 280,389 278,389 277,390 276,390 276,390 275,392 275,392 274,392 273,392 271,394 270,395 269,398 269,401 270,404 272,409 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_al = rsr.path("M 388,293 389,293 390,293 390,292 392,291 392,290 395,288 399,284 401,283 401,278 402,276 404,275 406,273 407,273 410,273 411,273 412,272 414,270 415,267 417,265 418,265 419,265 419,266 420,267 422,266 423,266 424,265 427,263 430,263 432,264 438,264 441,265 446,267 448,268 458,268 459,268 460,268 460,268 461,268 462,267 463,267 463,267 465,267 473,267 478,266 479,265 479,265 480,265 481,265 481,264 481,264 482,263 483,262 484,261 485,259 485,257 484,256 482,253 482,253 481,251 481,249 482,248 482,248 482,246 477,247 475,247 474,247 472,247 472,245 472,244 470,242 469,240 467,237 466,235 465,235 465,234 464,234 462,233 461,232 460,232 458,232 457,232 457,232 456,231 455,230 454,229 452,228 452,226 452,225 452,223 451,222 450,221 449,221 449,220 448,219 448,218 447,217 446,217 445,217 444,216 443,215 442,215 440,216 439,216 438,216 436,216 434,215 433,215 432,215 430,215 429,215 428,216 427,217 426,218 424,220 423,220 422,220 420,220 420,220 418,220 417,221 415,222 414,222 413,222 411,223 410,223 409,222 408,221 407,221 406,221 405,221 405,221 404,222 403,222 402,222 400,222 399,221 398,220 397,218 396,218 395,217 392,216 391,216 390,215 389,215 388,215 387,215 386,215 384,217 383,217 382,218 381,218 379,219 377,219 376,218 375,217 374,215 373,215 372,213 370,212 367,211 365,211 364,211 362,212 360,212 357,212 355,212 353,211 351,211 349,211 347,211 344,211 344,212 345,212 346,212 347,212 348,213 349,217 350,218 351,218 353,219 355,220 356,221 356,223 355,225 352,229 349,234 348,235 347,235 347,236 346,236 346,236 345,236 344,236 342,237 341,237 339,237 337,237 335,237 330,238 326,239 326,239 322,240 320,241 318,242 318,243 318,245 318,246 319,247 320,247 322,248 328,248 329,248 330,249 330,249 330,251 329,251 327,254 325,257 324,261 324,266 323,267 323,267 321,267 319,266 315,264 312,263 311,263 310,263 308,265 306,268 304,270 303,273 302,276 302,278 303,279 303,280 303,281 302,281 300,281 300,282 299,282 298,284 297,286 296,287 297,289 298,290 300,290 303,290 305,288 306,288 307,288 309,288 310,289 311,289 312,288 316,286 317,286 317,285 318,285 318,285 320,285 321,285 322,285 323,288 325,289 326,290 329,290 331,291 331,290 334,290 334,290 338,290 340,292 341,292 346,292 350,292 353,292 354,291 355,291 357,291 359,290 360,290 360,289 361,289 363,289 364,290 365,291 366,293 367,296 367,297 367,297 370,298 371,297 371,297 372,297 374,296 374,296 375,296 376,296 376,295 377,294 378,294 382,293 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_am = rsr.path("M 323,267 324,266 324,261 325,257 327,254 329,251 330,251 330,249 330,249 329,248 328,248 322,248 320,247 319,247 318,246 318,245 318,243 318,242 320,241 322,240 326,239 326,239 330,238 335,237 337,237 339,237 341,237 342,237 344,236 345,236 346,236 346,236 347,236 347,235 348,235 349,234 352,229 355,225 356,223 356,221 355,220 353,219 351,218 350,218 349,217 348,213 347,212 346,212 345,212 344,212 344,212 343,213 341,213 340,213 338,212 337,211 336,211 333,211 330,209 328,208 327,208 327,207 326,206 324,205 323,205 322,204 322,203 322,202 323,201 322,200 321,199 321,198 320,197 319,198 318,199 317,199 315,198 314,198 314,197 313,196 312,195 312,195 311,196 310,197 310,198 308,198 307,199 308,200 307,201 306,202 306,203 306,204 305,205 305,207 304,208 304,209 303,210 302,210 301,211 300,211 298,212 298,212 296,212 295,211 295,211 293,209 292,210 291,209 290,209 289,209 288,209 289,211 290,212 290,214 290,215 288,216 288,216 286,216 285,217 284,218 283,219 283,220 282,221 282,222 280,223 279,224 277,224 277,224 276,225 276,225 275,225 274,225 274,225 273,226 273,228 274,229 274,230 274,230 275,231 274,231 273,232 273,232 272,232 271,232 269,232 269,233 268,233 268,233 267,234 267,235 267,235 266,236 266,237 265,238 264,239 263,240 262,240 260,240 260,240 258,241 256,241 255,241 253,240 252,239 250,238 249,237 248,237 247,236 246,236 244,237 244,237 243,238 243,239 242,240 242,241 242,242 242,243 242,244 242,244 241,244 240,244 239,244 238,244 238,244 238,244 237,244 235,243 234,243 234,243 233,242 232,242 232,242 232,242 232,243 231,244 230,244 230,245 229,245 228,245 228,246 227,247 227,248 226,249 225,250 225,250 224,251 223,252 223,254 222,255 221,257 220,258 220,258 220,259 219,260 219,261 219,262 221,264 221,265 222,265 222,265 223,266 225,267 226,267 228,268 231,269 231,269 232,270 233,270 234,273 235,278 236,279 237,280 239,279 240,279 241,278 242,279 243,281 243,281 244,282 246,283 249,284 250,284 252,286 257,286 258,286 258,286 262,287 264,287 266,288 266,288 266,288 267,289 269,293 270,294 271,294 271,295 272,294 273,294 273,293 275,293 275,293 276,292 279,291 280,291 280,290 281,290 283,289 283,289 284,289 285,289 285,288 287,288 288,288 288,289 286,291 286,292 287,292 288,293 289,292 289,292 291,290 292,290 293,290 295,292 296,294 296,295 296,296 297,296 299,297 301,297 303,298 303,298 305,299 306,298 307,295 308,294 309,294 310,294 311,293 311,291 311,290 311,289 310,289 309,288 307,288 306,288 305,288 303,290 300,290 298,290 297,289 296,287 297,286 298,284 299,282 300,282 300,281 302,281 303,281 303,280 303,279 302,278 302,276 303,273 304,270 306,268 308,265 310,263 311,263 312,263 315,264 319,266 321,267 323,267 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_an = rsr.path("M 321,285 320,285 318,285 318,285 317,285 317,286 316,286 312,288 311,289 311,290 311,291 311,293 310,294 309,294 308,294 307,295 306,298 305,299 303,298 303,298 301,297 299,297 297,296 296,296 296,295 296,294 295,292 293,290 292,290 291,290 289,292 289,292 288,293 287,292 286,292 286,291 288,289 288,288 287,288 285,288 285,289 284,289 283,289 283,289 281,290 280,290 280,291 279,291 276,292 275,293 275,293 273,293 273,294 272,294 271,295 271,297 271,300 270,302 269,303 268,303 267,304 266,306 265,309 258,315 258,315 256,317 256,317 255,318 255,320 256,321 257,321 258,322 260,322 261,321 263,321 264,322 265,323 266,326 268,327 269,329 269,331 270,332 271,332 273,333 276,333 278,333 280,334 281,336 282,339 282,340 282,340 285,341 285,341 289,342 290,343 291,344 292,344 293,346 293,346 293,348 292,349 293,351 293,352 294,352 296,352 296,352 297,351 298,351 300,351 302,352 305,353 307,354 311,354 312,354 314,353 317,353 319,352 319,352 320,351 321,351 322,348 322,346 323,345 324,345 325,345 327,347 330,349 332,349 333,349 335,349 337,347 338,347 340,346 341,344 343,340 343,339 346,338 349,337 349,337 350,337 350,336 352,336 353,335 354,334 354,333 352,331 351,329 351,328 352,325 353,323 353,321 353,319 353,319 354,318 356,318 357,316 358,315 359,315 359,315 363,314 364,314 365,314 367,313 368,310 369,309 370,309 371,309 373,310 374,310 375,309 375,308 375,303 376,301 377,299 377,296 376,296 376,296 375,296 374,296 374,296 372,297 371,297 371,297 370,298 367,297 367,297 367,296 366,293 365,291 364,290 363,289 361,289 360,289 360,290 359,290 357,291 355,291 354,291 353,292 350,292 346,292 341,292 340,292 338,290 334,290 334,290 331,290 331,291 329,290 326,290 325,289 323,288 322,285 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_ao = rsr.path("M 346,338 343,339 343,340 341,344 340,346 338,347 337,347 335,349 333,349 332,349 330,349 327,347 325,345 324,345 323,345 322,346 322,348 321,351 320,351 319,352 319,352 317,353 314,353 312,354 311,354 307,354 305,353 302,352 300,351 298,351 297,351 296,352 296,352 294,352 293,352 293,351 292,349 293,348 293,346 293,346 292,344 291,344 290,343 289,342 285,341 285,341 282,340 279,344 278,345 277,347 277,348 277,348 277,349 280,351 282,353 283,354 283,355 281,362 279,364 278,365 277,365 276,365 276,365 275,365 275,366 274,366 273,366 271,366 268,367 267,367 267,367 266,368 267,369 267,369 271,371 272,372 273,373 276,375 277,376 278,377 279,379 281,383 282,387 284,391 285,391 285,391 287,392 290,391 290,391 291,391 291,391 295,391 297,392 299,394 300,396 301,401 302,402 305,405 307,405 309,404 309,403 310,403 313,403 314,403 315,401 316,401 319,400 322,400 322,400 325,401 325,401 326,402 327,402 330,402 332,402 336,402 340,403 343,403 344,404 345,405 346,406 347,407 348,407 349,407 351,406 353,406 356,406 357,407 358,407 359,408 360,409 360,410 359,410 357,412 357,414 357,415 358,415 361,416 362,416 363,416 365,415 366,412 368,411 369,410 370,410 374,411 377,412 380,412 382,411 386,410 386,410 387,410 387,409 388,409 390,409 390,406 389,404 389,403 387,401 386,397 386,395 387,394 391,394 392,394 392,394 393,393 394,392 394,390 395,389 396,388 398,387 399,387 401,386 401,384 401,382 401,382 399,380 398,379 396,379 396,378 397,377 399,377 400,377 401,377 401,376 401,375 400,374 399,373 400,372 400,372 405,372 406,371 407,369 407,369 408,361 407,355 407,354 406,353 404,352 403,351 402,349 401,347 402,342 403,340 403,339 404,336 403,333 402,331 400,329 399,328 399,328 398,327 396,326 395,325 394,322 393,321 391,321 391,321 389,320 387,319 385,318 384,317 383,314 383,311 383,310 384,307 386,304 387,302 388,302 389,302 390,302 392,301 393,301 393,299 393,297 391,295 390,293 390,293 389,293 388,293 382,293 378,294 377,294 376,295 376,296 377,296 377,299 376,301 375,303 375,308 375,309 374,310 373,310 371,309 370,309 369,309 368,310 367,313 365,314 364,314 363,314 359,315 359,315 358,315 357,316 356,318 354,318 353,319 353,319 353,321 353,323 352,325 351,328 351,329 352,331 354,333 354,334 353,335 352,336 350,336 350,337 349,337 349,337 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data({'id': 'west-country', 'region': 'West Country'});

        var path_ap = rsr.path("M 399,328 400,329 402,331 403,333 404,336 403,339 403,340 402,342 401,347 402,349 403,351 404,352 406,353 407,354 407,355 408,361 407,369 409,370 412,371 416,372 417,372 422,373 429,373 430,372 431,372 433,370 434,369 434,367 436,366 437,365 438,365 438,362 439,357 439,356 442,353 443,351 445,348 449,346 450,345 452,345 454,346 456,347 456,347 458,347 459,347 461,346 461,345 461,343 460,342 460,340 460,339 466,331 468,329 470,327 472,326 473,326 476,324 479,325 480,324 482,323 483,323 483,323 484,323 484,322 484,321 484,320 484,311 484,308 483,307 482,305 482,304 481,302 481,300 482,298 482,298 484,296 485,294 485,290 484,289 484,289 483,288 482,287 482,287 482,287 481,286 481,284 482,283 482,283 483,283 484,283 485,283 486,284 488,283 489,283 489,282 490,280 490,278 489,275 488,272 488,269 488,268 487,267 485,267 484,267 482,266 482,265 481,265 481,264 481,265 480,265 479,265 479,265 478,266 473,267 465,267 463,267 463,267 462,267 461,268 460,268 460,268 459,268 458,268 448,268 446,267 441,265 438,264 432,264 430,263 427,263 424,265 423,266 422,266 420,267 419,266 419,265 418,265 417,265 415,267 414,270 412,272 411,273 410,273 407,273 406,273 404,275 402,276 401,278 401,283 399,284 395,288 392,290 392,291 390,292 390,293 390,293 390,293 391,295 393,297 393,299 393,301 392,301 390,302 389,302 388,302 387,302 386,304 384,307 383,310 383,311 383,314 384,317 385,318 387,319 389,320 391,321 391,321 393,321 394,322 395,325 396,326 398,327 399,328 z").attr({fill: 'white',stroke: 'black',"stroke-width": '0.29','stroke-opacity': '1'}).data('id', 'path_ap');

        for (var i = 0; i < regions.length; i++) {

            // Change Yorkshire’s fill colour to gold
            if (regions[i].data('id') == 'iasi') {
                regions[i].node.setAttribute('fill', 'gold');
            }

            // Showing off
            regions[i].mouseover(function(e){
                this.node.style.opacity = 0.7;
                document.getElementById('region-name').innerHTML = this.data('region');
            });

            regions[i].mouseout(function(e){
                this.node.style.opacity = 1;
            });
        }

    </script>
</body>
</html>